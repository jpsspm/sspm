#!/usr/bin/env bash
###################################################################################################
#  this script is part of Epsilon(sspm) - https://jpsspm.github.io/sspm                           #
#  Copyright (C) 2021-2022 Joe Packar    (joepackar@gmail.com)                                    #
#                                                                                                 #
#      **** a package manager for linux-based Operating Systems built from scratch ****           #
#                                                                                                 #
# This program is free software; you can redistribute it and/or modify it under                   #
# the terms of the GNU General Public License as published by the Free Software                   #
# Foundation; either version 3 of the License, or (at your option) any later version.             #
#                                                                                                 #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       #
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       #
# See the GNU General Public License for more details.                                            #
#                                                                                                 #
# You should have received a copy of the GNU General Public License along with                    #
# this program.  If not, see <http://www.gnu.org/licenses/>.                                      #
#                                                                                                 #
# sspm require some external programs during its execution. You need to have at least             #
# the following installed for sspm to function: bsdtar (libarchive), gawk, zstd,                  #
#  coreutils, e2fsprogs, which, tar, grep, sed, pkg-config, Procps, find, xz                      #
###################################################################################################


# NOTE: sspm has been designed to assist a full build of a linux-based Operating System from "source",
#       if you are building one or simply using as packages manager, make sure you correctly set the "SRC"
#       variable in your shell or in the "~/.bashrc" file of your environment or system
#       (ex: export SRC=/tools/blabla/sources) before building a package.
#       
#
#        if you build a system the approach is: once the temporary tools are installed, place
#        this script in '/usr/bin' or elsewhere and make it executable. the idea is to unpack an archive
#        stored in "$SRC" and then compile and distort the installation of the package in a temporary 
#        clean environment, write the information needed to manage the package, then create the package.
#        sspm is mainly inspired from the 'lfs project' and 'makepkg'
#
#
#
#        attention some commands sometimes depends on comments written before/after other commands 
#        (ex: command -f something  # end of block)
#        the comment 'end of block' can be used as reper by another command, and so on...
#        modify only if you know and are sure of what you are doing.






# sspm isn't yet suitable for other SHELLS for the moment. exit if different from 'bash'.
if [[ "$SHELL" != *"bash" ]]; then
sleep 0.30
printf "\e[91mSorry\e[0m, only << bash >> is supported\n"
exit 1
fi

# dependencies check
if ( ! type awk bsdtar chattr find sha256sum ps sed tar which zstd &>/dev/null ); then
LINE="$(cat "$(realpath -q $0)" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0")"
if [[ "$LINE" == 'PKGDTB_DIGIT0=("")' || "$LINE" == 'PKGDTB_DIGIT0=()' \
|| "$LINE" == 'PKGDTB_DIGIT0=' || "$LINE" == 'local PKGDTB_DIGIT0=("")' \
|| "$LINE" == 'local PKGDTB_DIGIT0=()' || "$LINE" == 'local PKGDTB_DIGIT0=' ]]; then
if [[ -z "$SOURCES" || -z "$DESTDIR" ]]; then
printf "You have to manually install these packages:\n\e[4mwhich\e[0m, \e[4mzstd\e[0m, \e[4mlibarchive\e[0m, \e[4mpkg-config\e[0m, \e[4mprocps\e[0m \
et \e[4me2fsprogs\e[0m\nin a temporary directory to make sspm work\n\n\e[2m%1sthis can be done automatically by simply setting\n\
%1sthese both variables in your shell:\n ex: export \e[0m\e[1mSOURCES\e[0m\e[2m='/dir/containing/sources'\n\
%1sex: export \e[0m\e[1mDESTDIR\e[0m\e[2m='/dir/to_install/temp_packages'\n%1sthen rerun your command\n\n\
%1smake sure that you have these source files\n%1swith the following versions or later: \
libarchive v3.5.2, zstd v1.5.2\n%1spkg-config v0.29.2, which v2.21, procps-ng v3.3.17 et e2fsprogs v1.46.5\n\n\
%1sif you have already installed these packages, update and re-export\n\
%1sthe 'PATH' variable in your shell or simply source the .bashrc file\n%1sfor these packages to be visible in the environment\e[0m\n\n"
[[ ! -v "SOURCES" && -v "DESTDIR" ]] && printf "%1splease initialize the '\e[91mSOURCES\e[0m' variable\n\n" && exit 1
[[ ! -v "DESTDIR" && -v "SOURCES" ]] && printf "%1splease initialize the '\e[91mDESTDIR\e[0m variable'\n\n" && exit 1
exit 1
else
unset LINE
[[ "$DESTDIR" =~ /$ ]] && DESTDIR="${DESTDIR%?}"
[ ! -d "$SOURCES" ] && printf "error: cannot access the specified source directory\n" && exit 1
[ ! -d "$DESTDIR" ] && mkdir -p $DESTDIR
[ ! -d "$DESTDIR/lib" ] && mkdir -p $DESTDIR/lib
TEMP='/tmp'; BASHRC='.bashrc'

            if ! type which &>/dev/null && ! type "$DESTDIR/usr/bin/which" &>/dev/null && \
               ! type "$DESTDIR/bin/which" &>/dev/null; then
              FILE="$(find $SOURCES -iname "which*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'which' can't access the source file\n"; exit 1; fi
             printf '\n\n%9sBuilding sspm dependencies ...\n\n'; sleep 0.67
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr && \
		make && make install; cd $TEMP && rm -r $CD_DIR;
                   fi 
            if ! type zstd &>/dev/null && ! type "$DESTDIR/usr/bin/zstd" &>/dev/null && \
               ! type "$DESTDIR/bin/zstd" &>/dev/null; then
              FILE="$(find $SOURCES -iname "zstd*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'zstd' can't access the source file\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && \
                make && make prefix=/usr install; cd $TEMP && rm -r $CD_DIR;
                rm -v $DESTDIR/usr/lib/libzstd.a; mv -v $DESTDIR/usr/lib/libzstd.so.* $DESTDIR/lib
                SLINK0="$(find $DESTDIR -name "libzstd.so" -type l -print | head -1)"
                SLINK1="$(find $DESTDIR -name "libzstd.so.*" -type l -print | head -1)"
                ln -sfv ../../lib/$(readlink $SLINK0) $SLINK0
                ln -sfv $DESTDIR/lib/$(basename $(readlink $SLINK0)) /usr/lib/$(basename $SLINK0)
                ln -sfv $DESTDIR/lib/$(basename $(readlink $SLINK1)) /lib/$(basename $SLINK1)
                   fi
            if ! type pkg-config &>/dev/null && ! type "$DESTDIR/usr/bin/pkg-config" &>/dev/null && \
               ! type "$DESTDIR/pkg-config" &>/dev/null; then
              FILE="$(find $SOURCES -iname "pkg-config*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'pkg-config' can't access the source file\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --with-internal-glib --disable-host-tool && make && make install; cd $TEMP && rm -r $CD_DIR;
                   fi
              PATH=$PATH:$DESTDIR/bin:$DESTDIR/usr/bin:$DESTDIR/sbin:$DESTDIR/usr/sbin
            if ! type bsdtar &>/dev/null && ! type "$DESTDIR/usr/bin/bsdtar" &>/dev/null && \
               ! type "$DESTDIR/bin/bsdtar" &>/dev/null; then
              FILE="$(find $SOURCES -iname "libarchive*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'libarchive' can't access the source file\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --without-expat --without-xml2 --without-openssl --without-nettle \
               --disable-bsdcpio --disable-rpath --disable-static --with-zstd && \
               make && make install; cd $TEMP && rm -r $CD_DIR;
               SLINK0="$(find $DESTDIR -name "libarchive.so.*" -type l -print | head -1)"
               ln -sfv $(readlink -e $SLINK0) /usr/lib/$(basename $SLINK0)
                   fi
            if ! type ps &>/dev/null && ! type "$DESTDIR/usr/bin/ps" &>/dev/null && \
               ! type "$DESTDIR/bin/ps" &>/dev/null; then
              FILE="$(find $SOURCES -iname "procps*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'procps-ng' can't access the source file\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --exec-prefix= --libdir=/usr/lib --disable-static --disable-kill && \
               make && make install; cd $TEMP && rm -r $CD_DIR;
               mv -v $DESTDIR/usr/lib/libprocps.so.* $DESTDIR/lib;
               SLINK0="$(find $DESTDIR -name "libprocps.so" -type l -print | head -1)"
               SLINK1="$(find $DESTDIR -name "libprocps.so.*" -type l -print | head -1)"
               ln -svf ../../lib/$(readlink $SLINK0) $SLINK0
               ln -svf $DESTDIR/lib/$(basename $(readlink $SLINK0)) /lib/$(basename $SLINK0)
               ln -svf $DESTDIR/lib/$(basename $(readlink $SLINK1)) /lib/$(basename $SLINK1)
                   fi
            if ! type chattr &>/dev/null && ! type "$DESTDIR/usr/bin/chattr" &>/dev/null && \
               ! type "$DESTDIR/bin/chattr" &>/dev/null; then
              FILE="$(find $SOURCES -iname "e2fsprogs*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerror: 'e2fsprogs' can't access the source file\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && mkdir -pv $TEMP/$CD_DIR/build && \
               cd $TEMP/$CD_DIR/build && ../configure --prefix=/usr --bindir=/bin --with-root-prefix="" \
               --enable-elf-shlibs --disable-libblkid --disable-libuuid --disable-uuidd --disable-fsck && \
               make && make install; cd $TEMP && rm -r $CD_DIR; rm -fv $DESTDIR/usr/lib/{libcom_err,libe2p,libext2fs,libss}.a;
               SLINK0="$(find $DESTDIR -name "libcom_err.so.*" -type l -print | head -1)"
               SLINK1="$(find $DESTDIR -name "libe2p.so.*" -type l -print | head -1)"
               ln -svf $DESTDIR/lib/$(readlink $SLINK0) /lib/$(basename $SLINK0)
               ln -svf $DESTDIR/lib/$(readlink $SLINK1) /lib/$(basename $SLINK1)
               printf 'export PATH='$PATH'\n' >> $HOME/$BASHRC
               printf '\n%10s*** successfully done ***\n\n'
               printf "\e[2m%1supdate and reexport the 'PATH' variable in your shell by adding\n"
               printf "%1s'$DESTDIR' (ex: export PATH=\$PATH:$DESTDIR/bin)\n%1sor simply source the .bashrc file\n\n"
               printf "%1sDonâ€™t forget to unset 'SOURCES' and 'DESTDIR'\e[0m\n\n"; exit
                   fi
                   
                                                        if [[ -f $HOME/$BASHRC ]]; then
                                                        if test -n "$(sed -n '/\(^PATH.*$\)/h; ${x;p;}' $HOME/$BASHRC)"; then
                                                        source $HOME/$BASHRC
                                                        if ( ! type awk bsdtar chattr find sha256sum ps sed tar which zstd &>/dev/null ); then
                                                        printf "fatal error: please source your '.bashrc' file\n"
                                                        printf "%15sor update and export the 'PATH' variable\n\n" && exit 1
                                                        fi else
                                                        printf "fatal error: maybe you have to source your '.bashrc' file\n"
                                                        printf "%15sor update and export the 'PATH' variable\n\n" && exit 1
                                                        fi else
                                                        printf "fatal error: please source your '.bashrc' file\n"
                                                        printf "%15smaybe you missed to update the 'PATH' variable\n\n" && exit 1
                                                        fi
fi else sleep 0.10; unset LINE
PRINT_INFOS=YES
fi else TAR=bsdtar; umask 022; fi



SSPM_VER=
TMP="/tmp"
TAG="pkg"
PIPE="/dev/ilpc"
GROUP="sspm"
SYMBOLE="---->"
BUILDFILE="pkgbuild"
INFOFILE="pkginfo"
PKG_SHA=".cpkg"
PKG_INSTALL="pkginst"
FILES_SHA=".cfiles"
INS_FILE=".install"
PKGDIR="/var/cache/pkg"
PKG_DTB="pkginfos.dtb"
LOGFILE="install.log"
FAKEROOT="$TMP/fakeroot"
LOCALROOT="/"
OKCODE="0"
ERCODE="1"
DEPEND_ERCODE="7"
ARCH="$(uname -m)"
export BDIR="$(pwd -P)"
PKGEXT="tar.zst"
TEXT0="name"
TEXT1="version"
TEXT2="revision"
TEXT3="architecture"
TEXT4="build on"
TEXT5="build at"
TEXT6="type"
TEXT7="depend on"
TEXT8="make dependence to"
TEXT9="size"
TEXT10="packager"
TEXT11="about"
TEXT12="elapsed time"
DIALOG=
PARSEID="# parse options"
OPTIONS="--options"
COMMENT0="Package:"
COMMENT1="directories"
COMMENT2="files"
COMMENT3="folders"
COMMENT4="files"
COMMENT5="found"
COMMENT6="Installed"
COMMENT7="and"
COMMENT9="total"
COMMENT10="size"
LV_COMPRESS="compression-level=22"
COMPRESS_AS=($OPTIONS=$LV_COMPRESS)
DTBFILE0="$PKGDIR/database/$LOGFILE"
DTBFILE1="$PKGDIR/database/$PKG_DTB"
# this remove some commands errors if you run 
# this program with '../sspm' style
SCRIPTFILE="$(realpath -q $0)"
SCRIPTFILE="${SCRIPTFILE:-$0}"








sspm_version() {
if [[ "$RANDOM" =~ $"6" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%2s*********************\n%2s*%19s*\t\tThis is free software:\n\
%2s*%6s\e[94mS%1sS%1sP%1sM\e[0m%6s*\t\tyou are free to change and redistribute it.\n\
%2s*%19s*\t\tThere is NO WARRANTY, to the extent permitted by law.\n%2s*********************\
\t\tLicense GPLv3+: GNU GPL version 3\n%32sor later <http://gnu.org/licenses/gpl.html>.\n%32sWritten by joe packar\n"
elif [[ "$RANDOM" =~ ^"5" || "$RANDOM" =~ ^[1_1_]+$ ]]; then
printf "%13ssspm  v$SSPM_VER\n\
%6s\e[1mS\e[0m%6sCopyright (C) 2021-2022 Free Software Foundation, Inc.\n\
%6s\e[1mS\e[0m%6sLicense GPLv3+: GNU GPL version 3 or later\n\
%6s\e[1mP\e[0m\n\
%6s\e[1mM\e[0m%6sThis is free software: free to change and to redistribute\n\
%13sunder the terms of the GNU General Public License\n\
%13sas published by the Free Software Foundation\n\
%13sThere is NO WARRANTY, to the extent permitted by law.\n\n"
elif [[ "$RANDOM" =~ $"7" || "$RANDOM" =~ ^[6_2_]+$ ]]; then
printf "%21sOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n\
%21sO%2sCopyright (C) 2021 Free Software Foundation, Inc.%13sO\n%21sO%2sLicense GPLv3+: GNU GPL version 3 or later%20sO\
\n%21sO%64sO\n%21sO%2ssspm  v$SSPM_VER%50sO\n%21sO%2sunder the terms of the GNU General Public License%13sO\n%21sO%2sfree for you\
%1sto change or to redistribute this software%7sO\n%21sO%2sThere is NO WARRANTY, to the extent permitted by law.%9sO\n%21sO%64sO\n\
%21sO%2sWritten by  Joe Packar.%39sO\n%21sOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\v\n"
elif [[ "$RANDOM" == *3*5 ]]; then
printf "sspm is v$SSPM_VER\n"
elif [[ "$RANDOM" =~ ^"3" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s\e[90m-------------------\e[0m\n%2s\e[90m|\e[0m%19s\e[90m|\e[0m\t\tYes you right, sspm is free.\n\
%2s\e[90m|\e[0m%6s\e[1m\e[90mS%1sS\e[0m%1s\e[1mP%1sM\e[0m%6s\e[90m|\e[0m\t\tyou can redistribute or change it\n\
%2s\e[90m|%19s|\e[0m\t\tunder the terms of the GNU General Public License\e[90m\n%3s-------------------\e[0m\
\t\tas published by the Free Software Foundation\n%32seither version 3 of the License or\n%32s(at your option) any later version.\n"
elif [[ "$RANDOM" == *0*0* ]]; then
printf "%csspm  v$SSPM_VER\nCopyright (C) 2021-2022 Free Software Foundation, Inc.\n\
License GPLv3+ : GNU GPL version 3 or later\nthis is free software: redistribute or change it\nbut without any WARRANTY.\n\
See the GNU General Public License for more details.\v\nWritten by Joe Packar.\n"
elif [[ "$RANDOM" == 2*8 ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021 Joe Packar\n\
%3s\e[91m-------------------\e[0m\n%2s\e[91m|\e[0m%19s\e[91m|\e[0m\t\tthis is free software:\n\
%2s\e[91m|\e[0m%6s\e[94mS%1sS%1sP%1sM\e[0m%6s\e[91m|\e[0m\t\tyou can redistribute or change it\n\
%2s\e[91m|\e[0m%19s\e[91m|\e[0m\t\tunder the terms of the GNU General Public License\n%3s-------------------\
\t\tas published by the Free Software Foundation\n%32seither version 3 of the License or\n%32s(at your option) any later version.\n"
elif [[ "$RANDOM" == *7*4* ]]; then
printf "sspm is v$SSPM_VER\n"
elif [[ "$RANDOM" == 1*9 ]]; then
printf "%13ssspm  v$SSPM_VER\n\
%6s\e[1m\e[35mS\e[0m%6sCopyright (C) 2021 Free Software Foundation, Inc.\n\
%6s\e[1m\e[35mS\e[0m%6sLicense GPLv3+: GNU GPL version 3 later\n\
%6s\e[1m\e[35mP\e[0m\n\
%6s\e[1m\e[35mM\e[0m%6sthis is free software: you are free to change and to redistribute it\n\
%13sunder the terms of the GNU General Public License\n\
%13sBut there is NO WARRANTY, to the extent permitted by law.\n\n"
elif [[ "$RANDOM" =~ ^"2" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s-------------------\n%2s|%19s|\t\tthis is free software.\n\
%2s|%6s\e[94mS%1sS%1sP%1sM\e[0m%6s|\t\tyou are free to change or to redistribute it\n\
%2s|%19s|\t\tunder the terms of the GNU General Public License\n%3s-------------------\
\t\tas published by the Free Software Foundation.\n%32seither version 3 of the License or\n%32s(at your option) any later version.\n"
elif [[ -z "$RANDOM" || ! -e "$RANDOM" ]]; then
printf "%csspm  v$SSPM_VER\nCopyright (C) 2021-2022\nLicense GPLv3+ : GNU GPL version 3 or later\n\
this is free software: change and redistribute it\nBut there is NO WARRANTY, without even the implied\
%1swarranty \nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
See the GNU General Public License for more details.\v\nWritten by Joe Packar.\n"
else
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s\e[90m-------------------\e[0m\n%2s\e[90m|\e[0m%19s\e[90m|\e[0m\t\tthis is free software:\n\
%2s\e[90m|\e[0m%6s\e[1mS%1sS%1s\e[90mP%1sM\e[0m%6s\e[90m|\e[0m\t\tyou can change and redistribute it\n\
%2s\e[90m|%19s|\e[0m\t\tunder the terms of the GNU General Public License\e[90m\n%3s-------------------\e[0m\
\t\tas published by the Free Software Foundation.\n%32seither version 3 of the License or\n%32s(at your option) any later version.\n"
fi
}




usage() {
cat <<EOF
sspm $SSPM_VER
Build a package from source

Usage: sspm [options] <name|package|dir>

Options:
 -b, --build           Build       package
 -i, --install         Install     package
 -R, --remove          Uninstall   package
 -d, --debug           Debug mode
 -o, --destdir         Save the package to ...
 -s, --source          Fetch sources [x]
 -p, --path            installation history
 -pi, -ip              Package Informations
 -bi, -ib              Build and install package
 -l, --list            List all installed packages
 -h, --help            Print this help and exit
 -v, --version         Print the version and exit
     --depends         print installed dependencies
     infos             man page
     
     set 'LV_BUILD=[on/y/yes]'
     then type 'sspm -b' for interactive mode
     
     export PKG_GROUP=group
     set all next packages as type 'group'
     see PKG_GROUP environment variable section
     for possible values.
   

EOF
exit
}










sspm_infos() {
sspm_man_infos() {
clear
printf "SSPM(1)\n\n\
NAME\n\
     sspm - packages manager\n\n\
SYNOPSIS\n\
       sspm [\e[4mOPTION\e[0m]... [\e[4mNAME|PACKAGE|DIR\e[0m]... [\e[4mOPTION\e[0m]...\n\n\
DESCRIPTION\n\
       build from sources, install, list or uninstall packages.\n\n\
       -b, --build\n\
            Build a package\n\
            passing only this option with 'LV_BUILD' environment variable set will run an interactive mode.\n\
            see LV_BUILD environment variable section to learn more\n\n\
       -i, --install\n\
            Install a package\n\n\
       -R, --remove\n\
            Uninstall a package\n\n\
       -d, --debug\n\
            Debug mode\n\n\
       -s, --source\n\
            Fetch sources [x] (not yet available)\n\n\
       -o, --destdir=\e[4mPATH\e[0m\n\
            Save package/file to. the default dir is the working directory.\n\
            this option can also be used with '-pe'\n\n\
       -r, --root=\e[4mPATH\e[0m\n\
            Destination, new root\n\n\
       -p, --path\n\
            Package installation history\n\n\
       -pi, --print-infos\n\
            Package informations\n\n\
       -bi,\n\
            Install package after successful build\n\n\
       -l, --list\n\
            List all installed packages\n\
           --list --root=/mnt/new_root\n\
            List all installed packages from root '/mnt/new_root'\n\n\
       -rtf, --remnant-files\n\
            Clean remnant temp files\n\n\
       -eh,-wh   --enable-hash, --with-hash\n\
            generate a checksum (sha256sum)\n\n\
       -q, --quiet\n\
            Quiet successful build text\n\n\
       -qq, --quiet-all\n\
            Quiet all and show only the installation dialog if '-i' was passed\n\n\
       -aq, --always-quit\n\
            This permanently enable/disable the '-q' option\n\n\
       -pe, -ep, --pkgbuild-example\n\
            Generate an empty '$BUILDFILE' file\n\n\
       -h, --help\n\
            Print a short description\n\n\
       -v, --version\n\
            Print the version\n\n\
           --depends\n\
            Print 'sspm' installed dependencies versions\n\n\
           info/infos\n\
             Print this page\n\n\
       Exemples:\n\
         * sspm -b (with 'pkgbuild' in working directory)\n\
         * sspm -i foo.tar.zst (install foo)\n\
         * sspm -i foo.tar.zst --root /somedir (install foo to root 'somedir')\n\
         * sspm -bi (build and install package)\n\
         * sspm --path foo (where foo files are installed)\n\
         * sspm --root=/mnt/new_root -p foo (from root '/mnt/new_root' where foo files are installed)\n\
         * sspm -i -r /mnt/new_root -b --with-hash (build, generate a checksum and install the package to /mnt/new_root)\n\
         * sspm -bi --root /mnt/new_root --destdir='../saves' -wh
         * sspm infos (the man page)\v\n\
       
\e[1mENVIRONMENT\e[0m\n\
%7syou may need the '-E' option with if you use the 'sudo' command (preserve existing environment variables)\n\n\
%7s*%1sSRC\n%10sfetch sources from (ex: export SRC=~/all_sources_files) \n\n\
%7s*%1sPKG_SRC\n%11sabsolute path to source file, set this variable if sspm can't determinate the package source file\n\
%11suseful if the package name given in '$BUILDFILE' is different from its source file\n\n\
%7s*%1sPM_CONFDIR\n%11soverwrite the default sspm config directory\n\
%11sby default its '~/.config/sspm' you don't need to set this variable again at next session\n\n\
%7s*%1sPATH\n%11syou are at chroot stage (you've just chrooted in your temp environment).\n\
%11s'sspm' need these packages: 'bsdtar (libarchive), zstd, coreutils, e2fsprogs, which, tar\n\
%11spkg-config, grep, sed, xz, gawk, procps' in that environment to work.\n\
%11swhere the same packages must be build with sspm in a specific order. for not breaking libraries\n\n\
%11screate a temporary directory and install manually the packages listed above\n\
%11s(only not available packages) in that directory with maximum disabled features.\n\
%11s(ex: ./configure --disable-XXXXX --without-YYYYY && make && make DESTDIR=/dir/tmp_outils install)\n\
%11sAfter that reset the 'PATH' variable by including '/dir/tmp_outils/bin' for these packages to be visible.\n\
%11sremove that directory once you have permanently built and installed these packages\n\n\
%11s\e[4mexample\e[0m:\n\
%11scat > ~/.bashrc <<EOF\n\
%11s\e[90mexport PATH=\$PATH:/tools/sspm_tools/bin:/tools/sspm_tools/usr/bin\n%11sexport SRC=/sources\e[0m\n%11sEOF\n\n\
%7s*%1sEXCLUDE/IGNORE or NOT_TRACE_PATH\n%11s(ex: root:# export NOT_TRACE_PATH=/mnt/mounted_root)\n%11stell sspm that '/mnt/mounted_root' is not part of filesystem while tracking broken symbolic links\n\
%11snecessary if you have a mounted filesystem/toolchain for example\n\
%11syou need to set this variable if you have a mounted filesystem while acting (install/uninstall)\n%11sin the base system (where sspm is installed)\v\n\
%7s*%1sPKG_GROUP=group\n%11s(this variable takes effect only if the 'groups' variable is empty in 'pkgbuild' file)\n\
%11sset all next packages as type 'group', possible values are: base , add , opt , other\n%11sif nothing is done even in the 'pkgbuild' file, the group will be 'other'\n\
%11snote: here 'opt' for optionnal package nothing to do with '/opt'\v\n\
%7s*%1sPACKAGER=name\n%11s(this variable takes effect only if the 'packager' variable is empty in 'pkgbuild' file) built by 'name'\v\n\
%7s*%1sLV_BUILD=[on/y/yes]\n%11screate even install a package interactively instead of using a '$BUILDFILE' file\v\v\n\
\e[1mTHE PKGBUILD FILE:\e[0m\n\
cat $BUILDFILE\n\n\e[90m\
pkgname=foo\n\
pkgver=2.3\n\
pkgrev=1\n\
pkgdesc="'"'"foo contains the libfoo... ."'"'"\n\
url="'"'"https://www.source-foo.org/release/"'"'"\n\
groups=base\n\
depends=(xxx yyy)\n\
makedepend=()\n\
packager="'"'"name"'"'"\n\
tfext=tar.gz\n\n\n\n\
build() {\n\
./configure --prefix=/usr              \\\ \n\
            --with-XXX-YYY             \\\ \n\
            --disable-XXX-ZZZ          \\\ \n\
            --docdir=/dir/dir/doc\n\n\
make\n\
make check\n\
make DESTDIR="'$'"pkgdir install\n\
}\e[0m\n\n\
note:%5swhatever build function name build_foo() { commands }, foo_build() { commands },\n\
%9s foo() { commands } should work, but leave build() { commands } to keep it simple.\v\n\
%9s leaving the 'tfext' variable empty in (pkgbuild) file,\n\
%9s tell sspm to directly search the source file by matching the name and the version.\n\
%9s instead of doing an if file exist before doing pattern matching\n\
%9s if you apply a patch and you have an error like:\n\
\t\t\t**** can't find file to patch at input line 23 ****\n\
%9s do a 'cd right_extract_directory' before the 'patch' command in (pkgbuild) file\n\n\

\e[1mEXIT STATUS:\e[0m\n\
        0        if OK,\n\
        1        if an error ...\n\
	mostly you will have a message explaining failures reasons, well almost\v\n\
\e[1mAUTHOR\e[0m\n\
      Written by Joe Packar.\n\
      repport bugs at https://github.com/jpsspm/sspm/issues/\n\
      home page: https://jpsspm.github.io/sspm/\n\n\
\e[1mCOPYRIGHT\e[0m\n\
         Copyright \xc2\xa9 2021-2022 Free Software Foundation, Inc.\n\
         License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\n\
         This is free sortware: you can change and redistribute it.\n\
         There is NO WARRANTY, to the extent permitted by law.\v\v\n
sspm $SSPM_VER%66sJanuary 2022%66sSSPM(1)   \n"
}




sspm_err_infos() {
clear
printf "\e[93mNOTE:\e[0m there are (3) important variables\v\n\
%7s*%1sSRC\n%10sfetch sources from (ex: export SRC=~/all_sources_files) \n\n\
%7s*%1sPATH\n%11syou are at chroot stage (you've just chrooted in your temp environment).\n\
%11s'sspm' need these packages: 'bsdtar (libarchive), zstd, coreutils, e2fsprogs, which, tar\n\
%11spkg-config, grep, sed, xz, gawk, procps' in that environment to work.\n\
%11swhere the same packages must be build with sspm in a specific order. for not breaking libraries\n\n\
%11screate a temporary directory and install manually the packages listed above\n\
%11s(only not available packages) in that directory with maximum disabled features.\n\
%11s(ex: ./configure --disable-XXXXX --without-YYYYY && make && make DESTDIR=/dir/tmp_outils install)\n\
%11sAfter that reset the 'PATH' variable by including '/dir/tmp_outils/bin' for these packages to be visible.\n\
%11sremove that directory once you have permanently built and installed these packages\n\n\
%11s\e[4mexample\e[0m:\n\
%11scat > ~/.bashrc <<EOF\n\
%11s\e[90mexport PATH=\$PATH:/tools/sspm_tools/bin:/tools/sspm_tools/usr/bin\n%11sexport SRC=/sources\e[0m\n%11sEOF\n\n\
%7s*%1sEXCLUDE/IGNORE or NOT_TRACE_PATH\n%11s(ex: root:# export NOT_TRACE_PATH=/mnt/mounted_root)\n%11stell sspm that '/mnt/mounted_root' is not part of filesystem while tracking broken symbolic links\n\
%11snecessary if you have a mounted filesystem/toolchain for example\n\
%11syou need to set this variable if you have a mounted filesystem while acting (install/uninstall)\n%11sin the base system (where sspm is installed)\v\n"
}



case "$1" in
      "err" )  sspm_err_infos ;;
      '' )   sspm_man_infos ;;
      *)    exit $ERCODE ;;
esac


}





                                   if [[ -n $PRINT_INFOS && $PRINT_INFOS == "YES" ]]; then
                                       sspm_infos err
                                      printf '\n'
                                    printf '\n'
                                  printf '\n'
                                printf "\e[91m==> ERROR: \e[0mmissing dependencies\n"
                               printf "\e[2mmake sure to have at leaste these packages installed:\e[0m\n"
                               printf "\e[2mwhich, tar, gawk, grep, pkg-config, find, sed, xz, zstd, libarchive, coreutils, Procps, e2fsprogs\e[0m\n"
                               printf '\n'
                               printf '\n'
                               exit $DEPEND_ERCODE
                               fi










                                                                   # these directories are used as reference to base directories
                                                                   # feel free to ajust as you wish
                                                                   # ###########################################################
                                                                          sysdirs=(bin boot color cache dev doc etc lib \
                                                                          lib64 firmware locale home opt srv sbin usr \
                                                                          include local locate sysconfig media floppy \
                                                                          cdrom info log mail opt pkgconfig proc spool \
                                                                          man man1 man2 man3 man4 man5 man6 man7 man8 \
                                                                          share sys dict misc mnt run root var lock tmp \
                                                                          terminfo zoneinfo)


####################################################################################################################################################################################################
############ #############:                                                                                                                                                                        #
############ * nothing will be done if the script is run as or with 'root' rights but for 'non-root' users the script will try to access the default config directory                              #
############ * which is '~/.config/script_name' unless you specify another directory with 'PM_CONFDIR' environment variable                                                                        #
############   in both cases the directory will be created if does not exist                                      ( make sure to have the write access to the specified path 'PM_CONFDIR' )        #
############ * then a user restricted pipe will be created for synchronization purposes                                                   ( needed for multiple build in different shells )        #
############ * and if you set 'PM_CONFDIR' its value will be saved in the script                                                                                                                   #
####################################################################################################################################################################################################
#  if you use the 'sudo' command with a special configuration you need to ajust according to your needs the code block down below                                                                  #
####################################################################################################################################################################################################
                                                                                                                                                                                                   #
                                                                                                                                                                                                   #
                                                                                                                                                                                                   #
                if [[ "${EUID:-$(id -u)}" -eq 0 ]]; then                                                                                                                                           #
                [[ ! -p "$PIPE" ]] && mkfifo -m 660 "$PIPE"                                                                                                                                        #
                else                                                                                                                                                                               #
                if [[ -z "$PERM_PM_CONFDIR" || (( -n "$PM_CONFDIR" && ! "$PM_CONFDIR" =~ "$PERM_PM_CONFDIR" )) ]]; then                                                                            # 
                if [[ -n "$PM_CONFDIR" ]]; then                                                                                                                                                    #
                if [[ ! -d "$PM_CONFDIR" ]]; then                                                                                                                                                  #
                printf "===> '$PM_CONFDIR' not found\ncreating directory\n\n"                                                                                                                      #
                mkdir -p "$PM_CONFDIR"                                                                                                                                                             #
                fi                                                                                                                                                                                 #
                if [[ $? -ne 0 ]]; then                                                                                                                                                            #
                printf "make sure to have write privileges on parents directories\n"                                                                                                               #
                printf "or unset 'PM_CONFDIR' to use default directory '~/.config/$(basename $SCRIPTFILE)'\n\n"                                                                                             #
                printf "\e[91merror :\e[0m  aborted\n"                                                                                                                                             #
                exit $ERCODE                                                                                                                                                                       #
                else                                                                                                                                                                               #
                CHECK_VAR=Y                                                                                                                                                                        #
                fi                                                                                                                                                                                 #
                [[ "$PM_CONFDIR" =~ /$ ]] && PM_CONFDIR="${PM_CONFDIR%?}"                                                                                                                          #
                PIPE="$PM_CONFDIR/ilpc"                                                                                                                                                            #
                else                                                                                                                                                                               #
                DEFAULT_USER_CFG_DIR="$HOME/.config/$(basename $SCRIPTFILE)"                                                                                                                                #
                [[ -d $DEFAULT_USER_CFG_DIR ]] || mkdir -p $DEFAULT_USER_CFG_DIR                                                                                                                   #
                PIPE="$DEFAULT_USER_CFG_DIR/ilpc"                                                                                                                                                  #
                fi                                                                                                                                                                                 #
                [[ ! -p "$PIPE" ]] && mkfifo -m 660 "$PIPE"                                                                                                                                        #
                else                                                                                                                                                                               #
                PIPE="$PERM_PM_CONFDIR/ilpc"                                                                                                                                                       #
                [[ -d "$PERM_PM_CONFDIR" ]] || mkdir -p $PERM_PM_CONFDIR                                                                                                                           #
                [[ -p "$PIPE" ]] || mkfifo -m 660 "$PIPE"                                                                                                                                          #
                fi                                                                                                                                                                                 #
                fi                                                                                                                                                                                 #
                                                                                                                                                                                                   #            
                # NOTE: for 'root' the pipe is created in '/dev'                                                                                                                                   #
                #       for 'non-root' users we cannot write in '/dev' a good place to go is somewhere like '~/.config/script_name'                                                                #
                #       the next commands will be executed only if you change the default behaviour with 'PM_CONFDIR'                                                                              #
                if [[ -n $CHECK_VAR && $CHECK_VAR = [yY] ]]; then                                                                                                                                  #
                                                                                                                                                                                                   #                
                # we want to run one command with 'root' privileges                                                                                                                                #
                # to make sense of the ( $EUID -qe 0 ) condition given above, we need to run 'sudo' in the script to do a password request                                                         #
                # because running the whole script with 'sudo without options' gives you an EUID = 0 so the root condition is satisfied                                                            #
                                                                                                                                                                                                   #                
                # if [ run as a non-privileged user ] --> [ request password (with sudo and reset timestamp at the end of command) ] -->                                                           #
                #    [ make change ] -->  [ continue running as a non-privileged user ] fi                                                                                                         #
                                                                                                                                                                                                   #
                                                                                                                                                                                                   #                
                                                                                                                                                                                                   #      
                if grep -q ^"PERM_PM_CONFDIR=" $SCRIPTFILE; then                                                                                                                                            #
                    if [[ ! "$PM_CONFDIR" =~ ^"$PERM_PM_CONFDIR"$ ]]; then                                                                                                                         #
                      PM_CONFDIR="$(printf "$PM_CONFDIR" | sed 's/\//\\\//g')"                                                                                                                     #
                       if ( type -t sudo &>/dev/null ); then                                                                                                                                       #
                       printf "\n%2s*%1schanging configuration directory\n\n"                                                                                                                      #
                       sudo -k sed -i '/^PERM_PM_CONFDIR=.*/s/PERM_PM_CONFDIR=.*/PERM_PM_CONFDIR="'$PM_CONFDIR'"/' "$SCRIPTFILE"                                                                            #
                       else                                                                                                                                                                        #
                       printf "\e[91merror:\e[0m 'sudo' not found.  run this as root\n\n"                                                                                                          #
                       exit $ERCODE                                                                                                                                                                #
                      fi                                                                                                                                                                           #
                    fi                                                                                                                                                                             #
                else                                                                                                                                                                               #
                    if ( type -t sudo &>/dev/null ); then                                                                                                                                          #
                      printf "\n%2s*%1schanging configuration directory\n\n"                                                                                                                       #
                       PM_CONFDIR="$(printf "$PM_CONFDIR" | sed 's/\//\\\//g')"                                                                                                                    #
                       sudo -k sed -i "/^DTBFILE1=/aPERM_PM_CONFDIR=\"$PM_CONFDIR\"" $SCRIPTFILE                                                                                                            #
                       else                                                                                                                                                                        #
                       printf "\e[91merror:\e[0m 'sudo' not found.  run this as root\n\n"                                                                                                          #
                      exit $ERCODE                                                                                                                                                                 #
                    fi                                                                                                                                                                             #
                fi                                                                                                                                                                                 #
                  if [[ $? -ne 0 ]]; then                                                                                                                                                          #
                   printf "\nyou need root privileges to set 'PM_CONFDIR' value as default configuration directory\n\n"                                                                            #
                   printf "%2s*%1srerun your command with 'sudo'\n%2s*%1sor unset 'PM_CONFDIR' to act default\n\n"                                                                                 #
                   printf "\e[91merror :\e[0m  aborted\n"                                                                                                                                          #
                   exit $ERCODE                                                                                                                                                                    #
                  fi                                                                                                                                                                               #
                fi                                                                                                                                                                                 #
                                                                                                                                                                                                   #  
####################################################################################################################################################################################################                

                                           # The home made ipc_tool (inter-process communication tool). we use a named pipe here 
                                           # the main role of the ipc_tool is to check if there is not another
                                           # instance of this script manipulating the database in another shell
                                           # because we generate a checksum at the end of every database manipulation process
                                           # it's necessary for the database to not be manipulated by two instances of this script at the same time
                                           #
                                           #  we want to deny access to the database when it is in use
                                           #  there are several methods to complete this
                                           #  but even simplest methods (such us using a regular file/or simply locking the database)
                                           #  can bring complexe issues to solve
                                           #  one of the benefit of using a named pipe is that it's a volatile file, it's fast ...
                                           #################################################################################################################
                                           ipc_tool() 
                                           {
                                           local ERCODE=89
                                           local rep0='1'
                                           if [[ -n "$1" && "$#" = 1 ]]; then
                                             if [[ "$1" == "-c" || "$1" == "-C" ]]; then local option='1';
                                             elif [[ "$1" == "-l" || "$1" == "-L" ]]; then local option='2';
                                             elif [[ "$1" == "--break" || "$1" == "-s" ]]; then local option='0';
                                             else printf "\e[91munrecognized entry\e[0m\n" && exit $ERCODE; fi
                                             else
                                             printf "\e[91munrecognized entry\e[0m\n"; exit $ERCODE
                                           fi                                              
                                            if [[ "$option" = "0" ]]; then
                                            timeout 0.5s cat "$PIPE" &>/dev/null
                                            if [ ! $? = 0 ]; then
                                            printf "\e[91merror: \e[0mipc signal interruption has failed\n"
                                            exit $ERCODE
                                            fi
                                            fi
                                           if [[ "$option" == "1" ]]
                                           then
					      count() { printf "$(( $(printf $#) + 1 ))"; }
                                              export SUFIX="$(count $(ls -pa1 $TMP | sed -n '/\(.*'"$BUILDFILE"'*.\)/p' | tr '\n' ' '))"
                                              export TMPFILE=""$TMPFILE"$SUFIX"
                                           elif [[ "$option" == "2" ]]
                                           then
                                           local pid0="$(timeout --preserve-status 0.10s cat "$PIPE")"
                                           if [ -z "$pid0" ]; then
                                             printf "$$" > $PIPE &
                                           else
                                           if [ "$pid0" != "$$" ]; then
                                           if ps -fs --pid "$pid0" &>/dev/null; then
                                           case $RANDOM in
                                             *45*|1*2*8| *3*3)  printf "error: it looks like database is busy\n" ;;
                                             *9*1|*5*6| *7*4*)  printf "error: cannot lock database\n" ;;
                                             *7*0*|*2*1*| 5*4*) printf "error: the database is in use\n" ;;
                                              ''|*)             printf "error: unable to lock database\n" ;;
                                           esac
                                           printf "$pid0" > $PIPE &
                                           exit $ERCODE
                                           else
                                           printf "$$" > $PIPE &
                                           fi
                                           else
                                           printf "$$" > $PIPE &
                                           fi                            
                                           fi
                                           fi
                                         }
                                               






make_sum_check() {
local ERCODE=6
local TMPFILE=$(mktemp $TMP/msc.XXXXXX)
####################Parse options
######################################################
if [[ -z "$1" ]]; then
printf "\e[93mmake sum check:\e[0m at least one entry is required\n"
return $ERCODE
fi

if [ "$#" = "4" ] && [[ "$1" = "-c" || "$1" = "--check" ]] && [ -e "$2" ] && \
[[ "$3" = "-i" || "$3" = "--input" ]] && [ ! -z "$4" ]; then
local MODE=check
local TARGET="$2"
local INPUT="$4"
elif [ "$#" = "4" ] && [[ "$1" = "-g" || "$1" = "--gen" ]] && [ -e "$2" ] && \
[[ "$3" = "-o" || "$3" = "--output" ]] && [ ! -z "$4" ]; then
local MODE=gen
local TARGET="$2"
local OUTPUT="$4"
else
printf "\e[91m==> ERROR:\e[0m unrecognized option.\n\
\e[90mex: make_sum_check -g something -o write_hash_to_this_file\e[0m\n\
\e[90mex: make_sum_check -c something -i file_contains_hash\e[0m\n\
\e[90mnote: make sure to be in the right directory before performing this\e[0m\n"
exit 13
fi
###########  if the "check" or "gen" condition is satisfied
########################################################################
if [[ -n "$MODE" && "$MODE" == "check" ]]; then
sha256sum --quiet -c "$INPUT" &>/dev/null
if [ "$?" != "0" ]; then
if [[ "$INPUT" == "$FILES_SHA" ]]; then
printf "\e[93mwarning:\e[0m some errors occurred when checking some files\n\n"
read -p "do you want to Continue with installation (y/n) : " REP
case $REP in [yY] | '')  printf '\n' ;; [nN] ) exit ;; *) exit ;; esac
fi
fi
elif [[ -n "$MODE" && "$MODE" == "gen" ]]; then
printf "#%13shash of "$pkgname-$pkgver" on '$BUILDDATE' generated by 'make sum check'\n\
#....................................................................................................\n" > "$TMPFILE";
find $TARGET -type f -exec sha256sum {} \; | tee >> "$TMPFILE" && cat $TMPFILE > $OUTPUT && rm -f $TMPFILE;
sleep 1; else printf "checksum failed\n"; exit 12
fi
}









check_dtb() {
local ERCODE=143
local FNAME=".asosdtb"
if [[ -n "$2" ]]; then
if [[ "$2" =~ ^-[[:alpha:]]$ && (( "$2" = "-i" || "$2" = "-r" || "$2" = "-f" )) ]]; then
[[ "$2" == "-i" ]] && local processtype="installation"
[[ "$2" == "-r" ]] && local processtype="uninstallation"
else printf "\e[91munrecognized entry\e[0m\n" && exit $ERCODE; fi
fi; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set +x
# sspm use two regular files as database to save packages informations
# normally only the owner user can manipulate these files; here checksums are used only to synchronize and authenticate 
# last wrintten data, in order to remove or to save other data. from the first installation the 'PKGDTB_DIGIT0' variable
# will save the digit part of files hashs and will be match at the next use
# note: this is done only for the base system (where sspm is installed) not distant/mounted 'root'.


local PKGDTB_DIGIT0=()



local PKGDTB_DIGIT1="$(sha256sum "$DTBFILE0" 2>/dev/null | tr -d -c '[[:digit:]]')"
local PKGDTB_DIGIT1+="$(sha256sum "$DTBFILE1" 2>/dev/null | tr -d -c '[[:digit:]]')"
local REFVARFORM="$(sed -n '/\(^local PKGDTB_DIGIT0=(.*)$\)/ {p;q}' < "$SCRIPTFILE")"
local REFVARVALUE="$(cut -d= -f2- <<< "$REFVARFORM" | tr -d -c '[[:digit:]]')"
local REFVARBYTES="$(wc -c <<< "$REFVARVALUE")"

if [[ -z "$1" ]]; then
   if [[ -z "${PKGDTB_DIGIT0:-$REFVARVALUE}" ]]; then
   local ISNOTATABLE="$(sed -n '/^local PKGDTB_DIGIT0=$/p' "$SCRIPTFILE")"
   [[ $ISNOTATABLE ]] && sed -i 's/^local PKGDTB_DIGIT0=/local PKGDTB_DIGIT0=()/' "$SCRIPTFILE"
   printf '\v\v\t\t\tWelcome to sspm!\v\v\n'
   else export FIRST_INIT=N
   fi
elif [[ -n "$1" && "$#" -le 2 && "$1" =~ ^-[[:alpha:]]$ ]]; then

         if [[ "$1" = "-g" ]]
           then
            if [[ (( -n "$2" && "$2" = "-f" )) || -z "$2" ]]; then
             if [[ $REFVARBYTES -gt 2 ]]; then            
              [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
              sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE" && sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
              [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
              [[ ! -d "$PKGDIR/database" ]] && mkdir -pv "$PKGDIR/database"
              find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
              chmod 600 $PKGDIR/database/$FNAME
              [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
             else
              [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
              [[ "$REFVARFORM" =~ \" || "$REFVARFORM" =~ \' ]] && sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE"
              sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
              [ $(stat -c "%a" "$SCRIPTFILE") != '755' ] && chmod 755 "$SCRIPTFILE"
              [[ ! -d "$PKGDIR/database" ]] && mkdir -pv "$PKGDIR/database"
              find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
              chmod 600 $PKGDIR/database/$FNAME
              [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
             fi         
            fi      
         elif [[ "$1" = "-c" && "$#" -eq 2 && -n "$processtype" ]]
            then
             [[ "$2" = '-r' ]] || printf 'Reading database\n'
              if [[ "$PKGDTB_DIGIT1" != "$PKGDTB_DIGIT0" ]]; then
               printf 'an \e[91merror\e[0m occurred while synchronizing database\n\n'
               printf "Do you want to :\n\n%4s(a)%4stry to fix and process with ${processtype[@]}?\n"
               printf "%4s(i)%4signore and process with ${processtype[@]}?\n"
               printf "%4s(f)%4ssame as 'i' force ${processtype[@]}?\n"
               printf "%4s(r)%4srestore at last backup?\n"
               printf "%4s(q)%4squit?\n\n\n"
               read -p ":: " REP
               case $REP in
               [aA]) ;;
               [iI]) ;;
               [fF]) ;;
               [rR])
               [[ ! -f "$PKGDIR/database/$FNAME" ]] && printf "\e[91mfatal error: \e[0mcannot access $PKGDIR/database/$FNAME\n" && exit $ERCODE
               sleep 0.24; printf "\e[94mrestoring database ...\e[0m\n"
               if [ -f "$DTBFILE1" ]; then [ ! -w "$DTBFILE1" ] && chattr -i "$DTBFILE1" && rm -f "$DTBFILE1" || rm -f "$DTBFILE1"; fi
               if [ -f "$DTBFILE0" ]; then [ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0 && rm -f $DTBFILE0 || rm -f $DTBFILE0; fi
               tar -xf "$PKGDIR/database/$FNAME" -C "$PKGDIR/database/" && chattr +i "$DTBFILE0" "$DTBFILE1"; sleep 0.30
               printf "\e[94mchecking database:\e[0m\n"
               local MATCH0="$(sed '/./!d' $DTBFILE1| tac | sed -n '2,2 p'|cut -d. -f1|tr -d '{}')"
               local MATCH1="$(grep -v '^$' $DTBFILE1|tail -n2|head -n1|cut -d. -f1|tr -d '{}')"
               local LASTPKG="$([[ "$MATCH0" = "$MATCH1" ]] && printf "$MATCH1")"
               if $DTBFILE0 "$LASTPKG"_pth &>/dev/null; then
               printf "%1sdone\n"
               if [[ $REFVARBYTES -gt 2 ]]; then
               [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
               sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE" && sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
               [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
               [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
               else
               [[ "$REFVARFORM" =~ \" || "$REFVARFORM" =~ \' ]] && sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE"
               [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
               sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
               [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
               [[ -f "$PKGDIR/database/$FNAME" ]] && rm -f $PKGDIR/database/$FNAME
               find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
               [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
               fi
               else
               printf 'an \e[91merror\e[0m occurred while checking database\n\n' && exit $ERCODE
               fi ;; [qQ] | '' | *) exit ;; esac
               fi
              fi
            
else
printf '\e[91msyntax\e[0m error\n'
return $ERCODE
fi; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
}











pkg_infos () {
# print either: all installed packages, package installation history
# or package data
local GROUP0="base" GROUP1="add" GROUP2="opt" GROUP3="other"

if [[ $# -gt 1 ]]; then
 local PKG_NAME="$2"
else
    if [[ -n "$extra_0" ]]; then
  if [[ -d "$extra_0" ]]; then
  if [[ "$extra_0" =~ /$ ]]; then
  local DTBFILE1=""${extra_0%?}"$DTBFILE1"
  else local DTBFILE1=""$extra_0"$DTBFILE1"
  fi; else
  printf "%serror:  cannot access directory '$extra_0'\n"
  exit $ERCODE
  fi
    fi
fi


case $1 in  -l) LIST=y ;;  -p|-pi) PKGI=y ;;  *) exit $ERCODE ;; esac

if [[ $LIST = y ]]; then
   if [[ -f "$DTBFILE1" ]]; then
   printf "\n\t\e[100m\e[1mS\e[0m\e[100mimple \e[1mS\e[0m\e[100mcript \e[1mP\e[0m\e[100mackages \e[1mM\e[0m\e[100manager\e[0m\v\n"
   printf "\e[2mthis list is based on given $BUILDFILE file instructions\e[0m\v\n"
   printf "%3s\e[1mbase packages\e[0m\v\n"
   sed -n -e "/^{.*$GROUP0/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1madditional packages\e[0m\v\n"
   sed -n -e "/^{.*$GROUP1/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1moptional packages\e[0m\v\n"
   sed -n -e "/^{.*$GROUP2/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1mother packages\e[0m\v\n"
   sed -n -e "/^{.*$GROUP3/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/; $s/$/\n/' 
   else  LINE="$(cat "$SCRIPTFILE"|grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0"|cut -d'=' -f2|tr -d '()'|tr -d '"'|tr -d "'")"
   if [ -z "$LINE" ]; then printf "no package installed with $(basename $SCRIPTFILE)\n"; exit $ERCODE; else
   printf "\e[91m==> ERROR:\e[0m cannot read database\n\e[90mmake sure '$(dirname "$DTBFILE1")' exist\e[0m\n"
   exit $ERCODE; fi fi
   exit $OKCODE
fi




if [[ $PKGI = y ]]; then
local ERCODE=119
#######################  parse options 
###############################################################
if [[ -n $1 && -n $2 && $# = "2" ]]; then
if [ ! -d $PKGDIR ]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "no package installed with sspm\n"; exit $ERCODE; fi
sleep 0.10
printf "an \e[91merror \e[0moccurred while reading some files\n\
\e[90mmake sure the directory: '$PKGDIR' exist\e[0m\n"; exit $ERCODE
elif [ ! -d "$PKGDIR/database" ]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "no package installed with sspm\n"; exit $ERCODE; fi
sleep 0.10; printf 'Oops!\n'
printf "an \e[91merror \e[0moccurred while reading some files\n\
\e[90mmake sure the directory: '$PKGDIR/database' exist\e[0m\n"
exit $ERCODE
elif [[ ! (( -f "$DTBFILE0" || -f "$DTBFILE1" )) ]]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "no package installed with sspm\n"; exit $ERCODE; fi
sleep 0.10
printf "\e[91m===> ERROR: \e[0mcannot read database\n\e[2mfailed to sync\e[0m\n"
exit $ERCODE
fi
elif [[ -n $1 && -n $2 && -n $3 && $# = "3" ]]; then
local PKGDIR="$3"$PKGDIR; local DTBFILE0="$3"$DTBFILE0; local DTBFILE1="$3"$DTBFILE1
if [ ! -d $PKGDIR ]; then
sleep 0.10
printf "an \e[91merror \e[0moccurred while reading some files\n\
\e[90mcheck if the directory: '$PKGDIR' exist\e[0m\n"
exit $ERCODE
elif [ ! -d "$PKGDIR/database" ]; then
sleep 0.10; printf 'Oops!\n'
printf "an \e[91merror \e[0moccurred while reading some files\n\
\e[90make sure the directory: '$PKGDIR/database' exist\e[0m\n"
exit $ERCODE
elif [[ ! (( -f "$DTBFILE0" || -f "$DTBFILE1" )) ]]; then
sleep 0.10
printf "\e[91m===> ERROR: \e[0mcannot read database\n\e[2mfailed to sync\e[0m\n"
exit $ERCODE
fi
else
printf "\e[91msyntax\e[0m error\n"
exit $ERCODE
fi  ######## end



if [ "$1" = '-p' ]; then
if "$DTBFILE0" "$2"_pth &>/dev/null; then
"$DTBFILE0" "$2"_pth
else
printf "$(basename $SCRIPTFILE): '$2' package not found\n"; exit $ERCODE 
fi
elif [ "$1" = '-pi' ]; then
  local LINE="$(sed -n -e "/\(^{$2\)/p" $DTBFILE1|rev|sed 's/\((.}\)/( }/'|rev)"
if test -n "$LINE"; then
  local DEPPART="$(cut -d' ' -f2- <<< $LINE)"
  local LINE="$(cut -d' ' -f1 <<< $LINE)"
  local LINE0="$(sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g' <<< "$LINE")"
  local LINE1=($(sed -n -e "/\(^$2_desc\)/p" $DTBFILE1|sed "s/^$2_desc[[:punct:]]/\"/; s/[[:punct:]]url[[:punct:]]/\" \"/; s/[[:punct:]]$/\"/"))
  local pkgname="$(cut -d' ' -f1 <<< $LINE0)"
  local pkgver="$(cut -d' ' -f2 <<< $LINE0)"
  local pkgrev="$(cut -d' ' -f3 <<< $LINE0)"
  local arch="$(cut -d' ' -f4 <<< $LINE0)"
  local builddate="$(date --date="@$(cut -d' ' -f5 <<< $LINE0)" +%d/%m/%y)"
  local buildtime="$(date --date="@$(cut -d' ' -f5 <<< $LINE0)" +%R)"
  local pkgtype="$(cut -d' ' -f6 <<< $LINE0)"
  local pkgsize="$(cut -d' ' -f7 <<< $LINE0)"
  local packager="$(cut -d' ' -f8 <<< $LINE0|tr '<>' ' ')"
  local pkgdesc="$(cut -d'"' -f2 <<< ${LINE1[@]})"
  local pkg_url="$(cut -d'"' -f3- <<< ${LINE1[@]}|tr -d '"[[:space:]]')"
  local depends="$(cut -d')' -f1 <<< "$DEPPART"))"
  local makedepend="$(cut -d')' -f2- <<< "$DEPPART")"
else
printf "$(basename $SCRIPTFILE): '$2' package not found\n"
exit $ERCODE
fi


cat << EOF
======================================================================
                  Generated by sspm (install) $SSPM_VER
======================================================================
$pkgdesc 
url: $pkg_url

$TEXT0                  = $pkgname
$TEXT1               = $pkgver
$TEXT2              = $pkgrev
$TEXT3          = $arch
$TEXT4              = $builddate
$TEXT5              = $buildtime
$TEXT6                  = $pkgtype
$TEXT7             = $depends
$TEXT8    = $makedepend
$TEXT9                  = $pkgsize
$TEXT10              = $packager

EOF
exit $OKCODE

fi

fi

}





                                       sspm_depends () {
                                       if [[ -z $1 ]]; then
                                       bsdtar_ver="$(bsdtar --version | cut -d '-' -f1 | sed 's/ $//g')"
                                       zstd_ver="zstd $(zstd --version | cut -d 'v' -f2 | cut -d ',' -f1)"
                                       tar_ver="tar $(tar --version | tr '\n' ' ' | cut -d ' ' -f4)" 
                                       pkg_config_ver="pkg-config $(pkg-config --version)"
                                       procps_ng_ver="$(ps --version | rev | cut -d ' ' -f1,2 | rev )"
                                       which_ver="which $(which --version | head -1 | tr -d "[:alpha:],[:space:]" | cut -d '(' -f1)"
                                       printf "$bsdtar_ver%2s$pkg_config_ver%2s$procps_ng_ver%2s$tar_ver%2s$which_ver%2s$zstd_ver\n"
                                       exit $OKCODE
                                       fi
                                       }
                  
pkgbuild_example () {
local DEST_DIR=
if [ -n "$extra_1" ]; then
 if [[ "$extra_1" =~ /$ ]]
  then local DEST_DIR="$extra_1"
  else  local DEST_DIR=""$extra_1"/"
 fi
fi

tee $DEST_DIR"$BUILDFILE" 1>/dev/null << EOF
pkgname=
pkgver=
pkgrev=
pkgdesc=""
url=""
groups=""
depends=()
makedepend=()
packager=""
tfext=""


build() {





}

EOF
}



make_build() {
local ERCODE=3
# some dialogs work better with RANDOM var. can be removed 
# if you are sure that RANDOM var will always be available
local RANDOM=${RANDOM:-$(od -A n -t d -N 3 /dev/random)}
# run interactive mode if 'LV_BUILD' is set  
if [[ -v LV_BUILD && -n "$LV_BUILD" ]]; then
local INT_MODE="$(tr '[:upper:]' '[:lower:]' <<< ${LV_BUILD//[[:punct:][:digit:]]})"
while [[ "$INT_MODE" = on || "$INT_MODE" = y || "$INT_MODE" = yes  ]]; do
clear; printf "\e[90mEnter a package name\e[0m\n\npackage name%9s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ -n "$val" && ! "$val" =~ [[:cntrl:]] ]]; then pkgname="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEnter a version\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ -n "$val" && ! "$val" =~ [[:cntrl:]] ]]; then pkgver="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEnter a revision (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\nrevision%13s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then pkgrev="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEnter a short description (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\nrevision%13s: "$pkgrev"\ndescription%10s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then pkgdesc=("$val") && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mEnter an url (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\nrevision%13s: "$pkgrev"\n"
printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "url%18s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then url="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mpackage type  '(base)%3s(add)%3s(opt)%3s( )'  (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\n\
revision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"; printf "group%16s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then groups="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mDependencies, use space or comma as separator (optional)\e[0m\n\n\
package name%9s: "$pkgname"\nversion%14s: "$pkgver"\nrevision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"
printf "%burl%18s: $url\n"; printf "group%16s: $groups\n"; printf "depend on%12s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then depends="$(tr ',;' ' ' <<< "$val")" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mmake dependence to (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\n\
revision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"
printf "group%16s: $groups\n"; printf "depend on%12s: $depends\n"; printf "make dependence to%3s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then makedepend="$(tr ',;' ' ' <<< "$val")" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mpackager (optional)\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\n\
revision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"; printf "group%16s: $groups\n"
printf "depend on%12s: $depends\n"; printf "make dependence to%3s: $makedepend\n"; printf "packager%13s:\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then packager="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mSource file extension  'tar.gz'\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\n\
revision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"; printf "group%16s: $groups\n"
printf "depend on%12s: $depends\n"; printf "make dependence to%3s: $makedepend\n"; printf "packager%13s: $packager\n"; printf "tfext%16s:\n\n" 
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then tfext="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mLeave empty if 'SRC' is already set\e[0m\n\npackage name%9s: "$pkgname"\nversion%14s: "$pkgver"\n\
revision%13s: "$pkgrev"\n"; printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"; printf "group%16s: $groups\n"
printf "depend on%12s: $depends\n"; printf "make dependence to%3s: $makedepend\n"; printf "packager%13s: $packager\n"; printf "tfext%16s: $tfext\nSRC%18s:\n\n" 
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then SRC_DIR="$val" && break; else read -p ':: ' val && continue; fi done

                      clear
                      f_state() {
                            if [[ "$build" =~ [[:cntrl:]] || "$config" =~ [[:cntrl:]] ]]; then
                               case $RANDOM in
                                  3*2* | 2*6* | 4*4 | *9*9*3* | 6*7*1*1 | *0*0 | *1*9* | *5*7* )
                                  printf "%s\e[90mopt for typing rather than pasting to avoid some behaviour\n"
                                  printf "with the 'carriage return' caractere. [q] to quit, [}] to finish\e[0m\n\n" ;;
                                  * )
                                  printf "%s\e[90mpress [q] to quit, [}] to finish\e[0m\n\n" ;;
                               esac
                            else printf "%s\e[90mtype or paste all the configuration and type '}'\e[0m\n\n"
                            fi
                                printf "package name%9s: "$pkgname"\nversion%14s: "$pkgver"\nrevision%13s: "$pkgrev"\n"
                                printf "%sdescription%10s: ${pkgdesc[@]}\n"; printf "%burl%18s: $url\n"; printf "group%16s: $groups\n"
                                printf "depend on%12s: $depends\n"; printf "make dependence to%3s: $makedepend\n"
                                printf "packager%13s: $packager\n"; printf "tfext%16s: $tfext\n"
                                printf "%bSRC%18s: $SRC_DIR\n\n"
                                [[ "$build" ]] && printf "%b$build\n" || printf "build%1s()%1s\n{\n"
                            }


while true; do
clear; f_state; read config
if [[ -n "$config" && ! "$config" =~ [[:cntrl:]] ]]; then
   [[ "$config" == '}' ]] && break
   [[ "$config" == [qQ] ]] && exit
if [[ "$build" ]]; then
  build="$build
  $config
  "
  else
  build="build()
  {
  $config
  "
fi
continue
else
continue
fi
done
unset f_state
# spaces in 'sed' command below try to wipe spaces in build variable above
# NOTE: for any reason if you chose to change the build variable position above
# you need to ajust the sed command spaces below. because commands like 'make'
# should not start with spaces. see the infos page for an example.
build="$(sed 's/^  //g' <<< $build)
}"
if [[ -z "$pkgrev" ]]; then pkgrev=1; fi
if [[ -n "$url" ]]; then [[ $url =~ ^\".*\"$ ]] || url="$(sed 's/^\|$/"/g' <<< $url)"; fi
if [[ -n "$pkgdesc" ]]; then [[ $pkgdesc =~ ^\".*\"$ ]] || pkgdesc="$(sed 's/^\|$/"/g' <<< $pkgdesc)"; fi
if [[ -n "$packager" ]]; then [[ $packager =~ ^\".*\"$ ]] || packager="$(sed 's/^\|$/"/g' <<< $packager)"; fi


                       sleep 0.20 && clear
                       if [[ -n $SRC_DIR && -d $SRC_DIR ]] || [[  -n $SRC && -d $SRC ]]; then
                       [[ -d $SRC ]] || SRC="$SRC_DIR"
                       [[ "$SRC" =~ /$ ]] && SRC="${SRC%?}"
                       printf "%1sAlso generate a checksum ? (y/n)\n"
                       printf "%1s\e[90m[enter] key for 'no'\e[0m\n\n"
                       read -p ':: '  REP && case $REP in [nN]|'') ;; [oO]|[yY]) PKG_HASH=yes ;; *) exit $ERCODE ;; esac
                       OLDBDIR="$BDIR"    OLDBUILDFILE="$BUILDFILE"         BDIR=/tmp    BUILDFILE=""$BUILDFILE"_$RANDOM"
                       printf "%bpkgname=$pkgname\npkgver=$pkgver\npkgrev=$pkgrev\npkgdesc=$pkgdesc\nurl=$url\ngroups=$groups\n" > "$BDIR/$BUILDFILE"
                       printf "%bdepends=($depends)\nmakedepend=($makedepend)\npackager=$packager\ntfext=$tfext\n\n\n" >> "$BDIR/$BUILDFILE"
                       printf "%b$build\n" >> "$BDIR/$BUILDFILE"
                       RMBLDF=y; printf "%s\n" && sleep 0.15 && clear
                       break
                       else
                       printf "\nerror:  source directory not found\n"
                       exit $ERCODE
                       fi

done
fi
# end 

                               #### pkgbuild files detection 
                               shopt -s nullglob; local BUILDFILES=("$BUILDFILE"_*); shopt -u nullglob
                               if [[ ${#BUILDFILES[@]} -ge 1 ]]; then
                               [[ ! -f $BUILDFILE ]] || local BUILDFILES+=($BUILDFILE)
                               if [[ ${#BUILDFILES[@]} = 1 ]]; then local BUILDFILE=$BUILDFILES
                                else
                                                                                if [[ $RANDOM == *3*5* ]]
                                                                                then printf '\n\e[2;49;37menter a\e[0m suffix\n\n\n'
                                                                                elif [[ $RANDOM == 2* ]]
                                                                               then printf '\nenter a \e[1mname\e[0m\n\n\n'
                                                                              elif [[ $RANDOM == *7 ]]
                                                                             then printf '\nenter a name\n\n\n'
                                                                           elif [[ $RANDOM == *2*2* ]]
                                                                         then local read_cmd=y
                                                                        printf '\n\n'; read -p "build ? :: " NAME
                                                                        elif [[ $RANDOM == *1* ]]
                                                                        then printf '\nfiles ('${#BUILDFILES[@]}') enter a name\n\n\n'
                                                                         elif [[ $RANDOM == 8* ]]
                                                                           then printf "\nenter a package name\n\n\n"
                                                                             local read_cmd=y
                                                                              read -p "(${#BUILDFILES[@]}) :: " NAME
                                                                               elif [[ $RANDOM == *6* ]]
                                                                                then printf '\n enter a name\n\n\n'
                                                                                elif [[ $RANDOM == *4* ]]
                                                                                then printf '\n please enter a suffix\n\n\n'
                                                                                else printf '\n * enter a name!\n\n\n';fi
                                      
                                   while true; do
                                     if [[ $read_cmd ]]; then
                                   if [[ -n "$NAME" && "$NAME" != q ]] && \
                                   [[ "$NAME" =~ ^[[:print:]]+$ ]]; then
                                   printf '\n'; break                                
                                   else
                                   [[ -z "$NAME" || "$NAME" = q ]] && printf '\n' && exit 
                                   read_cmd=y; read -p ':: ' NAME ; continue
                                   fi
                                   else
                                   read_cmd=y; read -p ':: ' NAME ; continue
                                     fi
                                   done
                                   
                                   if [[ $NAME == "$BUILDFILE"_* ]]
                                     then
                                       local OLDBUILDFILE=$BUILDFILE
                                       local BUILDFILE=$NAME
                                     else
                                       local OLDBUILDFILE="$BUILDFILE"
                                       local BUILDFILE=""$BUILDFILE"_$NAME"
                                   fi
                                   unset NAME read_cmd
                                 fi
                                fi


#### pkgbuild file checking routine
local BUILDDATE="`date '+%D'`"  BUILDTIME="`date '+%R'`" PKGBID="$([[ "${EUID:-$(id -u)}" -ne 0 ]] && printf '1' || printf '0' )"
local TMPFILE="$TMP/.$BUILDFILE"; ipc_tool -c; set -e; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x; if [[ -n "$extra_1" ]]; then
if [[ ! -d "$extra_1" ]]; then printf "\e[91merror:\e[0m  cannot access directory '$extra_1'\n"; exit $ERCODE; fi
local DEST_DIR=""$(realpath -e $extra_1)"/"; fi; if [ -f "$BDIR/$BUILDFILE" ]; then if [ -s "$BDIR/$BUILDFILE" ]; then 
local REF_VAR=($(grep -E 'pkgname=|pkgver=|pkgrev=|tfext=' "$BDIR/$BUILDFILE" | cut -d'=' -f1 | tr '\n' ' '))
local NO_EMPTY=($(grep -E 'pkgname=|pkgver=' "$BDIR/$BUILDFILE" | cut -d'=' -f2 | tr -d "\"'" | tr '\n' ' '))
if ! [[ "${#REF_VAR[@]}" = 4 && "${REF_VAR[@]}" =~ ^[pkgname_pkgver_pkgrev_tfext_[:space:]_]+$ && "${#NO_EMPTY[@]}" = 2 ]]; then
if [[ "${#NO_EMPTY[@]}" -eq 0 || (( "${#REF_VAR[@]}" = 4 && "${#NO_EMPTY[@]}" -lt 2 )) ]]; then
printf "\e[91merror:  \e[0mplease fill out the ($BUILDFILE) file\n"; exit $ERCODE
elif [[ "${#REF_VAR[@]}" -lt 4 ]]; then local MISSING_REF_VAR=()
for name in pkgname pkgver pkgrev tfext; do [[ "${REF_VAR[@]}" =~ $name ]] || MISSING_REF_VAR+=("$name"); done
printf "\e[91merror:\e[0m  missing '${MISSING_REF_VAR[@]}=' in ($BUILDFILE) file\n"; exit $ERCODE
else printf "\e[91merror: \e[0m can't read the ($BUILDFILE) file\n\
%8smake sure to fill out the file properly\n"; exit $ERCODE; fi
else local NO_EMPTY_FUNC0="$(sed -n '/^\(.*().*{\)\|^\({\)/,/^\(.*}.*\)/p' "$BDIR/$BUILDFILE"\
|sed '/^.*().*{\|^{\|^.*}/s/#.*//'|sed 's/^.*().*{\|^{$\|\(^.*}\)//g'|tr -d '\n[:space:]')"
local NO_EMPTY_FUNC1="$(sed -n '0,/^.*().*{\|^{/!p' "$BDIR/$BUILDFILE" | tac | sed -n '0,/^}\|^.*}/!p'|tac|tr -d '\n[:space:]')"
if ( test $(wc -m <<< "$NO_EMPTY_FUNC0") -eq 1 && test $(wc -m <<< "$NO_EMPTY_FUNC1") -lt 2 ); then
printf "\e[91merror:\e[0m  could not read ($BUILDFILE) file\n%8smake sure to fill out the file properly\n\n\t***** the build function is empty *****\n"
exit $ERCODE; fi fi; else printf "\e[91merror:\e[0m ($BUILDFILE) is blank\ntry 'sspm --pkgbuild-example' to have an example\n"
exit $ERCODE; fi; else case $RANDOM in 2*2* | *0*4 | *3*5 | 6*1* | *0*0 | *9*1* )
printf "\e[91merror:\e[0m  ($BUILDFILE) \e[2munexisting file\e[0m\n" ;;
*) printf "\e[91merror:\e[0m  the ($BUILDFILE) file does not exit\n"  ;; esac; exit $ERCODE; fi
[[ -n "$1" && "$1" == "-wh" ]] && local PKG_HASH=yes
printf "\e[1msspm (build)\e[0m\nA build tool for creating \ncompatible packages to use with sspm\n"
sleep 0.60; cd $TMP; if [ $(pwd -P) != $TMP ]; then
printf "\e[91merror: \e[0mwe cannot create packages in this directory '$(pwd -P)'\n"; exit $ERCODE; fi

# Ensure "SRC" is set
printf '\e[36mInitializing source...\e[0m\n'
sleep 0.20;
                source_dir() 
                {
                printf '\n'; read -p "::" REP
                if [[ -n "$REP" ]]; then
                if [[ -d "$REP" && -n $(ls -A $REP) ]]; then
                [[ "$REP" =~ /$ ]] && REP="${REP%?}"
                CHECK_FILES=($REP/*)
                if [[ ${#CHECK_FILES[@]} > 0 ]]; then
                export SRC=$REP
                sleep 0.40 && printf '\n'
                else
                printf "\nsspm: nothing found in '$REP'\n"
                exit $ERCODE
                fi
                elif [[ -d "$REP" && -z $(ls -A $REP) ]]; then
                printf "\nsspm: '$REP'  is empty\e[0m\n"
                exit $ERCODE
                else
                printf "\nsspm: directory '$REP' not found\n"
                exit $ERCODE
                fi
                else
                printf '\n'
                exit $OKCODE
                fi
                }
                               if ! (set -u; : $SRC) &>/dev/null && ! (set -u; : $PKG_SRC) &>/dev/null; then
                               printf "\e[91m==> ERROR:\e[0m can't find source directory\n"
                               printf "\e[90mplease make sure you set SRC.\e[0m\n\n"
                               read -p "Do you wish to indicate it now ? (y/n) " REP
                               case $REP in [yY] | '') source_dir ;; [nN] | *) exit ;; esac
                               else [[ $SRC ]] && [[ "$SRC" =~ /$ ]] && SRC="${SRC%?}"
                               fi
# checking and detection in buildfile function name  
printf "\e[36mreading build file\e[0m\n"; sleep 0.70
## checking if the package has a: simple, pseudo complex or none configuration.
## in order to configure accordingly (ex: if the buildfile has "ln" command as configuration: 
## then this one will be moved to the install script ...and so on)

local B_FUNCTION_CMD="$(sed -ne '/\(^make.*install\)/,/\(^}.*\)/p' $BDIR/$BUILDFILE | sed '/cat.*EOF\|cat.*eof/,/EOF\|eof/d ; /^#/d ; /\(^make.*install\)\|^#$\|^[[:space:]]\}$\|\(^}.*\)\|^$/d' | tr -d "\"[:space:]'" |cut -d ' ' -f 1)"


                      if [[ -z $B_FUNCTION_CMD ]] || [[ ! $B_FUNCTION_CMD =~ "ln" && (( $B_FUNCTION_CMD =~ ^[install_]+$ || $B_FUNCTION_CMD =~ ^[mv_]+$ || \
                      $B_FUNCTION_CMD =~ ^[mv_rm_]+$ || $B_FUNCTION_CMD =~ ^[mv_cp_]+$ || $B_FUNCTION_CMD =~ ^[rm_]+$ || $B_FUNCTION_CMD =~ ^[cp_]+$ || \
                      $B_FUNCTION_CMD =~ ^[mv_install_]+$ || $B_FUNCTION_CMD =~ ^[cp_install_]+$ || $B_FUNCTION_CMD =~ ^[unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_rm_]+$ || $B_FUNCTION_CMD =~ ^[install_rm_]+$ || $B_FUNCTION_CMD =~ ^[install_unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_unset_]+$ || $B_FUNCTION_CMD =~ ^[mv_unset_]+$ || $B_FUNCTION_CMD =~ ^[rm_unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[touch_]+$ || $B_FUNCTION_CMD =~ ^[install_touch_]+$ || $B_FUNCTION_CMD =~ ^[mv_touch_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_touch_]+$ || $B_FUNCTION_CMD =~ ^[rm_touch_]+$ || $B_FUNCTION_CMD =~ ^[install_tar_]+$ )) ]]
                      then    local CONFIG_TYPE=; cp "$BDIR/$BUILDFILE" $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" && $B_FUNCTION_CMD =~ "localedef" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "localedef" || $B_FUNCTION_CMD =~ "localedef" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" && $B_FUNCTION_CMD =~ "rpc" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" ]]
                      then if grep -qiF '=glibc' $BDIR/$BUILDFILE; then
                              if grep -qiF 'tzselect' $BDIR/$BUILDFILE; then
                              printf "\e[91merror:\e[0m '$BUILDFILE' file should not contain the '\e[1mtzselect\e[0m' command\n"
                              exit $ERCODE
                              elif [[ $B_FUNCTION_CMD == *ln*localtime* ]]
                              then local CONFIG_TYPE="C"
                              sed "/\(^ln.*localtime\)\|\(.*ln.*localtime.*\)/s/^/##/"  < $BDIR/$BUILDFILE > $TMPFILE
                              else local CONFIG_TYPE=; cp $BDIR/$BUILDFILE  $TMPFILE
                              fi
                            fi
                      elif [[ $B_FUNCTION_CMD =~ ^"for".* ]]; then local CONFIG_TYPE="C"
                        sed "/\(^for.*\)\|\(.*for.*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                        ( grep -E ^'##install|##make*-ln*|##cp*|##mkdir*' $TMPFILE 1>/dev/null ) && \
                        sed -i '/^##install \|^##make.*-ln.*\|^##mkdir\|^##cp/s/^##//g' $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ "ln" ]]; then  local CONFIG_TYPE="C"
                        sed "/\(^ln.*\)\|\(.*ln.*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                        ( grep -E ^'##install|##make*-ln*|##cp*|##sed*ln*|##sed*Makefile|##make*|##mkdir*' $TMPFILE 1>/dev/null ) && \
                        sed -i '/^##install \|^##make.*-ln.*\|^##make\|^##sed.*ln.*\|^##sed.*Makefile\|^##mkdir\|^##cp/s/^##//g' $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ ^[chmod_]+$ ]]; then  local CONFIG_TYPE="C"
                        sed "/\(^chmod.*\)\|\(.*chmod.*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                      else  local CONFIG_TYPE= ; cp "$BDIR/$BUILDFILE" $TMPFILE                   
                      fi


if [[ "$INT_MODE" != on && "$INT_MODE" != y && "$INT_MODE" != yes ]]; then
local check1_fonction_name=$(cat $TMPFILE | grep "()" | sed 's/=()//g' | sed '/'depends'\|'makedepend'\|'pkgname'\|'pkgver'\|'pkgrev'\|'pkgdesc'\|'url'\|'"groups"'\|'tfext'/d' | sed 's/()//g' | sed 's/{//g')
local check2_fonction_name="$(sed -n '/\(^.*().*\)/h; ${x;p;}' $TMPFILE | tr -d '(){}')"
shopt -s extglob
local check1_fonction_name="${check1_fonction_name##*( )}"
local check1_fonction_name="${check1_fonction_name%%*( )}"
local check2_fonction_name="${check2_fonction_name##*( )}"
local check2_fonction_name="${check2_fonction_name%%*( )}"
shopt -u extglob
local auto_genereted_vars_found="$(sed -n '/^pkgbid=\|^builddate=\|^buildtime=/p' $TMPFILE|wc -w)"
[[ $auto_genereted_vars_found -gt 0 ]] && sed -i '/^pkgbid=\|^builddate=\|^buildtime=/d' $TMPFILE
. $TMPFILE
if [[ -n "$check1_fonction_name" && -n "$check2_fonction_name" ]] && (( "$check1_fonction_name" == "$check2_fonction_name" )); then
run_build_safe()
{
if type  $check1_fonction_name 1>/dev/null; then  
  start_day="$(date +"%F")"
  start_time="$(date +"%s")"
  [[  -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && $check1_fonction_name || $check1_fonction_name 1>/dev/null 2>&1
else
  printf "\e[91m==> ERROR:  \e[0mcannot read build function in '$BUILDFILE'\n"
  printf "%6s\e[90mmake sure its exist and its syntax is correct.\e[0m\n"; exit $ERCODE
fi
}
fi
else
. $TMPFILE
run_build_safe()
{
if type -t build 1>/dev/null; then
  start_day="$(date +"%F")"
  start_time="$(date +"%s")"
  [[  -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && build || build 1>/dev/null 2>&1
else
  printf "\e[91m==> ERROR:  \e[0mcannot read build function in '$BUILDFILE'\n"
  printf "%6s\e[90mmake sure its exist and its syntax is correct.\e[0m\n"
  printf "%17s\e[90mtype 'sspm info' to see an example\e[0m\n"; exit $ERCODE
fi
}
fi



## checking package type specified in 'groups'
# if var empty we check with 'PKG_GROUP', if empty too then the package will be type 'other' 
if [[ -n "$groups" && (( "$groups" != base && "$groups" != add && "$groups" != opt )) ]]; then
printf "\e[93mwarning:\e[0m unrecognized specified group, make sure to use one of these values:\n\
\e[2m%6sbase%17sadd%20sopt%14sother/empty\e[0m\n\e[90m(base packages)%3s(additional packages)%3s(optional packages)%3s(other packages)\e[0m\n"
sleep 0.82
fi

if [[ -z "$groups" ]]; then
 if [[ -n "$PKG_GROUP" ]]; then 
    if [[ "$PKG_GROUP" = base || "$PKG_GROUP" = add || "$PKG_GROUP" = opt || "$PKG_GROUP" = other ]]; then
    local groups="$PKG_GROUP" set_env_group="yes"; else local groups="other"  set_env_group="yes"; fi
 fi
fi
if [[ -z $packager ]]; then [[ -z "$PACKAGER" ]] || local packager="$PACKAGER"  set_env_pack="yes"; fi
if [[ -z "$pkgrev" ]]; then local pkgrev="1"  set_rev_val="yes"; fi


## checking if we have absolute path to "source file" 
## if the source file name is different from the package name
## (ex: user0:$ export PKG_SRC=/path/to/foo.tar.xz) then rerun your command
#########################################
local sufix="$SUFIX"
if [ -z $PKG_SRC ]; then
local PKG_SRC="$SRC/${pkgname}-${pkgver}.$tfext"
[[ -f "$PKG_SRC" ]] && local REFIND=NO || local REFIND=YES
fi
if [[ -z "$REFIND" || (( -n "$REFIND" && "$REFIND" = 'YES' )) ]]; then
local PKG_SRC_MATCH=(${PKG_SRC%%.*}*)

if [[ ${#PKG_SRC_MATCH[@]} -gt 0 ]]; then
if [[ "${PKG_SRC_MATCH[@]}" =~ "docs" || "${PKG_SRC_MATCH[@]}" =~ "html" \
|| "${PKG_SRC_MATCH[@]}" =~ "fixe" || "${PKG_SRC_MATCH[@]}" =~ "patch" \
|| "${PKG_SRC_MATCH[@]}" =~ "fhs" ]]
    then local PKG_SRC_MATCH1=()
    for psm in ${PKG_SRC_MATCH[@]}; do
    [[ "$psm" = *"docs"* || "$psm" = *"html"* || "$psm" = *"fixe"* || "$psm" = *"patch"* || "$psm" = *"fhs"* ]] || \
    local PKG_SRC_MATCH1+=("$psm")
    done
    local PKG_SRC_MATCH=(${PKG_SRC_MATCH1[@]})
    unset PKG_SRC_MATCH1
fi
fi

if [[ ${#PKG_SRC_MATCH[@]} -gt 1 ]]; then
local PKG_SRC_MATCH="$(tr '[:space:]' '\n' <<< "${PKG_SRC_MATCH[@]}" | sort -Vr | head -n1)"
fi
if [[ -f $PKG_SRC_MATCH ]]; then
local PKG_SRC="$PKG_SRC_MATCH"
unset PKG_SRC_MATCH
else
local PKG_SRC_MATCH="$(basename "$PKG_SRC")"
local HEAD="${PKG_SRC_MATCH:0:3}"
local HEAD="${HEAD,,}"
local PKG_SRC_FOUND="$(find $SRC -iname "$HEAD*.*" -type f)"
if [ -z "$PKG_SRC_FOUND" ]; then
printf "\e[91m===> ERROR:\e[0m '$(basename "$PKG_SRC")' not found in << $SRC >>\e[0m\n"
exit $ERCODE
fi
for FILE in $PKG_SRC_FOUND; do
FNAME="$(basename "${FILE,,}")"
if [[ "$FNAME" =~ "$HEAD" && "$FNAME" =~ "$pkgver" && (( "$FNAME" != *"docs"* && "$FNAME" != *"html"* && "$FNAME" != *"fixe"* && "$FNAME" != *"patch"* && "$FNAME" != *"fhs"* )) ]]
then local PKG_SRC="$FILE"; fi
done
fi
fi

                                        if grep -q '[Zz]ip archive' <<< $( file $PKG_SRC ); then
                                           if type -t 7z &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=7z
                                           elif type -t unzip &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=unzip
                                           elif type -t bsdtar &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=bsdtar
                                           else
                                              printf "\nerror:  you need to install package like 'libarchive, p7zip or unzip'\n"
                                              printf "%8sto manipulate zip file with sspm\n\n"
                                              exit $ERCODE
                                           fi
                                        fi

# 4 tests to detect a base directory of a source file may appear excessive, but we really need to be sure
# to avoid performance issues the command below stops at the first returned result
# because reading an entire archive of 200MB for example, is not a good idea for performance.
#######################################################
if [[ -n $C_TYPE_FILE && $C_TYPE_FILE = zip ]]; then
   if [[ $EXTOOL = unzip ]]; then
   local CD_DIR0="$(unzip -l "$PKG_SRC" 2>/dev/null | tac | head -n 4 | tail -n 1 | rev | cut -d' ' -f1 | rev)"
   local CD_DIR1="$(unzip -l "$PKG_SRC" 2>/dev/null | tail -n 4 | head -n 1 | rev | cut -d' ' -f1 | rev)"
   [[ ${CD_DIR0%%/*} == ${CD_DIR1%%/*} ]] && local CD_DIR=${CD_DIR0%%/*}
   elif [[ $EXTOOL = 7z ]]; then
   local CD_DIR0="$(7z l "$PKG_SRC" 2>/dev/null | tac | head -n 4 | tail -n 1 | rev | cut -d' ' -f1 | rev)"
   local CD_DIR1="$(7z l "$PKG_SRC" 2>/dev/null | tail -n 4 | head -n 1 | rev | cut -d' ' -f1 | rev)"
   [[ ${CD_DIR0%%/*} == ${CD_DIR1%%/*} ]] && local CD_DIR=${CD_DIR0%%/*}
   elif [[ $EXTOOL = bsdtar ]]; then
   local CD_DIR="$($TAR -tf "$PKG_SRC" 2>/dev/null | head -1)"
   fi
else
local CD_DIR="$(tar -tf "$PKG_SRC" 2>/dev/null | head -1)"
fi

[[ "$CD_DIR" =~ /$ ]] && local CD_DIR="${CD_DIR%?}" || [[ ! "$CD_DIR" =~ \/ ]] || local CD_DIR="$(dirname "$CD_DIR")" 
[[ "$CD_DIR" = "$(basename "$CD_DIR")" ]] || local CD_DIR="${CD_DIR%%/*}"
[[ -z "$CD_DIR" && -f $PKG_SRC ]] && printf "\e[93mwarning:\e[0m  cannot detect source file extract directory\n"  && sleep 0.56
if [[ "$CD_DIR" = \. ]]; then unset CD_DIR
[[ -f $PKG_SRC ]] && printf "\e[93mwarning:\e[0m  cannot detect source file extract directory\n" && sleep 0.56
fi
local TGT_PKG_NAME=$pkgname.$TAG.$PKGEXT
local extract_dir="$(mktemp -u extractdir_XXXXXXXXXX)"
pkgdir="$TMP/"$pkgname"_build$sufix"
pkgdir_rm=""$pkgname"_build$sufix"
spkgdir=""$pkgname"_source$sufix"
[ -d "$TMP/$spkgdir" ] && rm -rf "$TMP/$spkgdir"
[ -d "$TMP/$pkgdir_rm" ] && rm -rf "$TMP/$pkgdir_rm"
[ -d "$TMP/$extract_dir" ] && rm -rf "$TMP/$extract_dir"
[[ -n "$CD_DIR" && -d "$TMP/$CD_DIR" ]] && rm -rf "$TMP/$CD_DIR"


mkdir -p $pkgdir
# checking in build file if package requires a certain hierarchy in its install environment
############################################################################################
# for commands like 'mkdir , install , and so on...' you may have forgotten to indicate '$pkgdir' as root
# the commands below prevent or at least try to prevent the creation of these directories
# to avoid errors like 'No such file or directory'
##############################################################################

                                        if test -n "$(sed -n '/install/{/make\|sed/!p;}; /cp\|mv\|touch/p' < $TMPFILE | \
                                        cut -d ' ' -f1 | tr -d '[:space:]')"; then
                                        if ! cat $TMPFILE | grep ^'mkdir' &>/dev/null; then
                               sleep 0.30
                               printf "\e[96mcreating all needed directories in install environment\e[0m\n"
                               sleep 0.60
                                        while IFS= read -r line; do
                                        if [[ "$line" =~ ^"cp" || "$line" =~ ^"ln" || "$line" =~ ^"mv" \
                                        || "$line" =~ ^"install".*$ || "$line" =~ ^"touch" ]]; then
                                        line="$(rev <<< "$line" | cut -d ' ' -f1 | rev | sed 's/\($pkgdir\)//g'|tr -d "\"'")"
                                        subdir="$(basename "$line"|tr -d "\"'")"
					if [[ ${sysdirs[@]} =~ "$subdir" ]]; then
                                        [[ -d "$pkgdir"$line"" ]] || mkdir -p "$pkgdir"$line""
                                        else
					pdir="$(dirname "$line" 2>/dev/null|tr -d "\"'")"
					[[ "$pdir" =~ '$' || "$pdir" == '.' || -d ""$pkgdir"$pdir" ]] || mkdir -p ""$pkgdir"$pdir"
                                        fi
                                        elif [[ "$line" =~ ^"cat" && (( "$line" =~ '>' || "$line" =~ '>>' )) && "$line" =~ '<<' ]]; then
                                        output_file="$(sed 's/\(.*>\)\|\(<.*\)\|$pkgdir//g' <<< "$line" | tr -d '[:space:]')"
                                        output_dir=""$pkgdir"$(dirname $output_file|tr -d "\"'")"
                                        [[ -d "$output_dir" ]] || mkdir -p $output_dir
                                        fi
                                        done < $TMPFILE
                                        else  sleep 0.30; printf "\e[96mchecking build environment\e[0m\n"; sleep 0.60
                                        while IFS= read -r line; do
                                        if [[ "$line" =~ ^"cp" || "$line" =~ ^"mv" || "$line" =~ ^"install".*$ || "$line" =~ ^"touch" ]]; then
                                        line="$(rev <<< "$line" | cut -d ' ' -f1 | rev | sed 's/\($pkgdir\)//g'|tr -d "\"'")"
                                        subdir="$(basename "$line"|tr -d "\"'")"
				        if [[ ${sysdirs[@]} =~ "$subdir" ]]; then
                                        [[ -d "$pkgdir"$line"" ]] || mkdir -p "$pkgdir"$line""
                                        else pdir="$(dirname $line|tr -d "\"'")" ; [[ "$pdir" =~ '$' || "$pdir" == '.' || -d ""$pkgdir"$pdir" ]] || mkdir -p ""$pkgdir"$pdir"
                                        fi ; elif [[ "$line" =~ ^"cat" && (( "$line" =~ '>' || "$line" =~ '>>' )) && "$line" =~ '<<' ]]; then
                                        output_file="$(sed 's/\(.*>\)\|\(<.*\)\|$pkgdir//g' <<< "$line" | tr -d '[:space:]')"
                                        output_dir=""$pkgdir"$(dirname $output_file|tr -d "\"'")"
                                        [[ -d "$output_dir" ]] || mkdir -p $output_dir
                                        fi  done < $TMPFILE;  fi  fi   
                                                           

case "${pkgname,,}" in 'glibc') set +e ;; esac
cd $TMP && if [[ -f $PKG_SRC ]]; then
[ ! -d "$extract_dir" ] || rm -rf $extract_dir
local options="$([[ -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && printf 'xvf'||printf 'xf')"
mkdir $extract_dir &&
if [[ $C_TYPE_FILE ]]; then
 if [[ $C_TYPE_FILE = "zip" ]]; then
   case $EXTOOL in
        'unzip' ) unzip $PKG_SRC -d $extract_dir ;;               
             7z )  7z x -bd -y $PKG_SRC -o$extract_dir ;;
         bsdtar ) $TAR $options $PKG_SRC -C $extract_dir ;;
   esac
 fi
 else
 tar $options $PKG_SRC -C $extract_dir
fi
if (shopt -s nullglob dotglob; count=($extract_dir/*); test ${#count[@]} -eq 1 && test -d "$extract_dir/$CD_DIR"); then
rename "$extract_dir/$CD_DIR" $spkgdir "$extract_dir/$CD_DIR" && rm -rf $extract_dir
cd $spkgdir && run_build_safe
else
mv $extract_dir $spkgdir && cd $spkgdir && run_build_safe
fi
else
  printf "\e[91m==> ERROR:\e[0m  Unable to find $PKG_SRC\n%12s\e[90mplease ensure that the file exist\n\
  %10sand its extension is the one given in '$BUILDFILE'\n\
  %10sthe absolute path to file can be set with 'PKG_SRC'\n%12s(ex: export PKG_SRC=/dir/dir/file.bzip2)\e[0m\n"
  [ -f "$TMPFILE"  ] && rm -f $TMPFILE
  [ -d "$extract_dir" ] && rm -rf "$extract_dir"
  [ -d "$TMP/$spkgdir" ] && rm -rf "$TMP/$spkgdir"
  [ -d "$TMP/$pkgdir_rm" ] && rm -rf "$TMP/$pkgdir_rm"
  [[ -n "$CD_DIR" && -d "$TMP/$CD_DIR" ]] && rm -rf "$TMP/$CD_DIR"
  exit $ERCODE
fi
local error_code="$?"
[ $error_code -ne 0 ] && exit $error_code
printf "copying build file\n"
[[ "$OLDBUILDFILE" ]] && local PKGFILE="$OLDBUILDFILE" || local PKGFILE="$BUILDFILE"
sed "3a pkgbid=$PKGBID\nbuilddate='"$BUILDDATE"'\nbuildtime='"$BUILDTIME"'"  < $TMPFILE | sed 's/^##//g' > $pkgdir/$PKGFILE
[[ -n $set_rev_val && $set_rev_val = yes ]] && sed -i '/^pkgrev/s/=.*/="'$pkgrev'"/' $pkgdir/$PKGFILE
[[ -n $set_env_group && $set_env_group = yes ]] && sed -i '/^groups/s/=.*/="'$groups'"/' $pkgdir/$PKGFILE
[[ -n $set_env_pack && $set_env_pack = yes ]] && sed -i "/^packager/s/=.*/=\"$packager\"/" $pkgdir/$PKGFILE
printf "creating install script\n"
cat > $pkgdir/$PKG_INSTALL <<EOF
# $pkgname-$pkgver config file

EOF
if [[ -n "$CONFIG_TYPE" && "$CONFIG_TYPE" == "C" ]]; then
cat $TMPFILE | sed -n '/\(^##.*\)/p' | sed 's/^##\|$pkgdir//g' >> $pkgdir/$PKG_INSTALL;
fi
rm -f $TMPFILE
if [ "$RMBLDF" = y ]; then rm -f "$BDIR/$BUILDFILE"; local BDIR="$OLDBDIR"; fi
chmod a+x $pkgdir/$PKG_INSTALL;
# checking if we have broken symbolic links
# to recreate them later at install process         
              while IFS= read -r line; do
              test -z "$line" && continue
                if [[ -n $(find $pkgdir -name "$(basename $(readlink $line))") ]]
                 then
                   target="$(find $pkgdir -name "$(basename $(readlink $line))" | sed 's|'$pkgdir'||g')"
                   name="$(printf "$line" | sed 's|'$pkgdir'||g')"
                   if ! grep "$(basename $line)" $pkgdir/$PKG_INSTALL 1>/dev/null; then
                   printf "ln -sfv $target $name\n" >> $pkgdir/$PKG_INSTALL
                   fi
                 else continue; fi
              done <<< $(find $pkgdir -xtype l -print)
# Creating package
sleep 0.30; printf "\n\e[100mCreating package\e[0m\n"; sleep 0.60
if [ -z "$DEST_DIR" ]; then
[ -f $BDIR/$TGT_PKG_NAME ] && rm -f $BDIR/$TGT_PKG_NAME
cd $pkgdir && make_sum_check -g "." -o $FILES_SHA && $TAR -cpf $BDIR/$TGT_PKG_NAME --zstd $COMPRESS_AS .
if [[ -n $PKG_HASH && $PKG_HASH = "yes" ]]; then 
if [ -f $BDIR/$TGT_PKG_NAME ] && ( file $BDIR/$TGT_PKG_NAME 2>/dev/null | grep 'Zstandard compressed' 1>/dev/null ); then
cd $BDIR && make_sum_check -g "$TGT_PKG_NAME" -o "$PKG_SHA"; fi; fi
else
[ -f "$DEST_DIR"$TGT_PKG_NAME ] && rm -f "$DEST_DIR"$TGT_PKG_NAME
cd $pkgdir && make_sum_check -g "." -o $FILES_SHA && $TAR -cpf ""$DEST_DIR"$TGT_PKG_NAME" --zstd $COMPRESS_AS .
if [[ -n $PKG_HASH && $PKG_HASH = "yes" ]]; then 
if [ -f "$DEST_DIR"$TGT_PKG_NAME ] && ( file "$DEST_DIR"$TGT_PKG_NAME 2>/dev/null | grep 'Zstandard compressed' 1>/dev/null ); then
cd $DEST_DIR && make_sum_check -g "$TGT_PKG_NAME" -o "$PKG_SHA"; fi; fi
fi;    rm -rf $TMP/$pkgdir_rm; rm -rf $TMP/$spkgdir; [ -f $TMPFILE ] && rm -f $TMPFILE; sleep 0.27


if [[ -z "$DIALOG" || (( "$DIALOG" != "off" && "$DIALOG" == "on" )) ]]; then
if [[ (( -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "s" )) && (( -z "$PERM_STDOUT_MODE" || "$PERM_STDOUT_MODE" != "y" )) ]]; then
if [[ "$(date +"%F")" == "$start_day" ]]; then   local end_time="$(date +"%s")"
local timer="$(date -u -d "0 $end_time sec - $start_time sec" +"%Hh:%Mm:%Ss"|tr ':' ' ')"
                            for time_segment in $timer; do
                              if [[ ! "$time_segment" =~ ^00 ]]
                              then
                              if [[ "${time_segment:0:1}" = 0 ]]
                              then  build_time+=("${time_segment:1}")
                              else  build_time+=("$time_segment")
                              fi
                              fi
                            done
fi

# we need to lock a RANDOM var value for all tests instead of
# having a different RANDOM var value for each test. unstable
# redundant dialogs are done on purpose
local RANDOM="$RANDOM"

while true; do
[[ "$RANDOM" =~ ^"9" && "$RANDOM" =~ "2" ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m successfully built\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "8" && "$RANDOM" =~ "1"$ ]] && printf "\v\v\v\e[2m$TGT_PKG_NAME\e[0m\e[90m has been created successfully\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"9" && "$RANDOM" =~ "0" ]] && printf "\v\v\v\e[94m$TGT_PKG_NAME\e[0m created\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ ^"9" ]] && printf "\v\v\v\e[2m$TGT_PKG_NAME\e[0m\e[90m successfully build\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"2" && "$RANDOM" =~ "2" && "$RANDOM" =~ "3" ]] && printf "\v\v\veverything is ok,%2s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "3"$ && ! "$RANDOM" =~ "7" ]] && printf "\v\v\v$TGT_PKG_NAME: ok\v\n***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "5"$ && ! "$RANDOM" =~ "0" ]] && printf "\v\v\v$TGT_PKG_NAME has been created successfully\v\n%15s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ ^"2" && "$RANDOM" =~ "2" ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m successfully created\v\n" && break
[[ "$RANDOM" =~ ^"8" || "$RANDOM" =~ ^"6" ]] && [[ "$RANDOM" =~ "8"$ || "$RANDOM" =~ "5"$ ]] &&  printf "\v\v\vdone\v\n" && break
[[ "$RANDOM" =~ "1"$ && "$RANDOM" =~ "6" ]] && printf "\v\v\v<<<%1sdone, $TEXT12%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "42"$ ]] && printf "\v\v\v<<<%1sdone, build time%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "7"$ ]] && printf "\v\v\vdone\v\n" && break
[[ "$RANDOM" =~ ^"3" ]] && [[ "$RANDOM" =~ "0" && "$RANDOM" =~ "2" ]] && printf "\v\v\v\e[90meverything is \e[0m\e[2mok\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"3" ]] && printf "\v\v\v\e[94m$pkgname\e[0m successfully created\v\n%3s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ ^"4" && "$RANDOM" =~ "4" ]] && printf "\v\v\v\e[94mdone\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"1" && "$RANDOM" =~ "2"$ ]] && printf "\v\v\v\e[90mcreated: \e[0m\e[2m$TGT_PKG_NAME\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"7" && "$RANDOM" =~ "4" ]] && printf "\v\v\vsuccessfully built package\v\n%1s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "5" && "$RANDOM" =~ "8" ]] && printf "\v\v\v\e[90mcreated package: \e[0m\e[2m$TGT_PKG_NAME\e[0m\n\e[90min%13s:%1s\e[0m\e[2m$(cat <<< "${build_time[@]}")\e[0m\v\n" && break
[[ "$RANDOM" =~ "06"$ ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m has been successfully created\v\n%11s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "0" && "$RANDOM" =~ "5" ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m created\v\n%8s<<<%1s$TEXT12%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "9" && ! "$RANDOM" =~ "2" ]] && printf "\v\v\vdone\v\n" && break
[[ "$RANDOM" =~ ^"6" ]] && printf "\v\v\v\e[94m$TGT_PKG_NAME\e[0m ok\v\n" && break
[[ "$RANDOM" =~ ^"1" && "$RANDOM" =~ "1" ]] && printf "\v\v\v\e[94m$TGT_PKG_NAME\e[0m successfully created\v\n" && break
[[ "$RANDOM" =~ ^"5" ]] && printf "\v\v\veverything is ok,%2s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "0"$ ]] && printf "\v\v\v\e[36m$TGT_PKG_NAME\e[0m created successfully\v\n" && break
[[ "$RANDOM" =~ "2"$ ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m created successfully\v\n" && break
[[ "$RANDOM" =~ "4"$ ]] && printf "\v\v\veverything is ok\v\n%1s<<<%1sbuild duration,%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "8"$ ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m has been created successfully\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "1"$ ]] && printf "\v\v\vdone\v\n" && break
[[ "$RANDOM" =~ "6"$ ]] && printf "\v\v\v\e[92m$TGT_PKG_NAME\e[0m created\v\n" && break
[[ "$RANDOM" =~ ^"7" && "$RANDOM" =~ "7" ]] && printf "\v\v\v\e[95m$TGT_PKG_NAME\e[0m successfully created\v\n" && break
[[ "$RANDOM" =~ "5"$ && "$RANDOM" =~ [7-9] ]] && printf "\v\v\vdone\v\n" && break
printf "\v\v\v\e[90mcreated package: \e[0m\e[2m$TGT_PKG_NAME\e[0m\n\e[90min%9s:%1s\e[0m\e[2m$(cat <<< "${build_time[@]}")\e[0m\v\n" && break
done; if (export -p | grep -q PKG_SRC); then [[ "$RANDOM" =~ "1"$ || "$RANDOM" =~ ^"2" || "$RANDOM" =~ "8" ]] && printf "\e[90mDo not forget to unset 'PKG_SRC'\e[0m\v\n"; fi
fi
fi
if [[ "$INT_MODE" != on && "$INT_MODE" != y && "$INT_MODE" != yes ]]; then
if [[ -n $NOEXIT && $NOEXIT = y ]]; then
   if [ -z "$DEST_DIR" ]
    then
     export PKG_FILE="$BDIR/$TGT_PKG_NAME"
    else
     export PKG_FILE=""$DEST_DIR"$TGT_PKG_NAME"
   fi
else
 [[ -n "$PERM_STDOUT_MODE" && "$PERM_STDOUT_MODE" = "y" ]] || exit $OKCODE
fi
else
printf "%1s\e[2m[Enter] key for 'yes'\e[0m\n\n"
      case $RANDOM in
          5*3* | 2*6* | *8*0*0* | 6*7*1*1 | *7*3*4 | 1*0*1* | *0*0 | *1*9* | *5*7* )
              read -p " Proceed with installation ? (y/n) : " REP ;;        
          *)  read -p " Do you wish to install package ? (y/n) : " REP ;;
      esac
case $REP in [nN]) exit $OKCODE ;; [oO]|[yY]|oui|yes|'') ;; *) exit $ERCODE ;; esac; printf "%s\n"
[[ "$OLDBUILDFILE" ]] && BUILDFILE="$OLDBUILDFILE"
PKG_FILE="$BDIR/$TGT_PKG_NAME"   BIMODE=y
make_install $PKG_FILE && exit $OKCODE
fi
}





make_install () {
# some dialogs work better with RANDOM var. can be removed 
# if you are sure that RANDOM var will always be available
local RANDOM=${RANDOM:-$(shuf -i 1-100000 -n 1)}
#################################################################
local ERCODE=8; if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
if [[ $BIMODE ]]; then printf "cannot proceed with installation. permission denied\n"; exit $ERCODE
else printf "%1syou need to be root to run this command\n"; exit $ERCODE; fi fi
local TMPFILE=$(mktemp $TMP/tif.XXXXXX); [[ -n "$BIMODE" && "$BIMODE" == y ]] && set +e
[[ -z "$2" ]] && check_dtb; if [[ -n "$1" ]]; then if [[ -e "$1" ]]; then
  if ! ( test -f "$1" && file "$1" 2>/dev/null | grep -q 'Zstandard compressed data' && tar tf "$1" | grep -q "$BUILDFILE" )
  then  printf "\e[91merror:\e[0m  Could not initialize package\n\e[90m '$1' doesn't look like a package.\e[0m\n"
  ( test -n "$(ls "$TMP" | sed -n '/\(tif.*\)/p')" ) && find "$TMP" -depth -name 'tif*' -type f -delete
  exit $ERCODE; fi else printf "\e[91merror:\e[0m unable to find '$1'\n"; exit $ERCODE; fi
  else printf "\e[91merror:\e[0m  no package specified\n"; exit $ERCODE; fi
ipc_tool -L
local EMULATED_TERM="$([[ "$(tty)" = '/dev/pts/'* ]] && printf '1')"
### the default behavior if you install a package with single process '--install' is to scrollback console buffer
### [on non-login shell]. remove the command below if you do not want this behavior
if ! [[ $INT_MODE || $BIMODE || $NOEXIT || ! $FIRST_INIT ]]; then [[ $EMULATED_TERM ]] && printf '\e[2J\e[H'; fi
printf "\e[1msspm (install)\e[0m\nCompatibles packages install tool\e[0m\n"
[[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
################ checking needed directories
## we make sure of existence of needed directories in this "root" or "new root" if indicated
#### for example : if we are in chroot
#### ( "root"      ----------> is the chroot environment )
#### ( "new root"  ----------> is the mount point of somedisk in chroot environment)
############################################################################################################
                 if [[ -z "$2" ]]; then
                     if [ ! -d "$PKGDIR/database" ]; then
                     mkdir -p "$PKGDIR/database"
                     if [ $? -ne 0 ]; then
                     printf "\e[91m==> ERROR:\e[0m  unable to create the directory '$PKGDIR/database'\n"
                     exit $ERCODE
                     fi
                     fi
                  else
                  if [ ! -d "$2" ]; then
                  printf "\ndirectory '$2' does not exist\n\n"
                  read -p "do you want to create the directory? (y/n) " REP
                  case $REP in  [yY]|'') ;; [nN]|*) find $TMP -iname tif.* -delete; exit ;; esac;  fi
                     [[ "$2" =~ /$ ]] && local PKGDIR=""${2%?}"$PKGDIR" || local PKGDIR=""$2"$PKGDIR"
                     local DTBFILE0="$PKGDIR/database/$LOGFILE"; local DTBFILE1="$PKGDIR/database/$PKG_DTB"
                     if [ ! -d "$PKGDIR/database" ]; then
                     mkdir -p "$PKGDIR/database" &>/dev/null
                     if [ $? -ne 0 ]; then
                     printf "error: cannot create directory '$PKGDIR/database'\n"
                     exit $ERCODE
                     fi
                     fi
                  fi


################ Install dialog
local PKG_NAME=$(tar xf $1 "./$BUILDFILE" -O 2>/dev/null | grep "pkgname=" | cut -d "=" -f2 | tr -d "\"'")
if [[ $PKG_NAME ]]; then
local PKG_VER=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgver=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_REV=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgrev=" | cut -d "=" -f2 | tr -d "\"'")
else local BUILDFILE=$(tar tf $1 | grep "$BUILDFILE"); local BUILDFILE=${BUILDFILE#./}
local PKG_NAME=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgname=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_VER=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgver=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_REV=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgrev=" | cut -d "=" -f2 | tr -d "\"'"); fi
if [ -f "$DTBFILE1" ]; then if grep -q "^[[:punct:]]$PKG_NAME[[:punct:]][[:punct:]][[:punct:]]" $DTBFILE1; then
local LINE="$(sed -n -e "/\(^{$PKG_NAME}.{\)/p" $DTBFILE1|rev|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f1\
|sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g')"
local INSTALLED_PKG_NAME="$(cut -d' ' -f1 <<< $LINE)"  INSTALLED_PKG_VER="$(cut -d' ' -f2 <<< $LINE)"  INSTALLED_PKG_REV="$(cut -d' ' -f3 <<< $LINE)"
if [[ "$PKG_VER" == "$INSTALLED_PKG_VER" ]]
then if [[ "$PKG_REV" == "$INSTALLED_PKG_REV" ]]
     then
     printf "\n\nWarning: $PKG_NAME-$PKG_VER-$PKG_REV already exists with the same version\v\n"
     read -p "Reinstall package ? (y/n) " REP
     case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n' ; exit ;; esac
     else
  if [[ $PKG_REV > $INSTALLED_PKG_REV ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n INSTALLED%3s:%2s\e[3m\e[2m$INSTALLED_PKG_NAME \e[2m\e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m\e[2m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    ''|*) printf "\n\n INSTALLED%3s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    esac else printf "\n\n INSTALLED%3s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n TO INSTALL%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n\n"
    fi; read -p "proceed with the update ? (y/n) " REP
    case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete ; printf '\n' && exit ;; esac
  elif [[ $PKG_REV < $INSTALLED_PKG_REV ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n INSTALLED%3s:%2s\e[3m\e[2m$INSTALLED_PKG_NAME \e[2m\e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m\e[2m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    ''|*) printf "\n\n INSTALLED%3s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    esac else printf "\n\n INSTALLED%3s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n TO INSTALL%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n"
    fi; printf "\e[90mdowngrading packages can seriously damage your system\e[0m\n\n\n"
    read -p "proceed with the installation ? (y/n) " REP
    case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  fi
    fi
elif [[ "$PKG_VER" != "$INSTALLED_PKG_VER" ]]
then
  if [[ $PKG_VER > $INSTALLED_PKG_VER ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n INSTALLED%3s:%2s\e[3m\e[2m$INSTALLED_PKG_NAME \e[2m\e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m\e[2m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    ''|*) printf "\n\n INSTALLED%3s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    esac else printf "\n\n INSTALLED%3s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n TO INSTALL%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n\n"
    fi; read -p "proceed with the update ? (y/n) " REP
    case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  elif [[ $PKG_VER < $INSTALLED_PKG_VER ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n INSTALLED%3s:%2s\e[3m\e[2m$INSTALLED_PKG_NAME \e[2m\e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m\e[2m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    ''|*) printf "\n\n INSTALLED%3s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n TO INSTALL%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    esac else printf "\n\n INSTALLED%3s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n TO INSTALL%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n"
    fi; printf "\e[90mdowngrading packages can seriously damage your system\e[0m\n\n\n"
    read -p "proceed with the installation ? (y/n) " REP
    case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  fi
fi
else printf "\n\nPackage%3s$PKG_NAME-$PKG_VER-$PKG_REV\n\n"
read -p "proceed with the installation ? (y/n) " REP
case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac fi
else printf "\n\nPackage%3s$PKG_NAME-$PKG_VER-$PKG_REV\n\n"
read -p "proceed with the installation ? (y/n) " REP
case $REP in  [yY]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac fi



printf "\n\e[36msetting fakeroot\e[0m\n"
if [ -d $FAKEROOT ]; then
rm -rf $FAKEROOT && mkdir $FAKEROOT && mkdir $FAKEROOT/temproot
else mkdir $FAKEROOT && mkdir $FAKEROOT/temproot; fi
tar xf "$1" -C $FAKEROOT/temproot; cd $FAKEROOT/temproot
printf "\e[36mchecking package\e[0m\n"; sleep 0.67
make_sum_check -c "." -i "$FILES_SHA" && rm -rf $TMP/msc.*;
find -L . \( -perm 711 -o -perm 555 -o -perm 777 -o -perm 511 -o -perm 775 -o -perm 750 \) -exec chmod 755 {} &>/dev/null \; \
       -o \( -perm 444 -o -perm 666 -o -perm 664 -o -perm 640 -o -perm 400 -o -perm 600 -o -perm 440 \) -exec chmod 644 {} &>/dev/null \;


## finding package name, version, install dirs, type and other
## packages types: base --> base , opt --> optional , add --> additional , [ if var empty ] --> other
#### NOTE: there is no dependency checking mechanism in this release.
########### setting a type has no significant effect other than listing packages
sleep 0.20; printf "\e[36mCollecting informations on package ...\e[0m\n"
local pkgname=$(grep --binary-files=text -i "pkgname=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgver=$(grep --binary-files=text -i "pkgver=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgrev=$(grep --binary-files=text -i "pkgrev=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgbid=$(grep --binary-files=text -i "pkgbid=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkg_url=$(grep --binary-files=text -i ^"url=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgdesc=$(grep --binary-files=text -i "pkgdesc=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local depends=$(grep --binary-files=text -i ^"depends=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkggroup=$(grep --binary-files=text -i ^"groups=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local packager=$(grep --binary-files=text -i "packager=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'" | tr ' ' '<>')
local buildtime=$(grep --binary-files=text -i "buildtime=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local builddate=$(grep --binary-files=text -i "builddate=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local makedepend=$(grep --binary-files=text -i "makedepend=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
###########################################################
[[ -n $pkgbid && $pkgbid = 1 ]] && chown -R root:root .
### for any reason if you change the "fakeroot" directory make sure to ajust this '| cut -c "23"- |' section in the following command
################ this removes caracteres to make "temproot" dir as a root
find . -type f,l -exec realpath {} \; | sort -u | cut -c 23- | sed '/'$BUILDFILE'\|'$PKG_INSTALL'\|'$FILES_SHA'/d' | sed '/^$/d' > $FAKEROOT/realpath.bck
###### sorting package data
local fonction_name=""$pkgname"_pth() {    ######################### package $pkgname"
          printf "%s\n" "$fonction_name" > $FAKEROOT/realpath && \
          printf "%s\n" "printf '$COMMENT0 $pkgname\n$COMMENT6 $COMMENT1\n'"  >> $FAKEROOT/realpath
find . -type d \! -name "." -print0 | while IFS= read -r -d '' line; do
parentdir_name="$(basename $line)"
if [[ -n $parentdir_name && ! "${sysdirs[@]}" =~ $parentdir_name ]]; then
printf "%s\n" "printf '  \e[96m$line\e[0m\n'" | sed 's/.\//\//' >> $FAKEROOT/realpath && continue
else continue; fi; done; printf "%s\n" "printf '$COMMENT6 $COMMENT2\n'" >> $FAKEROOT/realpath
while IFS= read -r line; do
######## ignore warnings if you list a package paths for example with the package 'ruby' 
#################### this last contains some caracteres which are not easy to manipulate with the printf command
printf "%s\n" "printf '  \e[96m$(basename $line)\t\t\e[90m$SYMBOLE\e[0m  \e[90m$(dirname $line)\e[0m\n'" >> $FAKEROOT/realpath
done < $FAKEROOT/realpath.bck
COUNT() { printf $#; }; shopt -s nullglob dotglob
local ALL_FOUND=$(COUNT $(printf "%s" "$(find . -type f,l,d \! -iname "." \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" -o -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "pkgconfig" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))"))
local ALL_FOUND_DIRS=$(COUNT $(printf "%s" "$(find . -type d \! -iname "." \! \( -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "pkgconfig" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))"))
local ALL_FOUND_FILES=$(COUNT $(printf "%s" "$(find . -type f,l \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" \))"))
local PKG_SIZE="$(printf "%s" "$(find . -type f,l,d \! -iname "." \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" -o -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "pkgconfig" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))" | du -cah | tail -1 | cut -f 1)B"
shopt -u nullglob dotglob
printf "%s\n" "printf '$COMMENT10[\e[91m$PKG_SIZE\e[0m]; $COMMENT9 $COMMENT5[\e[91m$ALL_FOUND\e[0m], $COMMENT3[\e[91m$ALL_FOUND_DIRS\e[0m] $COMMENT7 $COMMENT4[\e[91m$ALL_FOUND_FILES\e[0m]\n'" >> $FAKEROOT/realpath && printf "}  ########################## package $pkgname" >> $FAKEROOT/realpath && rm -f $FAKEROOT/realpath.bck;


## group/type of the package
if [[ -n "$pkggroup" ]]; then 
 if [[ "$pkggroup" = base || "$pkggroup" = add || "$pkggroup" = opt || "$pkggroup" = other ]]; then
    local pkggroup=$(tr -d "\"'" <<< "$pkggroup")
 else
     printf "\n\e[91merror:\e[0m  unrecognized specified group\n"
     printf "\e[2mplease set a valide group in (pkgbuild) or with 'PKG_GROUP'\nduring the build process. type 'sspm infos' to learn more\e[0m\n"
     exit $ERCODE
 fi
else
 local pkggroup=other
fi


#### installing, checking, activating libraries and restoring broken symbolic links if necessary

#### if set ignore the directory with its contents     
             if [[ "${EXCLUDE:-$IGNORE}" ]]
                then local EXCLUDE_DIR="${EXCLUDE:-$IGNORE}"
                else [[ "$NOT_TRACE_PATH" ]] && local EXCLUDE_DIR="$NOT_TRACE_PATH"
             fi
             if [[ "$EXCLUDE_DIR" ]]; then
             printf "checking directories to exclude:"
             if [[ -d "$EXCLUDE_DIR" ]]; then printf " found\n"
             [[ "$EXCLUDE_DIR" =~ /$ ]] || EXCLUDE_DIR=""$EXCLUDE_DIR"/"
             else printf "\n\e[91m===> ERROR:\e[0m '$EXCLUDE_DIR' directory not found\n\n"
             exit $ERCODE; fi fi

mv "$FILES_SHA" "$BUILDFILE" "$PKG_INSTALL" $FAKEROOT


if [ -z "$2" ]; then
check_dtb -c -i
tar -cpf - ./* | (cd $LOCALROOT && tar --no-overwrite-dir --keep-directory-symlink -xvpf -) | sed 's/^.//g; /\/$/d'
printf "reading config file\n"
if [[ "$(cat $FAKEROOT/$PKG_INSTALL | wc -l)" -gt "2" ]]; then
printf "creating symbolic links\n"
. $FAKEROOT/$PKG_INSTALL
fi
[ -x "/sbin/ldconfig" ] && /sbin/ldconfig &>/dev/null
sleep 0.52; printf "\e[96mchecking symbolic links\e[0m\n"; sleep 0.48
if [[ -z "$EXCLUDE_DIR" ]]; then
find $LOCALROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path \
'/tmp/*' -o -path '/dev/*' -o -path '/run/*' -o -path '/home/*' -o -path '/root/*' \) -delete
else
find $LOCALROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/tmp/*' -o -path \
'/dev/*' -o -path '/run/*' -o -path '/home/*' -o -path '/root/*' -o -path ''$EXCLUDE_DIR'*' \) -delete
fi
else
tar -cpf - ./* | (tar --no-overwrite-dir --keep-directory-symlink -xvpf - -C "$2") | sed 's/^.//g'
sleep 0.52; printf "\e[96mchecking symbolic links\e[0m\n"; sleep 0.48
[ -x "$2/sbin/ldconfig" ] &&  $2/sbin/ldconfig
fi

dtb_ercode=1
[[ "$LC_TIME" = POSIX ]] || export LC_TIME=POSIX
local DATE="$(date +%D)" TIME="$(date "+%I:%M %p")"
local EPOCH="$(date --date="$builddate $buildtime" +%s)"

if [[ -f "$DTBFILE0" ]]; then
[ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0
cp $DTBFILE0 "$DTBFILE0.bck"
if $DTBFILE0 "$pkgname"_pth &>/dev/null; then
sed -i "/"$pkgname"_pth/,/package "$pkgname"/d ; /^$/d" $DTBFILE0
else
$DTBFILE0 "$pkgname"_pth 2>&1
   if [[ $? != $dtb_ercode ]]; then
    printf "\n%1san \e[91merror\e[0m occurred while reading database\n"
    printf "%1sthis does not affect the system\n\n"
            printf "do you want to :\n\n%4s(a)%4stry an auto-repair?\n"
            printf "%4s(r)%4srestore to last database backup?\n"
            printf "%4s(q)%4squit?\n\n\n" ; read -p ":: " REP
            case $REP in [aA]) restore_type -b ;; [rR]) restore_type -r ;; [qQ]|*) exit ;; esac
   exit
   fi
fi
sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0; sed -i '/^$/d' $DTBFILE0; sed -i '/^[[:space:]]*$/d' $DTBFILE0
cat $FAKEROOT/realpath >> $DTBFILE0; sed -i 's/^}.*/&\n\n/' $DTBFILE0

                                         if [[ "$(grep --binary-files=text $pkgname"_pth" $DTBFILE0|cut -d'_' -f1|wc -w)" -gt 1 ]]; then
                                            sed -i "/$pkgname.*_pth/I,/}.*$pkgname/I d ; /^$/d" $DTBFILE0
                                            cat $FAKEROOT/realpath >> $DTBFILE0
                                            sed -i 's/^}.*/&\n\n/' $DTBFILE0
                                         fi

printf '%b\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n' >> $DTBFILE0
local SPCLINE="$(( $(grep -n '^#-*-#$' $DTBFILE0 |tail -1|cut -f1 -d':') + 1 ))"
local LINE_STAT="$(head -n $SPCLINE $DTBFILE0|tail -1)"
[[ "$LINE_STAT" =~ ^[[:space:]]+$ ]] || sed -i -e "$(( $SPCLINE - 1 ))a \ " $DTBFILE0
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE0
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE0
[ $(stat -c "%a" "$DTBFILE0") != "755" ] && chmod 755 $DTBFILE0; chattr +i $DTBFILE0; rm -f "$DTBFILE0.bck"
else
printf "#-----------------------------------------------------------------------------------------------#\n\
#%1s$LOGFILE%83s#\n#%1sDescription: sspm installation logfile%56s#\n#%1slast edit: $DATE at $TIME%43sDo not edit by hand%1s#\n\
#-----------------------------------------------------------------------------------------------#\n\n" > $DTBFILE0 
cat $FAKEROOT/realpath >> $DTBFILE0
printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n' >> $DTBFILE0
chmod 755 $DTBFILE0
chattr +i $DTBFILE0
fi
###########################################################    div infos
if [ -f "$DTBFILE1" ]; then
[ ! -w "$DTBFILE1" ] && chattr -i $DTBFILE1
cp $DTBFILE1 "$DTBFILE1.bck"; printf "\e[96mupdating database\e[0m\n"
if grep -q "^[[:punct:]]$pkgname" $DTBFILE1; then
sed -i "/^[[:punct:]]$pkgname\|^.*"$pkgname"_desc/d ; /^[[:space:]]*$/d" $DTBFILE1
else sed -i '/^[[:space:]]*$/d' $DTBFILE1; fi
printf '%b ' "{$pkgname}.{$pkgver}.($pkgrev).{$ARCH}.{$EPOCH}.{$pkggroup}.{$PKG_SIZE}.{$packager}.${depends[@]}${makedepend[@]}\n" >> $DTBFILE1
printf ""$pkgname"_desc<$pkgdesc>url<$pkg_url>\n" >> $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
sed -i -e "$(grep -n '^###*#$' $DTBFILE1 |tail -1|cut -f1 -d':')a \ " $DTBFILE1
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE1
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE1
[ $(stat -c "%a" "$DTBFILE1") != "755" ] && chmod 755 $DTBFILE1; chattr +i $DTBFILE1; rm -f "$DTBFILE1.bck"
[[ -z "$2" ]] && check_dtb -g -f
else
printf "#####################################################################################################\n\
#%2sGenerated by sspm%80s#\n#%2s---------------------------%70s#\n#%2slast edit: $DATE  $TIME%48sDo not edit by hand%1s#\n\
#####################################################################################################\n\n" > $DTBFILE1
printf '%b ' "{$pkgname}.{$pkgver}.($pkgrev).{$ARCH}.{$EPOCH}.{$pkggroup}.{$PKG_SIZE}.{$packager}.${depends[@]}${makedepend[@]}\n" >> $DTBFILE1
printf ""$pkgname"_desc<$pkgdesc>url<$pkg_url>\n" >> $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
chmod 755 $DTBFILE1; chattr +i $DTBFILE1; [[ -z "$2" ]] && check_dtb -g
fi

find $TMP -iname tif.* -delete
                rm -rf $FAKEROOT
                  ipc_tool --break
                       printf '\n'
[ -n $BIMODE ] && unset BIMODE
[ -n $M_CHOWN ] && unset M_CHOWN
}






remove_pkg () {
## we check whether a user has/or can have the necessary privileges to manipulate the database. else error
###########################################################################################################
[[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
check_dtb 1>/dev/null
if [[ (( ! -f "$DTBFILE0" || ! -f "$DTBFILE1" )) && $FIRST_INIT = "N" ]]; then
    case $RANDOM in
    9*1|1*3*8*|*12*0|*6*2|4*3|*0*9*3|7*1*) printf "\e[91mfatal error:\e[0m cannot read database\n"; exit $ERCODE ;;
    ''|*) printf "\e[91mfatal error:\e[0m could not find database\n"; exit $ERCODE ;;
    esac
else
if [[ ! -f "$DTBFILE0" && ! -f "$DTBFILE1" ]]; then printf "no package installed with $(basename $SCRIPTFILE)\n"; exit $ERCODE; fi
local DTB_OWNER="$([[ "$(stat  -c %u $DTBFILE0)" != "$(stat  -c %u $DTBFILE1)" ]] || printf "$(stat  -c %u $DTBFILE1)")"
if [[ "${EUID:-$(id -u)}" -ne "$DTB_OWNER" ]]; then
   if ! [[ -w $DTBFILE0 || -w $DTBFILE1 ]]; then 
   printf "$(basename $SCRIPTFILE): database: Permission denied\n"
   exit $ERCODE
   fi
fi
fi
####################################################################
[[ "$LC_TIME" = POSIX ]] || export LC_TIME=POSIX
local DATE="$(date +%D)" TIME="$(date "+%I:%M %p")"
## directory detection 
             if [[ -n "$1" && "$#" = "1" ]]; then
             local ROOT="/"; local PKGDIR="$PKGDIR"; local DOCDIR="/usr/share/doc/"
             elif [[ -n "$2" && "$#" = "2" ]]; then
             [[ "$2" =~ /$ ]] && local ROOT="${2%?}" || local ROOT="$2"
             local DOCDIR="$ROOT/usr/share/doc/"; local PKGDIR="$ROOT"$PKGDIR
             else printf "\e[91merror:\e[0m unrecognized option\n"
             exit $ERCODE; fi
             ipc_tool -l
[[ "$2" ]] || check_dtb -c -r
if grep -q "^"$1"_pth" $DTBFILE0 && grep -q "^[[:punct:]]"$1"" $DTBFILE1; then
local LINE="$(sed -n -e "/\(^{$1}\)/p" $DTBFILE1)"
local LINE0="$(rev <<< "$LINE"|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f1|sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g')"
local LINE1="$(rev <<< "$LINE"|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f2-|sed 's/)(/) (/')"
printf "\e[36mSearching package informations ...\e[0m\n"; sleep 0.25
local PKG_NAME="$(cut -d' ' -f1 <<< $LINE0)"
local PKG_VER="$(cut -d' ' -f2 <<< $LINE0)"
local PKG_REV="$(cut -d' ' -f3 <<< $LINE0)"
local PKG_TYPE="$(cut -d' ' -f6 <<< $LINE0)"
local PKG_SIZE="$(cut -d' ' -f7 <<< $LINE0)"
local PKG_DEPEND=("$(cut -d')' -f1 <<< $LINE1|tr -d '()')")
local PKG_MAKE_DEPEND=("$(cut -d'(' -f3- <<< $LINE1|tr -d '()')")

                               while IFS= read -r LINE; do
                                if [[ -n "$LINE" && ! $LINE =~ ^"{$1" ]]; then
                                NAME="$(tr -d '{}' <<< "${LINE%%.*}")"  
                                MATCH="$(cut -d')' -f1 <<< "${LINE##*.}" | tr -d '()')"
                                for PKG in $MATCH; do [[ $PKG != "$1" || "${PKG_MAKE_DEPEND[@]}" =~ "$NAME" ]] || PKG_MAKE_DEPEND+=("$NAME"); done
			           else continue
                                fi
                               done <<< "$(grep ^'{.*)'$ $DTBFILE1 | grep "\<$1\>")"

## the only one rule if you set a package as type 'base' is to fail its uninstallation if the package make dependence (is required by another package)
## none sspm dependency checking mechanism exist yet
#######################################################################################################################################################
if [[ ${#PKG_MAKE_DEPEND[@]} -gt 0 ]]; then
local FOUND_PKGMAKE_DEPEND=()
for NAME in ${PKG_MAKE_DEPEND[@]}; do ( grep -q "^{$NAME}" $DTBFILE1) && local FOUND_PKGMAKE_DEPEND+=("$NAME"); done
if [[ ${#FOUND_PKGMAKE_DEPEND[@]} -gt 0 ]]; then
case $PKG_TYPE in
        base)
        repeat() { N=$(($(wc -c <<< "${FOUND_PKGMAKE_DEPEND[@]}") + 3)); printf -- "$1%.0s" $(seq 1 $N); }
        local words="$([[ ${#FOUND_PKGMAKE_DEPEND[@]} = 1 ]] && printf "this package" || printf "these packages")"
        printf "\e[91merror :\e[0m this package is required by :\n"
        printf "%b$(repeat -)\n| $(cat <<< ${FOUND_PKGMAKE_DEPEND[@]}) |\n$(repeat -)\n"
        printf "and is set as '\e[1m\e[3mbase\e[0m' package\n"
        printf "uninstall $words first\n\n"
        printf "$(basename $SCRIPTFILE): '$PKG_NAME' cannot remove package\n"
        exit $ERCODE        
        ;;
esac
fi

# some dialogs work better with RANDOM var. can be removed 
# if you are sure that RANDOM var will always be available
local RANDOM=${RANDOM:-$(shuf -i 1-100000 -n 1)}
#################################################################

local COLOR="$(
if [[ $RANDOM == [[:digit:]]5* ]]
 then printf '\\e[95m'
  elif [[ $RANDOM == 2* ]]
   then printf '\\e[32m'
    elif [[ $RANDOM == *0 ]]
     then printf '\\e[35m'
      elif [[ $RANDOM == *6*0* ]]
        then printf '\\e[33m'
          elif [[ $RANDOM == *1* ]]
            then printf '\\e[97m'
              elif [[ $RANDOM == 8* ]]
                then printf '\\e[93m'
                   elif [[ $RANDOM == *7 ]]
                      then printf '\\e[31m'
                        else printf '\\e[97m';fi)"
fi
printf "\n%5spackage: "$PKG_NAME"  version ($PKG_VER) revision ($PKG_REV) \n%15stype '$PKG_TYPE' \n%15smake dependence to:\n\
%14s\e[3m$COLOR$(cat <<< "${FOUND_PKGMAKE_DEPEND[@]}") \e[0m\n\n%10sfree up  $PKG_SIZE\n\n"


read -p "Uninstall package ? (y/n) " REP
case $REP in [yY]|'')  printf "\n" ;; [nN]|*) printf "\n" && exit ;; esac
else printf "sspm: '$1' not installed\n"; exit $ERCODE; fi
local FILES="$($DTBFILE0 "$1"_pth|sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"\
|sed '/'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|^'$COMMENT10.*$COMMENT9.*$COMMENT5'/d'\
|sed -e 's/\'$SYMBOLE'\|'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|'$COMMENT3'\|'$COMMENT4'\|'$COMMENT5'\|'$COMMENT6'\|'$COMMENT7'\b\|\[[^]]*\]//g' \
| tr '\t' ' ')" 

             #### if set ignore the directory with its contents
             if [[ "${EXCLUDE:-$IGNORE}" ]]
                then local EXCLUDE_DIR="${EXCLUDE:-$IGNORE}"
                else [[ "$NOT_TRACE_PATH" ]] && local EXCLUDE_DIR="$NOT_TRACE_PATH"
             fi
             if [[ "$EXCLUDE_DIR" ]]; then
             printf "checking directories to exclude:"
             if [[ -d "$EXCLUDE_DIR" ]]; then printf " found\n"
             [[ "$EXCLUDE_DIR" =~ /$ ]] || EXCLUDE_DIR=""$EXCLUDE_DIR"/"
             else printf "\n\e[91m===> ERROR:\e[0m '$EXCLUDE_DIR' directory not found\n\n"
             exit $ERCODE; fi fi
             ######  verification
             local PKG_DIRS=() PKG_FILES=()
             shopt -s extglob
             while IFS= read -r LINE; do
             local LINE="${LINE##*( )}"
             local LINE="${LINE%%*( )}"
             if [[ "$LINE" =~ ^/ && ! "${PKG_DIRS[@]}" =~ "$LINE" ]]
             then local PKG_DIRS+=("$LINE")
             else
                if [[ "$(wc -w <<< "$LINE")" = 2 ]]; then
                local PKG_FILE=""${LINE##* }"/"${LINE%% *}""
                [[ "${PKG_FILES[@]}" =~ "$PKG_FILE" ]] || local PKG_FILES+=("$PKG_FILE")
                [[ "${PKG_DIRS[@]}" =~ "${LINE##* }" ]] || local PKG_DIRS+=("${LINE##* }")
                else  local PKG_FILES+=("$LINE");  fi
             fi
             done <<< "$FILES"
             shopt -u extglob
             ###### removing the package
             local DTB_CONTENT="$(cat -s $DTBFILE0 | sed "/"$1"_pth/,/package "$1"/d" \
             | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" \
             | sed '/^#\|'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|^.*'$COMMENT10.*$COMMENT9.*$COMMENT5'/d' \
             | sed -e 's/\'$SYMBOLE'\|'$COMMENT1'\|'$COMMENT2'\|'$COMMENT3'\|'$COMMENT4'\|'$COMMENT5'\|'$COMMENT6'\|\[[^]]*\]//g' | tr '\t\n' ' ')"
             rm -fv ${PKG_FILES[@]}  | tr -d "\"'" | sed 's/removed\| su.*$//g'
             for PKG_DIR in ${PKG_DIRS[@]}; do
             [[ "${sysdirs[@]}" =~ "$(basename "$PKG_DIR")" || "$DTB_CONTENT" =~ "$PKG_DIR" ]] && continue || rm -rf $PKG_DIR && printf "%s\n" "$PKG_DIR"
             done;   [[ -n "$(find "$DOCDIR" -name "$1*")" ]] && find "$DOCDIR" -name "$1*" -print0 | xargs -0 rm -rf
             #### checking symbolic links
             if [ -z "$2" ]; then
             if [ -z "$EXCLUDE_DIR" ]; then
             find $ROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/run/*' -o -path '/tmp/*' -o -path '/dev/*' -o -path '/home/*' -o -path '/root/*' \) -delete
             else
             find $ROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/tmp/*' -o -path '/run/*' -o -path '/dev/*' -o -path '/home/*' -o -path '/root/*' -o -path ''$EXCLUDE_DIR'*' \) -delete
             fi
             fi

### database update
[ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0 && local PERM1=ro
cp $DTBFILE0 "$DTBFILE0.bck"
sed -i "/"$1"_pth/,/package "$1"/d" $DTBFILE0 && sed -i '/^$/d' $DTBFILE0
sed -i 's/^}.*/&\n\n/' $DTBFILE0; sed -i '/'"$PARSEID"'/i\\' $DTBFILE0
local SPCLINE="$(( $(grep -n '^#-*-#$' $DTBFILE0 |tail -1|cut -f1 -d':') + 1 ))"
local LINE_STAT="$(head -n $SPCLINE $DTBFILE0|tail -1)"
[[ "$LINE_STAT" =~ ^[[:space:]]+$ ]] || sed -i -e "$(( $SPCLINE - 1 ))a \ " $DTBFILE0
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE0
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE0
[ $(stat -c "%a" "$DTBFILE0") != "755" ] && chmod 755 $DTBFILE0
[[ -n "$PERM1" && "$PERM1" = "ro" ]] && chattr +i $DTBFILE0
rm -f "$DTBFILE0.bck"
[ ! -w "$DTBFILE1" ] && chattr -i "$DTBFILE1" && local PERM2=ro
cp $DTBFILE1 "$DTBFILE1.bck"
sed -i "/^[[:punct:]]"$1"\|^"$1"/d" $DTBFILE1 && sed -i '/^$/d' $DTBFILE1
sed -i '/^[[:space:]]*$/d' $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
sed -i -e "$(grep -n '^###*#$' $DTBFILE1 |tail -1|cut -f1 -d':')a \ " $DTBFILE1
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE1
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE1
[ $(stat -c "%a" "$DTBFILE1") != "755" ] && chmod 755 $DTBFILE1
[[ -n "$PERM2" && "$PERM2" = "ro" ]] && chattr +i $DTBFILE1
rm -f "$DTBFILE1.bck"
[[ -z "$2" ]] && check_dtb -g -f
ipc_tool -s
printf "\n\e[90m%10suninstalled%10s\e[0m\n\n"
}


                           restore_type () {
                           ## this tool will try to repair the database with common errors, if that fails try manually.   
                           ##  assuming "/tmp" is temporary directory the idea is to group errors at the end of the file
                           ##  in order to inspect them    (to be tested)
                           #############################################################################################
                               case $1 in -b)
                               sleep 0.20; printf "\n\e[93mWarning:\e[0m this may take time\n\n";  sleep 0.70
                               printf "database reading test%22s"
                               [[ -r "$DTBFILE0" && -r "$DTBFILE1" ]] && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[91mfailed\e[0m ]\n"
                               printf "checking installed packages%10s"
                               local PKG_NAMES0=($(grep _pth "$DTBFILE0"|cut -d '_' -f1|tr '\n' ' '))
                               if [[ "${#PKG_NAMES0[@]}" -gt 0 ]]; then printf "[ ${#PKG_NAMES0[@]} ]%2s[ \e[92mok\e[0m ]\n"
                               else printf "[ \e[91munknown\e[0m ]\n"; fi
                               printf "database sync test%14s"
                               local PKG_NAMES1=($(grep _desc "$DTBFILE1"|cut -d '_' -f1|tr '\n' ' '))
                               [[ "${#PKG_NAMES1[@]}" -gt 0 && (( "${#PKG_NAMES1[@]}" -eq "${#PKG_NAMES0[@]}" )) ]] &&
                               printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n"
                               printf "creating temp database%18s"
                               local tmp_database0="$(mktemp /tmp/$LOGFILE.XXXXXX)" && chmod u+x $tmp_database0 && printf "[ \e[92mok\e[0m ]\n"
                               if [[ "${#PKG_NAMES1[@]}" -ne "${#PKG_NAMES0[@]}" ]]; then
                               printf "fast retrieve test%32s"
                               if [[ "${#PKG_NAMES1[@]}" -lt "${#PKG_NAMES0[@]}" ]]; then
                               local first_pkg="$(cut -d' ' -f1 <<< ${PKG_NAMES1[@]} )"
                               local last_pkg="$(rev <<< ${PKG_NAMES1[@]}|cut -d' ' -f1|rev)"
                               sed -n "/$first_pkg.*_pth/I,/}.*$last_pkg/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               $tmp_database0 "$last_pkg"_pth  &>/dev/null
                               [ $? -eq 0 ] && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n" &&
                               printf "saving temp database%16s"
                               local tmp_database1="/tmp/$LOGFILE" && mv $tmp_database0 $tmp_database1 &&
                               printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n" &&
                               printf "checking remaining data%27s"
                               sed -i "/$first_pkg.*_pth/I,/}.*$last_pkg/I d ; /^$/d" $DTBFILE0
                               sed -i '/^'}'/a\\' $DTBFILE0 && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n"
                               printf 'troubleshooting ...%36s'
                               local LAST_PKG_NAMES0=($(grep _pth "$DTBFILE0"|cut -d '_' -f1|tr '\n' ' '))
                               >$tmp_database0 && chmod u+x $tmp_database0
                               for pkg_name in ${LAST_PKG_NAMES0[@]}; do
                               sed -i -e '/'"$PARSEID"'/,$d' $tmp_database0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               if $tmp_database0 "$pkg_name"_pth &>/dev/null; then
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database1
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               continue
                               else
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0
                               sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 && cat $tmp_database1 >> $DTBFILE0 && sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 
                               sed -i '/^'}'/a\\' $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               printf '#####################################################################################################\n' >> $DTBFILE0
                               printf '########################### error: cannot properly read this section\n\n' >> $DTBFILE0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $tmp_database0 >> $DTBFILE0
                               printf '\n#####################################################################################################\n' >> $DTBFILE0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $DTBFILE0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $DTBFILE0
                               find /tmp \( -iname tif.* -o -iname $LOGFILE -o -iname $LOGFILE.* \) -delete ; rm -rf $FAKEROOT
                               printf "\n\e[91merror:\e[0m  courld not read this last section '"$pkg_name"_pth'\n\e[2min '$DTBFILE0'\e[0m\n"
                               exit $ERCODE
                               fi
                               done
                               fi
                               else
                               printf 'troubleshooting ...%34s'
                               local tmp_database1="/tmp/$LOGFILE"
                               >$tmp_database0 && chmod u+x $tmp_database0
                               for pkg_name in ${PKG_NAMES0[@]}; do
                               sed -i -e '/'"$PARSEID"'/,$d' $tmp_database0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               if $tmp_database0 "$pkg_name"_pth &>/dev/null; then
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database1
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               continue
                               else
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0
                               # sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> "$PKGDIR/database/check_me"
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $tmp_database0 >> "$PKGDIR/database/check_me"
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $tmp_database0
                               continue
                               fi
                               done
                               sed -i '/^.*_pth/,$d' $DTBFILE0 ; sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 && cat $tmp_database1 >> $DTBFILE0 &&
                               sed -i '/^'}'/a\\' $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               sed -i '/^'}'/a\\' "$PKGDIR/database/check_me" ; printf '\n' >> "$PKGDIR/database/check_me"
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $DTBFILE0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $DTBFILE0
                               find /tmp \( -iname tif.* -o -iname $LOGFILE -o -iname $LOGFILE.* \) -delete ; rm -rf $FAKEROOT
                               printf "[ \e[92mok\e[0m ]\n"
                               printf "\nplease inspect '$PKGDIR/database/check_me'\n"                             
                               printf "then recopy its contents in '$DTBFILE0' if there is no error.\n"
                               fi
                               ;;
                               -r)
                               local FNAME=".asosdtb"
                               if [ -f "$PKGDIR/database/$FNAME" ]; then
                               chattr -i "$DTBFILE0" "$DTBFILE1" ; rm -f "$DTBFILE0.bck" "$DTBFILE0" "$DTBFILE1"
                               tar -xf "$PKGDIR/database/$FNAME" -C "$PKGDIR/database/" && chattr +i "$DTBFILE0" "$DTBFILE1"
                               check_dtb -g -f
                               else
                               printf "\e[91mfatal error:\e[0m can't find backup file\n"
                               exit $ERCODE
                               fi                         
                               ;;
                               esac                        
                           
                           }
                           
                           
                           
                           
                           
        





###################################    General Parse Options    (the parse zone)
############################################################################################################
############################################################################################################
# options sorting and encoding
input=(); extra_0=(); extra_1=(); file=(); fatal=(); positionnal=() opt_end=
[[ "$#" -gt 0 ]] && optin="y:$#"; while [[ $# -gt 0 ]]; do
arg="$1"; shift; case "${opt_end}${arg}" in
-rtf|-pi|-ip|-aq|-qa|-qq|-wh|-eh|-pe|-ep|--*) args+=("$arg") ;;
-ob|-bo|-io|-oi|-br|-or|-ro|-rb|-lr|-rl|-ri|-ir|[[:punct:]]) fatal+=("$arg") ;;
-*) for i in $(seq 2 ${#arg}); do args+=("-${arg:i-1:1}"); done ;;
*) args+=("$arg") ;; esac done;   set -- "${args[@]}"

while [[ $# -gt 0 ]]; do
  arg="$1"; shift
  case "${opt_end}${arg}" in
    --)                                           fatal+=("$arg"); opt_end=1 ;;
    -rtf|--remnant-files)                         input+=("c") ;;
    --root=*|-r=*)                                extra_0+=("${arg#*=}") ; r+=("1") ;;
    --destdir=*)                                  extra_1+=("${arg#*=}") ; r+=("2") ;;
    -r*|--root*)                                  extra_0+=("$1") ; r+=("1") ; shift ;;
    -o*|--destdir*)                               extra_1+=("$1") ; r+=("2") ; shift ;;
    infos|'info')                                 input+=("a") ;;
    -v|--version)                                 input+=("b") ;;
    -pe|-ep|--pkgbuild-example)                   input+=("i") ;;
    --depends|--depend)                           input+=("d") ;;
    -p|--path)                                    input+=("e") ;;
    -pi|-ip|--print-infos)                        input+=("f") ;;
    -l|--list)                                    input+=("g") ;;
    -h|--help)                                    input+=("h") ;;
    -R|--remove)                                  input+=("7") ;;
    -d|--debug)                                   input+=("0") ;;
    -q|--quiet)                                   input+=("1") ;;
    -qq|--quiet-all)                              input+=("2") ;;
    -qa|-aq|--always-quiet)                       input+=("3") ;;
    -wh|-eh|--enable-hash|--with-hash)            input+=("4") ;;
    -b|--build)                                   input+=("5") ;;
    -i|--install)                                 input+=("6") ;;
    --*)                                          fatal+=("$arg") ;;
    -*) for i in $(seq 2 ${#arg}); do input0+=("-${arg:i-1:1}"); done ;;
    *)                                            file+=("$arg") ;;
  esac
done

set -- ${positionnal[@]}

                 
    # syntax checking
    if [[ -v LV_BUILD && -n "$LV_BUILD" && $optin == y:[[:digit:]] ]]; then
    INT_MODE="$(tr '[:upper:]' '[:lower:]' <<< ${LV_BUILD//[[:punct:][:digit:]]})"
    if [[ "$INT_MODE" = on || "$INT_MODE" = y || "$INT_MODE" = yes  ]]; then
    if [[ "${input[@]}" = 5 && "${optin//[[:alpha:][:punct:]]}" -gt 1 ]] \
    || [[ "${input[@]}" =~ 5 && "${#input[@]}" -gt 1 ]]; then
    printf "\e[2mthe interactive mode was set type \e[0m'sspm -b'\e[2m to start or unset 'LV_BUILD'\e[0m\n"; exit $ERCODE; fi fi fi
    N="$(cat <<< "${input0[@]}"|wc -w)"
    if [[ "${#input[@]}" -gt 1 && -n "$(tr ' ' '\n' <<< "${input[@]}" | sort |uniq -d|tr -d '\n')" ]]; then
    printf "error:  too many options\nTry 'sspm --help' for more infos.\n"; exit $ERCODE; fi
    if [[ -n "${r[@]}" && (( "$extra_0" = \-[[:alpha:]] || "$extra_1" = \-[[:alpha:]] )) ]]; then
    printf "sspm : syntax error, enter a path\n"; exit $ERCODE; fi    
    if [[ -n "$N" ]]; then if [[ "$N" -gt 1 ]]; then
    unknown_opt="$(sed 's/-p\|-i\|-l\|-h\|-o\|-R\|-q\|-b\|-d\|-v\|-r\|infos\|info\|--depends\|--depend//g; s/^ //g' <<< ${input0[@]})"
    if [[ -n "$unknown_opt" ]]; then
    printf "%ssspm :  error  unrecognized options -- '$(tr -d '[:punct:]' <<< $unknown_opt)'\nTry 'sspm --help' for more infos.\n"
    exit $ERCODE; else  printf "%ssspm :  syntax error '$(cat <<< ${input0[@]})'\nTry 'sspm --help' to learn more.\n"
    exit $ERCODE; fi else  fatal+=("$input0"); if [[ -n "${fatal[@]}" ]]; then
    printf "%serror:  unrecognized option -- '$(tr -d '[:punct:]' <<< ${fatal[@]})'\nTry  << sspm --help >> to learn more.\n"
    exit $ERCODE; fi  fi  fi;  if [[ "${input[@]}" =~ [0-9] && (( "${input[@]}" =~ [a-z] || "${input[@]}" =~ [A-Z] )) ]]; then
    printf "sspm :  error too many arguments\nTry << sspm --help >> for infos.\n"; exit $ERCODE; fi
    if [[ "${input[@]}" =~ '1' || "${input[@]}" =~ '2' || "${input[@]}" =~ '3' || "${input[@]}" =~ '4' ]]; then
    if [[ ! "${input[@]}" =~ '5' ]]; then
    printf "%ssspm :  '-q*/--quiet* and -wh' options can only be used if '-b' is present\n"
    exit $ERCODE; fi fi; if [[ "${input[@]}" =~ '7' && (( "${input[@]}" =~ '5' || "${input[@]}" =~ '6' )) ]]; then
    printf "sspm :  error too many arguments\nTry 'sspm --help' for more informations.\n"; exit $ERCODE; fi
    if [[ "${input[@]}" =~ '0' ]]; then if [[ "$EUID" != 0 || $(id -u) != 0 ]]; then
    printf "error:  you need to be root to run debug mode\n";  exit $ERCODE; fi fi
    if [[ "${input[@]}" =~ ^[[:alpha:][:space:]]+$ ]]; then if [[ "${#input[@]}" -gt 1 ]]; then
    printf "sspm :  too many options\nTry  << sspm --help >> for more infos.\n"; exit $ERCODE; fi
    elif [[ "${input[@]}" =~ '6' && ! "${input[@]}" =~ '5' ]]; then
    if [[ "${r[@]}" =~ 2 ]]; then
    printf "sspm : syntax error '-o/--destdir' can only be used if:\n"
    printf "'-b/--build' or '-pe/--pkgbuild-example' is present\n\e[2mTry  << sspm infos >> to learn more.\e[0m\n"
    exit $ERCODE;  fi
    elif [[ "${input[@]}" =~ '5' && ! "${input[@]}" =~ 6 ]]; then
    if [[ "${r[@]}" =~ 1 ]]; then
    printf "sspm : syntax error '-r/--root' can only be used if:\n"
    printf "'-i/--install' or '-p/--path' is present\n\e[2mTry  << sspm infos >> to learn more.\e[0m\n"
    exit $ERCODE;  fi
    elif [[ -z "${input[@]}" && (( -n "$extra_0" || -n "$extra_1" )) ]]; then
    if [[ "${r[@]}" = 1 ]]; then
    printf "sspm :  unrecognized option \e[2m(ex: sspm -i -b -r /dir -q)\e[0m\n"
    printf "Try  'sspm info' for more informations.\n"; exit $ERCODE
    elif [[ "${r[@]}" = 2 ]]; then
    printf "sspm :  unrecognized option\n\e[2m(ex: sspm --pkgbuild-example -o /dir)\e[0m\n"
    printf "Try  'sspm info' for more informations.\n"; exit $ERCODE
    else printf "sspm :  syntax error\nTry  'sspm info' for more informations.\n"; exit $ERCODE;  fi
    elif [[ -n "${file[@]}" && (( -z "${input[@]}" && -z "${fatal[@]}" )) ]]; then
    printf "error:  unrecognized option\nTry 'sspm --help' to learn more.\n"; exit $ERCODE
    fi ;   if [[ -n "$r" ]]; then if [[ "${#r[@]}" = 1 ]]; then  if [[ "${r[@]}" = 1 ]]; then
    if [[ ! "${input[@]}" =~ [6-7] ]] && [[ "${input[@]}" != [e-g] ]]; then
    printf "sspm :  too many arguments, '-r/--root' can't be used here\nTry  'sspm infos' for more informations.\n"
    exit $ERCODE;  fi;  elif [[ "${r[@]}" = 2 ]]; then  if [[ ! "${input[@]}" =~ '5' && "${input[@]}" != 'i'  ]]; then
    printf "sspm :  too many arguments, '-o/--destdir' can't be used here\nTry  'sspm infos' for more informations.\n"
    exit $ERCODE;  fi  fi;  if [[ -z "$extra_0" && -z "$extra_1" ]]; then
    printf "%serror:  missing argument(s) \n\e[2mTry  << sspm infos >> to learn more.\e[0m\n"; exit $ERCODE;  fi
    elif [[ "${#r[@]}" -gt 2 ]]; then printf "error:  too many arguments\nTry 'sspm --help' for more infos.\n"; exit $ERCODE; fi fi
    if [[ "${input[@]}" = 'i' ]]; then if [[ -n "$r" && (( "${r[@]}" =~ 1 || "${r[@]}" = 1 )) ]]; then
    printf "sspm :  too many options, '-r/--root' cannot be used here\nTry 'sspm infos' for more infos.\n"
    exit $ERCODE;  fi fi;   if [[ "${input[@]}" =~ '5' && -n $file ]]; then  printf "%s\n" "Warning:  unrecognized option '$file'"; fi


# checking and processing the request
commande=(); variable=()

   [[ "${input[@]}" == 'a' ]] && commande=("sspm_infos")
   [[ "${input[@]}" == 'b' ]] && commande=("sspm_version")
   [[ "${input[@]}" == 'c' ]] && variable=("CLEANUP=y")
   [[ "${input[@]}" == 'd' ]] && commande=("sspm_depends")
   [[ "${input[@]}" == 'e' ]] && commande=("e")
   [[ "${input[@]}" == 'f' ]] && commande=("f")
   [[ "${input[@]}" == 'g' ]] && commande=("pkg_infos -l")
   [[ "${input[@]}" == 'h' ]] && commande=("usage")
   [[ "${input[@]}" == 'i' ]] && commande=("pkgbuild_example")
   [[ "${input[@]}" =~ '0' ]] && variable+=("DEBUG_MODE=y")
   [[ "${input[@]}" =~ '1' ]] && variable+=("STDOUT_MODE=s")
   [[ "${input[@]}" =~ '2' ]] && variable+=("STDOUT_MODE=qs")
   [[ "${input[@]}" =~ '3' ]] && variable+=("PERM_STDOUT_MODE=y")
   if [[ "${input[@]}" =~ '5' ]]; then
   [[ "${input[@]}" =~ '6' ]] && variable+=("NOEXIT=y")
   fi; if [[ "${input[@]}" =~ '6' ]]; then
   [[ "${input[@]}" =~ '5' ]] && variable+=("BIMODE=y")
   fi; [[ "${input[@]}" =~ '5' ]] && commande+=("5")
   [[ "${input[@]}" =~ '4' ]] && commande+=("4")
   [[ "${input[@]}" =~ '6' ]] && commande+=("6")
   [[ "${input[@]}" =~ '7' ]] && commande=("r")

[ -z "$variable" ] || declare ${variable[@]}

	
if [[ -n "$commande" ]]; then
if [[ $commande == 'e' || $commande == 'f' ]]; then
arg="$([ $commande = 'e' ] && printf '%s-p'; [ $commande = 'f' ] && printf '%s-pi')"
if [ -n "$file" ]; then if [ -z "$extra_0" ]; then if [[ ! "$file" == *['!'@#\$%^\&*()_+./]* ]]; then pkg_infos $arg $file
else printf "syntax \e[91merror\e[0m\n\e[90mplease enter a name\nmake sure it does not contain special characters\e[0m\n"; exit $ERCODE; fi
else if [[ ! "$file" == *['!'@#\$%^\&*()_+./]* ]]; then if [ -d "$extra_0" ]; then pkg_infos $arg $file $extra_0
else printf "%serror:  '$extra_0' is not a directory or does not exist\n"; exit $ERCODE; fi
else printf "syntax \e[91merror\e[0m\n\e[90mplease enter a name\nmake sure it does not contain special characters\e[0m\n"
exit $ERCODE; fi  fi else printf "error:  enter a package name\n"; exit $ERCODE; fi
elif [[ $commande == 'r' ]]; then if [ -n "$file" ]; then if [ -z "$extra_0" ]; then if [[ ! "$file" == *['!'@#\$%^\&*()_+./]* ]]; then remove_pkg $file
else printf "syntax \e[91merror\e[0m\n\e[90mplease enter a package name\nand make sure it does not contain special characters\e[0m\n"; exit $ERCODE; fi
else if [[ ! "$file" == *['!'@#\$%^\&*()_+./]* ]]; then if [ -d "$extra_0" ]; then remove_pkg $file $extra
else printf "%serror:  '$extra_0' is not a directory or does not exist\n"; exit $ERCODE; fi
else printf "syntax \e[91merror\e[0m\n\e[90mplease enter a package name\nand make sure it does not contain special characters\e[0m\n"
exit $ERCODE; fi  fi else printf "error:  enter a package name\n"; exit $ERCODE; fi
elif [[ "${commande[@]}" =~ "5" && (( ! "${commande[@]}" =~ "4" && ! "${commande[@]}" =~ "6" )) ]]; then make_build
elif [[ "${commande[@]}" =~ "6" && (( ! "${commande[@]}" =~ "5" )) ]]; then 
[ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "4" && (( ! "${commande[@]}" =~ "6" )) ]]; then make_build -wh
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "4" && "${commande[@]}" =~ "6" ]]; then
make_build -wh && [ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "6" && (( ! "${commande[@]}" =~ "4" )) ]]; then
make_build && [ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0; else $commande; fi
else if [ -z $variable ]; then usage; else if [[ ! "${variable[@]}" =~  ^"CLEANUP=y"$  ]]; then
printf "sspm :  error  too many options\nTry << sspm --help >> for more infos.\n"; exit $ERCODE; fi; fi; fi





#####################################################   End of parse
####################################################################################################
####################################################################################################














                                                                       # Remove all remnant temporary files
                                                                       # left by a stoped build process and other...
                                                                       
                                                                       if [[ -n $CLEANUP && $CLEANUP == [yY] ]]; then
                                                                          [[ ! -d "$TMP" ]] && printf "\e[91merror: \
                                                                          \e[0mUnable to access temp dir\n" && exit 1
                                                                          if [[ -n "$(find "$TMP" \( -name "*_build*" \
                                                                          -o -name "*_source*" -o -iname "*fakeroot*" \
                                                                          -o -name "*tif*" -o -name "*link*" -o -name "*msc*" \
                                                                          -o -name "*extractdir*" -o -name "*$BUILDFILE*" \) \
                                                                          -writable -type f,l,d 2>/dev/null )" ]]; then
                                                                          printf "Warning: this will erase all affected files\n"
                                                                          printf "%10sin the temporary directory\n\n"
                                                                          read -p "Continue ? (y/n) : " REP
                                                                          case $REP in  [yY]|'') printf '\n' ;;  [nN]) \
                                                                          printf '\n' && exit ;;  *) printf '\n' && exit ;; esac
                                                                          if [[ "${EUID:-$(id -u)}" -eq 0 ]]; then find "$TMP" \
                                                                          \( -name '*_build*' -o -iname "*fakeroot*" -o -name '*tif*' \
                                                                          -o -name "*$BUILDFILE*" -o -name '*msc*' -o -name '*link*' \
                                                                          -o -name '*extractdir*' -o -name 'tst*' -o -name '*_source*' \) \
                                                                          -type f,l,d -print0 | xargs -0 rm -rf && printf 'Done\n\n'
                                                                          else find "$TMP" \( -name '*extractdir*' -o -iname "*fakeroot*" \
                                                                          -o -name '*_source*' -o -name "*$BUILDFILE*" -o -name '*msc*' \
                                                                          -o -name '*link*' -o -name 'tst*' -o -name '*_build*' -o -name \
                                                                          '*tif*' \) -writable -type f,l,d -print0 2>/dev/null | xargs -0 rm -rf && \
                                                                          printf 'Done\n\n'; fi; exit; else printf 'empty  \n';exit; fi; fi




if [[ -n "$PERM_STDOUT_MODE" ]]; then if [[ "$PERM_STDOUT_MODE" = "y" ]]; then if [[ "$DIALOG" = "off" ]]; then
sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="on"/' "$SCRIPTFILE"; printf "\e[90msuccess message enabled\e[0m\n"
elif [[ "$DIALOG" = "on" ]]; then sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="off"/' "$SCRIPTFILE"
printf "\e[90msuccess message disabled\e[0m\n"; elif [[ -z "$DIALOG" ]]; then
sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="off"/' "$SCRIPTFILE"; printf "\e[90msuccess message disable\e[0m\n"; fi fi fi

