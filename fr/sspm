#!/usr/bin/env bash
####################################################################################################
#  Ce script fait partie de Epsilon(sspm) - https://jpsspm.github.io/sspm                          #
#  Copyright (C) 2021-2022 Joe Packar    (joepackar@gmail.com)                                     #
#                                                                                                  #
#  **** gestionnaire de paquet pour les systemes d'explotations compiles a partir de zero ****     #
#                                                                                                  #
#  Ce programme est un logiciel libre; vous pouvez le redistribuer ou le modifier sous les termes  #
#  de la GNU General Public License telle que publiee par la Free Software Foundation;             #
#  soit la version 3 de la licence, soit (a votre choix) toute version ulterieure.                 #
#                                                                                                  #
#  Ce programme est distribue dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE;           #
#  sans meme la garantie implicite de QUALITE MARCHANDE ou ADAPTATION A UN USAGE PARTICULIER.      #
#  Voir la GNU General Public License pour plus de details.                                        #
#                                                                                                  #
#  Vous devriez avoir recu une copie de la GNU General Public License avec ce programme.           #
#  si ce n'est pas le cas, consultez <http://www.gnu.org/licenses/>.                               #
#                                                                                                  #
#  sspm utilise pas mal de programmes externes lors de son execution. Vous devez avoir au moins    #
#  les elements suivants installes pour que sspm fonctionne: bsdtar (libarchive), gawk, zstd,      #
#  coreutils, e2fsprogs, which, tar, grep, sed, pkg-config, Procps, find, xz                       #
####################################################################################################


# NOTE: sspm a ete penser pour creer un systeme linux a partir de la "source", si vous en construisez un
#       ou si vous l'utilisez comme simple gestionnaire de paquets, assurez vous que la variable "SRC"
#       est bien definie dans votre shell ou dans le fichier "~/.bashrc" de votre environnement ou systeme
#       (ex: export SRC=/tools/blabla/sources) avant de compiler un paquet.
#       
#
#       si vous construisez un systeme l'approche est: une fois les outils temporaires installes, placez
#       ce script dans "/usr/bin" ou ailleurs et rendez-le executable. l'idee est de deballer une archive
#       stockee dans "$SRC" puis de compiler et fausser l'installation du paquet dans un environnement
#       temporaire propre, ecrire les informations necessaires pour la gestion du paquet, creer le paquet.
#       sspm est principalement inspire du 'livre lfs' et de 'makepkg'
#
#       attention le fonctionnement de certaines commandes depend parfois des commentaires ecrits apres
#       une autre commande (ex: command -f quelque_chose  # fin du bloc) 
#       le commentaire "fin du bloc" peut etre utilise comme repere par une autre commande, etc...
#       on modifie seulement si on sait et on est sure de ce que l'on fait.






# lors du developpement du script j'ai rencontre un probleme que j'ai resolu avec la methode suivante:
# par exemple: pendant l'installation d'un paquet le script lit et ecrit certaines informations dans
# son propre fichier, or dans un environnement chroote bash (bash 5) interprete mal les accents aigues, graves,
# circonflexe, etc... lors de la lecture d'un fichier . ce qui faisait que je me retrouvais avec des caracteres non 
# imprimables dans ce fichier ou le texte affiche sur la console. rendant ainsi le script completement inutilisable.
# j'avais deux possibilites (plus simple selon moi) soit:   
# * traduire tout le script en anglais 
# * ou enlever tout les accents du script puis les indiques en codage hex:
# oui je sais j'ai meme pas accentuer tout ce que je viens de dire

# ceci nous garantit les accents meme avec un locale non-francophone
A_grave='\xC3\x80'
a_grave='\xc3\xa0'
a_circumflex='\xc3\xa2'
a_diaeresis='\xc3\xa4'
c_cedilla='\xc3\xa7'
e_acute='\xc3\xa9'
e_grave='\xc3\xa8'
e_diaeresis='\xc3\xab'
e_circumflex='\xc3\xaa'
E_acute='\xc3\x89'
E_grave='\xc3\x88'
E_circumflex='\xc3\x8a'
i_circumflex='\xc3\xae'
i_diaeresis='\xc3\xaf'
o_circumflex='\xc3\xb4'
u_grave='\xc3\xb9'






# sspm n'est pas encore adapte pour d'autres SHELLS pour le moment. sortir si different de 'bash'.
if [[ "$SHELL" != *"bash" ]]; then
sleep 0.30
printf "\e[91mD"$e_acute"sol"$e_acute"\e[0m, seul << bash >> est support"$e_acute"\n"
exit 1
fi

# Verification des dependances de sspm
if ( ! type awk bsdtar chattr find sha256sum ps sed tar which zstd &>/dev/null ); then
LINE="$(cat "$(realpath -q $0)" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0")"
if [[ "$LINE" == 'PKGDTB_DIGIT0=("")' || "$LINE" == 'PKGDTB_DIGIT0=()' \
|| "$LINE" == 'PKGDTB_DIGIT0=' || "$LINE" == 'local PKGDTB_DIGIT0=("")' \
|| "$LINE" == 'local PKGDTB_DIGIT0=()' || "$LINE" == 'local PKGDTB_DIGIT0=' ]]; then
if [[ -z "$SOURCES" || -z "$DESTDIR" ]]; then
printf "Vous devez installer manuellement ces paquets:\n\e[4mwhich\e[0m, \e[4mzstd\e[0m, \e[4mlibarchive\e[0m, \e[4mpkg-config\e[0m, \e[4mprocps\e[0m \
et \e[4me2fsprogs\e[0m\ndans un r"$e_acute"pertoire temporaire pour faire fonctionner sspm\n\n\e[2m%1ssi vous voulez que cela se fasse automatiquement\n\
%1sexportez ces deux variables dans votre shell:\n ex: export \e[0m\e[1mSOURCES\e[0m\e[2m='/dir/containing/sources'\n\
%1sex: export \e[0m\e[1mDESTDIR\e[0m\e[2m='/dir/to_install/temp_packages'\n%1spuis r"$e_acute"ex"$e_acute"cutez votre commande\n\n\
%1sveuillez vous assurer que vous disposez de ces fichiers sources\n%1savec les versions suivantes ou ult"$e_acute"rieures: \
libarchive v3.5.2, zstd v1.5.2\n%1spkg-config v0.29.2, which v2.21, procps-ng v3.3.17 et e2fsprogs v1.46.5\n\n\
%1ssi vous avez d"$e_acute"j"$a_grave" install"$e_acute" tous ces paquets, mettez "$a_grave" jour et exportez\n\
%1sla variable 'PATH' dans le shell ou sourcez le fichier .bashrc\n%1spour que ces paquets soient visibles dans l'environnement\e[0m\n\n"
[[ ! -v "SOURCES" && -v "DESTDIR" ]] && printf "%1sveuillez initialiser la variable '\e[91mSOURCES\e[0m'\n\n" && exit 1
[[ ! -v "DESTDIR" && -v "SOURCES" ]] && printf "%1sveuillez initialiser la variable '\e[91mDESTDIR\e[0m'\n\n" && exit 1
exit 1
else
unset LINE
[[ "$DESTDIR" =~ /$ ]] && DESTDIR="${DESTDIR%?}"
[ ! -d "$SOURCES" ] && printf "erreur: impossible d'acc"$e_acute"der au r"$e_acute"pertoire source sp"$e_acute"cifie"$acute"\n" && exit 1
[ ! -d "$DESTDIR" ] && mkdir -p $DESTDIR
[ ! -d "$DESTDIR/lib" ] && mkdir -p $DESTDIR/lib
TEMP='/tmp'; BASHRC='.bashrc'

            if ! type which &>/dev/null && ! type "$DESTDIR/usr/bin/which" &>/dev/null && \
               ! type "$DESTDIR/bin/which" &>/dev/null; then
              FILE="$(find $SOURCES -iname "which*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'which' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
             printf '\n\n%9sCompilation des de'$acute'pendances de sspm ...\n\n'; sleep 0.67
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr && \
		make && make install; cd $TEMP && rm -r $CD_DIR;
                   fi 
            if ! type zstd &>/dev/null && ! type "$DESTDIR/usr/bin/zstd" &>/dev/null && \
               ! type "$DESTDIR/bin/zstd" &>/dev/null; then
              FILE="$(find $SOURCES -iname "zstd*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'zstd' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && \
                make && make prefix=/usr install; cd $TEMP && rm -r $CD_DIR;
                rm -v $DESTDIR/usr/lib/libzstd.a; mv -v $DESTDIR/usr/lib/libzstd.so.* $DESTDIR/lib
                SLINK0="$(find $DESTDIR -name "libzstd.so" -type l -print | head -1)"
                SLINK1="$(find $DESTDIR -name "libzstd.so.*" -type l -print | head -1)"
                ln -sfv ../../lib/$(readlink $SLINK0) $SLINK0
                ln -sfv $DESTDIR/lib/$(basename $(readlink $SLINK0)) /usr/lib/$(basename $SLINK0)
                ln -sfv $DESTDIR/lib/$(basename $(readlink $SLINK1)) /lib/$(basename $SLINK1)
                   fi
            if ! type pkg-config &>/dev/null && ! type "$DESTDIR/usr/bin/pkg-config" &>/dev/null && \
               ! type "$DESTDIR/pkg-config" &>/dev/null; then
              FILE="$(find $SOURCES -iname "pkg-config*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'pkg-config' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --with-internal-glib --disable-host-tool && make && make install; cd $TEMP && rm -r $CD_DIR;
                   fi
              PATH=$PATH:$DESTDIR/bin:$DESTDIR/usr/bin:$DESTDIR/sbin:$DESTDIR/usr/sbin
            if ! type bsdtar &>/dev/null && ! type "$DESTDIR/usr/bin/bsdtar" &>/dev/null && \
               ! type "$DESTDIR/bin/bsdtar" &>/dev/null; then
              FILE="$(find $SOURCES -iname "libarchive*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'libarchive' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --without-expat --without-xml2 --without-openssl --without-nettle \
               --disable-bsdcpio --disable-rpath --disable-static --with-zstd && \
               make && make install; cd $TEMP && rm -r $CD_DIR;
               SLINK0="$(find $DESTDIR -name "libarchive.so.*" -type l -print | head -1)"
               ln -sfv $(readlink -e $SLINK0) /usr/lib/$(basename $SLINK0)
                   fi
            if ! type ps &>/dev/null && ! type "$DESTDIR/usr/bin/ps" &>/dev/null && \
               ! type "$DESTDIR/bin/ps" &>/dev/null; then
              FILE="$(find $SOURCES -iname "procps*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'procps-ng' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && ./configure --prefix=/usr \
               --exec-prefix= --libdir=/usr/lib --disable-static --disable-kill && \
               make && make install; cd $TEMP && rm -r $CD_DIR;
               mv -v $DESTDIR/usr/lib/libprocps.so.* $DESTDIR/lib;
               SLINK0="$(find $DESTDIR -name "libprocps.so" -type l -print | head -1)"
               SLINK1="$(find $DESTDIR -name "libprocps.so.*" -type l -print | head -1)"
               ln -svf ../../lib/$(readlink $SLINK0) $SLINK0
               ln -svf $DESTDIR/lib/$(basename $(readlink $SLINK0)) /lib/$(basename $SLINK0)
               ln -svf $DESTDIR/lib/$(basename $(readlink $SLINK1)) /lib/$(basename $SLINK1)
                   fi
            if ! type chattr &>/dev/null && ! type "$DESTDIR/usr/bin/chattr" &>/dev/null && \
               ! type "$DESTDIR/bin/chattr" &>/dev/null; then
              FILE="$(find $SOURCES -iname "e2fsprogs*" -type f -print | head -1 )"
             if [[ -z $FILE || -z "$(file $FILE | grep -E 'compressed|compress'$(printf '\xc3\xa9')'es' )" ]]
             then printf "\n\nerreur: 'e2fsprogs' impossible d'acc"$e_acute"der au fichier source\n"; exit 1; fi
              CD_DIR="$(tar -tf $FILE | head -1)" CD_DIR="${CD_DIR//\/}"
               tar xf $FILE -C $TEMP && cd $TEMP/$CD_DIR && mkdir -pv $TEMP/$CD_DIR/build && \
               cd $TEMP/$CD_DIR/build && ../configure --prefix=/usr --bindir=/bin --with-root-prefix="" \
               --enable-elf-shlibs --disable-libblkid --disable-libuuid --disable-uuidd --disable-fsck && \
               make && make install; cd $TEMP && rm -r $CD_DIR; rm -fv $DESTDIR/usr/lib/{libcom_err,libe2p,libext2fs,libss}.a;
               SLINK0="$(find $DESTDIR -name "libcom_err.so.*" -type l -print | head -1)"
               SLINK1="$(find $DESTDIR -name "libe2p.so.*" -type l -print | head -1)"
               ln -svf $DESTDIR/lib/$(readlink $SLINK0) /lib/$(basename $SLINK0)
               ln -svf $DESTDIR/lib/$(readlink $SLINK1) /lib/$(basename $SLINK1)
               printf 'export PATH='$PATH'\n' >> $HOME/$BASHRC
               printf '\n%10s*** Op'$e_acute'ration r'$e_acute'ussie ***\n\n'
               printf "\e[2m%1smettez "$a_grave" jour et exportez la variable 'PATH' dans votre shell en incluant\n"
               printf "%1s'$DESTDIR' (ex: export PATH=\$PATH:$DESTDIR/bin)\n%1sou tout simplement sourcez le fichier .bashrc\n\n"
               printf "%1sN'oubliez pas de d"$e_acute"sinitialiser les variables 'SOURCES' et 'DESTDIR'\e[0m\n\n"; exit
                   fi
                   
                                                        if [[ -f $HOME/$BASHRC ]]; then
                                                        if test -n "$(sed -n '/\(^PATH.*$\)/h; ${x;p;}' $HOME/$BASHRC)"; then
                                                        source $HOME/$BASHRC
                                                        if ( ! type awk bsdtar chattr find sha256sum ps sed tar which zstd &>/dev/null ); then
                                                        printf "erreur fatale: veuillez sourcer votre fichier '.bashrc'\n"
                                                        printf "%15sou mettez "$a_grave" jour et exportez la variable 'PATH'\n\n" && exit 1
                                                        fi else
                                                        printf "erreur fatale: veuillez sourcer votre fichier '.bashrc'\n"
                                                        printf "%15sou mettez "$a_grave" jour et exportez la variable 'PATH'\n\n" && exit 1
                                                        fi else
                                                        printf "erreur fatale: veuillez sourcer votre fichier '.bashrc'\n"
                                                        printf "%15sou mettez "$a_grave" jour et exportez la variable 'PATH'\n\n" && exit 1
                                                        fi
fi else sleep 0.10; unset LINE
PRINT_INFOS=YES
fi else TAR=bsdtar; umask 022; fi



SSPM_VER=
TMP="/tmp"
TAG="pkg"
PIPE="/dev/ilpc"
GROUP="sspm"
SYMBOLE="---->"
BUILDFILE="pkgbuild"
INFOFILE="pkginfo"
PKG_SHA=".cpkg"
PKG_INSTALL="pkginst"
FILES_SHA=".cfiles"
INS_FILE=".install"
PKGDIR="/var/cache/pkg"
PKG_DTB="pkginfos.dtb"
LOGFILE="install.log"
FAKEROOT="$TMP/fakeroot"
LOCALROOT="/"
OKCODE="0"
ERCODE="1"
DEPEND_ERCODE="7"
ARCH="$(uname -m)"
export BDIR="$(pwd -P)"
PKGEXT="tar.zst"
TEXT0="nom du paquet"
TEXT1="version"
TEXT2="r"$'\xc3\xa9'"vision"
TEXT3="architecture"
TEXT4="date de compilation"
TEXT5="heure de compilation"
TEXT6="paquet de type"
TEXT7="d"$'\xc3\xa9'"pend de"
TEXT8="d"$'\xc3\xa9'"pendant du paquet"
TEXT9="taille du paquet"
TEXT10="compil"$'\xc3\xa9'" par"
TEXT11="environ"
TEXT12="temps "$'\xc3\xa9'"coul"$'\xc3\xa9'""
DIALOG=
PARSEID="# options d'analyse"
OPTIONS="--options"
COMMENT0="Paquet:"
COMMENT1="R"$'\xc3\xa9'"pertoires"
COMMENT2="Fichiers"
COMMENT3="dossiers"
COMMENT4="fichiers"
COMMENT5="trouv"$'\xc3\xa9'"s"
COMMENT6="install"$'\xc3\xa9'"s"
COMMENT7="et"
COMMENT8="dont"
COMMENT9="total"
COMMENT10="taille"
LV_COMPRESS="compression-level=22"
COMPRESS_AS=($OPTIONS=$LV_COMPRESS)
DTBFILE0="$PKGDIR/database/$LOGFILE"
DTBFILE1="$PKGDIR/database/$PKG_DTB"
# ce-ci supprime les erreurs produisent par certaines 
# commandes si vous executez le script en '../sspm'
SCRIPTFILE="$(realpath -q $0)"
SCRIPTFILE="${SCRIPTFILE:-$0}"








sspm_version() {
if [[ "$RANDOM" =~ $"6" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%2s*********************\n%2s*%19s*\t\tCe programme est un logiciel libre:\n\
%2s*%6s\e[94mS%1sS%1sP%1sM\e[0m%6s*\t\tvous pouvez le redistribuer ou le modifier\n\
%2s*%19s*\t\tsous les termes de la GNU General Public License\n%2s*********************\
\t\ttelle que publi"$e_acute"e par la Free Software Foundation;\n%32ssoit la\
%1sversion 3 de la licence, soit\n%32s($a_grave votre choix) toute version\
%1sult"$e_acute"rieure.\n"
elif [[ "$RANDOM" =~ ^"5" || "$RANDOM" =~ ^[1_1_]+$ ]]; then
printf "%13ssspm  v$SSPM_VER\n\
%6s\e[1mS\e[0m%6sCopyright (C) 2021-2022 Free Software Foundation, Inc.\n\
%6s\e[1mS\e[0m%6sLicense GPLv3+: GNU GPL version 3 ou ult"$e_acute"rieure\n\
%6s\e[1mP\e[0m\n\
%6s\e[1mM\e[0m%6sCe programme est un logiciel libre: libre a modifier ou a redistribuer\n\
%13ssous les termes de la GNU General Public License\n\
%13sIl n'y a AUCUNE GARANTIE, dans la mesure permise par la loi.\n\n"
elif [[ "$RANDOM" =~ $"7" || "$RANDOM" =~ ^[6_2_]+$ ]]; then
printf "%21sOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\n\
%21sO%2sCopyright (C) 2021 Free Software Foundation, Inc.%13sO\n%21sO%2sLicense GPLv3+: GNU GPL version 3 ou ult"$e_acute"rieure%15sO\
\n%21sO%64sO\n%21sO%2ssspm  v$SSPM_VER%50sO\n%21sO%2ssous les termes de la GNU General Public License%14sO\n%21sO%2slibre "$a_grave" vous de\
%1smodifier ou de redistribuer ce programme%6sO\n%21sO%2sIl n'y a AUCUNE GARANTIE, dans la mesure permise par la loi.%2sO\n%21sO%64sO\n\
%21sO%2sEditeur  Joe Packar.%42sO\n%21sOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO\v\n"
elif [[ "$RANDOM" == *3*5 ]]; then
printf "sspm v$SSPM_VER\n"
elif [[ "$RANDOM" =~ ^"3" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s\e[90m-------------------\e[0m\n%2s\e[90m|\e[0m%19s\e[90m|\e[0m\t\tCe programme est un logiciel libre;\n\
%2s\e[90m|\e[0m%6s\e[1m\e[90mS%1sS\e[0m%1s\e[1mP%1sM\e[0m%6s\e[90m|\e[0m\t\tvous pouvez le redistribuer ou le modifier\n\
%2s\e[90m|%19s|\e[0m\t\tsous les termes de la GNU General Public License\e[90m\n%3s-------------------\e[0m\
\t\ttelle que publi"$e_acute"e par la Free Software Foundation;\n%32ssoit la\
%1sversion 3 de la licence, soit\n%32s($a_grave votre choix) toute version\
%1sult"$e_acute"rieure.\n"
elif [[ "$RANDOM" == *0*0* ]]; then
printf "%csspm  v$SSPM_VER\nCopyright (C) 2021-2022 Free Software Foundation, Inc.\n\
License GPLv3+ : GNU GPL version 3 ou ult"$e_acute"rieure\nCe programme est un logiciel\
%1slibre: redistribuer ou modifier le\nmais SANS AUCUNE GARANTIE; sans m"$e_circumflex"me\
%1sla garantie implicite\nde QUALITE MARCHANDE ou ADAPTATION A UN USAGE PARTICULIER\n\
Voir la licence publique g"$e_acute"n"$e_acute"rale GNU pour plus de details.\v\nEcrit par Joe Packar.\n"
elif [[ "$RANDOM" == 2*8 ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021 Joe Packar\n\
%3s\e[91m-------------------\e[0m\n%2s\e[91m|\e[0m%19s\e[91m|\e[0m\t\tCe programme est un logiciel libre;\n\
%2s\e[91m|\e[0m%6s\e[94mS%1sS%1sP%1sM\e[0m%6s\e[91m|\e[0m\t\tvous pouvez le redistribuer ou le modifier\n\
%2s\e[91m|\e[0m%19s\e[91m|\e[0m\t\tsous les termes de la GNU General Public License\n%3s-------------------\
\t\ttelle que publi"$e_acute"e par la Free Software Foundation;\n%32ssoit la\
%1sversion 3 de la licence, soit\n%32s($a_grave votre choix) toute version\
%1sult"$e_acute"rieure.\n"
elif [[ "$RANDOM" == *7*4* ]]; then
printf "sspm est en v$SSPM_VER\n"
elif [[ "$RANDOM" == 1*9 ]]; then
printf "%13ssspm  v$SSPM_VER\n\
%6s\e[1m\e[35mS\e[0m%6sCopyright (C) 2021 Free Software Foundation, Inc.\n\
%6s\e[1m\e[35mS\e[0m%6sLicense GPLv3+: GNU GPL version 3 ou ult"$e_acute"rieure\n\
%6s\e[1m\e[35mP\e[0m\n\
%6s\e[1m\e[35mM\e[0m%6sCe programme est un logiciel libre: libre a modifier ou a redistribuer\n\
%13ssous les termes de la GNU General Public License\n\
%13sIl n'y a AUCUNE GARANTIE, dans la mesure permise par la loi.\n\n"
elif [[ "$RANDOM" =~ ^"2" ]]; then
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s-------------------\n%2s|%19s|\t\tCe programme est un logiciel libre;\n\
%2s|%6s\e[94mS%1sS%1sP%1sM\e[0m%6s|\t\tvous pouvez le redistribuer ou le modifier\n\
%2s|%19s|\t\tsous les termes de la GNU General Public License\n%3s-------------------\
\t\ttelle que publi"$e_acute"e par la Free Software Foundation;\n%32ssoit la\
%1sversion 3 de la licence, soit\n%32s($a_grave votre choix) toute version\
%1sult"$e_acute"rieure.\n"
elif [[ -z "$RANDOM" || ! -e "$RANDOM" ]]; then
printf "%csspm  v$SSPM_VER\nCopyright (C) 2021-2022 Free Software Foundation, Inc.\n\
License GPLv3+ : GNU GPL version 3 ou ult"$e_acute"rieure\nCe programme est un logiciel\
%1slibre: redistribuer ou modifier le\nmais SANS AUCUNE GARANTIE; sans m"$e_circumflex"me\
%1sla garantie implicite\nde QUALITE MARCHANDE ou ADAPTATION A UN USAGE PARTICULIER\n\
Voir la licence publique g"$e_acute"n"$e_acute"rale GNU pour plus de details.\v\nEcrit par Joe Packar.\n"
else
printf "%c\t\t\t\tsspm  v$SSPM_VER\n\t\t\t\tCopyright (C) 2021-2022 Joe Packar\n\
%3s\e[90m-------------------\e[0m\n%2s\e[90m|\e[0m%19s\e[90m|\e[0m\t\tCe programme est un logiciel libre;\n\
%2s\e[90m|\e[0m%6s\e[1mS%1sS%1s\e[90mP%1sM\e[0m%6s\e[90m|\e[0m\t\tvous pouvez le redistribuer ou le modifier\n\
%2s\e[90m|%19s|\e[0m\t\tsous les termes de la GNU General Public License\e[90m\n%3s-------------------\e[0m\
\t\ttelle que publi"$e_acute"e par la Free Software Foundation;\n%32ssoit la\
%1sversion 3 de la licence, soit\n%32s($a_grave votre choix) toute version\
%1sult"$e_acute"rieure.\n"
fi
}




usage() {
cat <<EOF
sspm $SSPM_VER
Compiler un paquet $(printf '\xc3\xa0') partir de z$(printf '\xc3\xa9')ro

Usage: sspm [options] <nom|paquet|dossier>

Options:
 -b, --build           Cr$(printf '\xc3\xa9')er       le paquet
 -i, --install         Installer   le paquet
 -R, --remove          D$(printf '\xc3\xa9')sinstaller le paquet
 -d, --debug           Mode d$(printf '\xc3\xa9')bogage
 -o, --destdir         Stocker le paquet dans ...
 -s, --source          R$(printf '\xc3\xa9')cup$(printf '\xc3\xa9')rer toutes les sources [x]
 -p, --path            Historique d'installation du paquet
 -pi, -ip              Informations du paquet
 -bi, -ib              Compiler et installer le paquet
 -l, --list            Lister tout les paquets install$(printf '\xc3\xa9')s
 -h, --help            Afficher cette aide et quitter
 -v, --version         Afficher la version et quitter
     --depends         Afficher les dependances install$(printf '\xc3\xa9')es
     infos             Afficher la page de manuel
     
     exportez la variable 'LV_BUILD=[on/y/yes]'
     puis tapez 'sspm -b' pour lancer le mode int$(printf '\xc3\xa9')ractif
     
     export PKG_GROUP=group
     d$(printf '\xc3\xa9')finir les prochains paquets comme paquets de type 'group'
     voir la section variable d'environnement PKG_GROUP
     pour les valeurs de groupes possible.
   

EOF
exit
}










sspm_infos() {
sspm_man_infos() {
clear
printf "SSPM(1)\n\n\
NOM\n\
     sspm - gestionnaire de paquets\n\n\
SYNOPSIS\n\
       sspm [\e[4mOPTION\e[0m]... [\e[4mNOM|PAQUET|DOSSIER\e[0m]... [\e[4mOPTION\e[0m]...\n\n\
DESCRIPTION\n\
       compiler "$a_grave" partir des sources, installer, lister ou d"$e_acute"sinstaller des paquets.\n\n\
       -b, --build\n\
            Cr"$e_acute"er le paquet\n\
            si cette option est indiqu"$e_acute"e seule et que la variable 'LV_BUILD' a "$e_acute"t"$e_acute" export"$e_acute"e,
            cela lancera automatique le mode interactif. voir la section variables d'environnement\n\n\
       -i, --install\n\
            Installer le paquet\n\n\
       -R, --remove\n\
            D"$e_acute"sinstaller le paquet\n\n\
       -d, --debug\n\
            Mode d"$e_acute"bogage\n\n\
       -s, --source\n\
            R"$e_acute"cup"$e_acute"rer toutes les sources [x] (en d"$e_acute"veloppement)\n\n\
       -o, --destdir=\e[4mPATH\e[0m\n\
            Le r"$e_acute"pertoire o"$u_grave" le paquet sera stock"$e_acute". par d"$e_acute"faut le paquet est stock"$e_acute" dans le r"$e_acute"pertoire de travail\n\
            peut "$e_circumflex"tre aussi utilis"$e_acute"e avec '-pe'\n\n\
       -r, --root=\e[4mPATH\e[0m\n\
            Destination\n\n\
       -p, --path\n\
            Afficher l'istorique d'installation d'un paquet\n\n\
       -pi, --print-infos\n\
            Afficher les informations du paquet\n\n\
       -bi,\n\
            Installer automatiquement le paquet apr"$e_grave"s sa compilation\n\n\
       -l, --list\n\
            Lister tout les paquets install"$e_acute"s\n\
           --list --root=/mnt/nouveau_root\n\
            Lister tout les paquets install"$e_acute"s dans '/mnt/nouveau_root'\n\n\
       -rtf, --remnant-files\n\
            Effacer les fichiers (de compilation ou d'installation) temporaires restants\n\
            si vous avez auparavant arr"$e_circumflex"ter l'un de ces processus.\n\n\
       -eh,-wh   --enable-hash, --with-hash\n\
            G"$e_acute"n"$e_acute"rer une somme de contr"$o_circumflex"le\n\n\
       -q, --quiet\n\
            Ne pas afficher le message de fin apr"$e_grave"s la cr"$e_acute"ation d'un paquet\n\n\
       -qq, --quiet-all\n\
            Rendre la compilation silensieuse, et n'afficher que le dialogue d'installation\n\
            si l'option '-i' est indiqu"$e_acute"e\n\n\
       -aq, --always-quit\n\
            Activer ou D"$e_acute"sactiver le message de succ"$e_grave"s apr"$e_grave"s la cr"$e_acute"ation d'un paquet\n\
            Pareil que l'option '-q' de mani"$e_grave"re permanente\n\n\
       -pe, -ep, --pkgbuild-example\n\
            G"$e_acute"n"$e_acute"rer un exemple du fichier '$BUILDFILE'\n\n\
       -h, --help\n\
            Afficher une courte description\n\n\
       -v, --version\n\
            Afficher la version\n\n\
           --depends\n\
            Afficher les dependances install"$e_acute"es d'un paquet, 'sspm --depends' simple sans un nom de paquet\n\
            vous retournera ses propres d"$e_acute"pendances install"$e_acute"es dans le syst"$e_grave"me\n\n\
           info/infos\n\
             Afficher cette page\n\n\
       Exemples:\n\
         * sspm -b (avec le fichier 'pkgbuild' dans le dossier courant)\n\
         * sspm -i foo.tar.zst (installer foo)\n\
         * sspm -i foo.tar.zst --root /quelquepart (installer foo dans 'quelquepart')\n\
         * sspm -bi (compiler et installer le paquet)\n\
         * sspm --path foo (afficher l'istorique d'installation de foo)\n\
         * sspm --root=/mnt/nouveau_root -p foo (afficher l'istorique d'installation de foo install"$e_acute" dans /mnt/nouveau_root)\n\
         * sspm -i -r /mnt/nouveau_root -b --with-hash (compiler, g"$e_acute"n"$e_acute"rer une somme de contr"$o_circumflex"le et installer le paquet dans /mnt/nouveau_root)\n\
         * sspm -bi --root /mnt/nouveau_root --destdir=\$HOME/pkg_archives -wh (compiler le paquet, g"$e_acute"n"$e_acute"rer une somme de contr"$o_circumflex"le(sha256sum)\n%17spuis stocker les fichiers dans '\$HOME/pkg_archives' et enfin installer le paquet dans /mnt/nouveau_root)\n\
         * sspm infos (Afficher la page de manuel)\v\n\
       
\e[1mENVIRONNEMENT\e[0m\n\
%7ssi vous utilis"$e_acute"s la commande 'sudo' vous aurez peut-"$e_circumflex"tre besoin de l'option '-E' (preserve existing environment variables)\n\n\
%7s*%1sSRC\n%10sr"$e_acute"pertoire contenant le ou les fichiers sources (ex: export SRC=~/tout_les_fichiers_sources) \n\n\
%7s*%1sPKG_SRC\n%11schemin d'acc"$e_grave"s direct au fichier source, d"$e_acute"finissez cette variable\n\
%11ssi sspm ne parvient pas $a_grave d"$e_acute"terminer l'archive avec les informations saisies dans le fichier '$BUILDFILE'\n\n\
%7s*%1sPM_CONFDIR\n%11sr"$e_acute""$e_acute"crire la valeur par d"$e_acute"faut du r"$e_acute"pertoire de configuration de sspm\n\
%11spar d"$e_acute"faut le r"$e_acute"pertoire de configuration est '~/.config/sspm'\n%11svous avez pas besoin de red"$e_acute"finir cette variable "$a_grave" la prochaine session.\n\n\
%7s*%1sPATH\n%11svous "$e_circumflex"tes au stade du chroot (c'est-"$a_grave"-dire vous venez de chrooter dans vos outils temporaires).\n\
%11s'sspm' a besoin de ces paquets: 'bsdtar (libarchive), zstd, coreutils, e2fsprogs, which, tar\n\
%11spkg-config, grep, sed, xz, gawk, Procps' dans ce environnement pour fonctionner.\n\
%11squi eux m"$e_circumflex"me doivent "$e_circumflex"tre install"$e_acute"s par 'sspm' dans un ordre d"$e_acute"fini par vous ou votre livre linux.\n\
%11spour ne pas d"$e_acute"stabiliser vous outils ou corrompre certaines biblioth"$e_grave"ques\n\n\
%11scr"$e_acute"ez un r"$e_acute"pertoire temporaire puis installez manuellement les paquets list"$e_acute"s ci-dessus\n\
%11s(uniquement ceux qui ne sont pas encore disponible dans votre environnement) dans ce r"$e_acute"pertoire.\n\
%11spour que cela fonctionne il faut installer ces paquets avec peu de configurations\n\n\
%11s(ex: ./configure --disable-XXXXX --without-YYYYY && make && make DESTDIR=/repertoire/tmp_outils install)\n\
%11sApr"$e_grave"s avoir r"$e_acute"ussi d'installer ces paquets, d"$e_acute"finissez la variable 'PATH' temporairement pour que \n%11sces paquets et leurs biblioth"$e_grave"ques soient visible. Ces paquets temporaires seront suprim"$e_acute"s\n%11sune fois qu'ils seront cr"$e_acute$e_acute"s \
et install"$e_acute"s d"$e_acute"ffinitivement \n\
%11s(selon l'ordre d"$e_acute"fini par votre manuel, livre linux ou autre, etc ... ).\n\n\
%11s\e[4mexemple\e[0m:\n\
%11scat > ~/.bashrc <<EOF\n\
%11s\e[90mexport PATH=\$PATH:/tools/sspm_tools/bin:/tools/sspm_tools/usr/bin\n%11sexport SRC=/sources\e[0m\n%11sEOF\n\n\
%7s*%1sEXCLUDE/IGNORE ou NOT_TRACE_PATH\n%11svous avez besoin de cette variable seulement si vous manipul"$e_acute"s \
les donn"$e_acute"es d'un autre syst"$e_grave"me\n%11sc'est-"$a_grave"-dire que vous install"$e_acute"s ou d"$e_acute"sinstall"$e_acute"s un paquet dans votre syst"$e_grave"me d'exploitation\n\
%11sen m"$e_circumflex"me temps vous avez 'un disk mont"$e_acute", un r"$e_acute"pertoire' qui contient un autre syst"$e_grave"me, une toolchain\n\
%11salors vous devez imp"$e_acute"rativement export"$e_acute" cette variable\n%11s\e[90m(ex: root:# export NOT_TRACE_PATH=/mnt/buildroot) ou dans \
le fichier ~/.bashrc\e[0m\n%11sau risque de voir les biblioth"$e_grave"ques de l'un se li"$e_acute"es "$a_grave" l'autre. ce que vous ne voulez pas\v\n\
%11spourquoi ainsi ? :  parce que "$a_grave" chaque installation ou d"$e_acute"sinstallation d'un paquet\n%11ssspm cherche les liens symboliques \
cass"$e_acute"s dans le syst"$e_grave"me or les liens symboliques\n%11sde votre 'toolchain' par exemple appara"$i_circumflex"tront comme rompu, il va alors tenter de les restaur"$e_acute"s\n%11sen les liant aux biblioth"$e_grave"ques de votre syst"$e_grave"me et donc rendre votre syst"$e_grave"me inutilisable\v\n\
%7s*%1sPKG_GROUP=group\n%11s(cette variable ne prend effet que si la variable 'groups' est vide dans le fichier 'pkgbuild')\n\
%11sd"$e_acute"finir tout les prochains paquets entant que paquets de type 'group'\n\
%11sles valeurs possible: base ; add ; opt ; other. si cette variable n'est pas d"$e_acute"finie, le groupe sera 'other'\n%11sNB: ici 'opt' ne signifie pas que le paquet sera install"$e_acute" dans '/opt' mais plut"$o_circumflex"t sera d"$e_acute"fini entant que paquet optionnel\v\n\
%7s*%1sPACKAGER=name\n%11s(cette variable ne prend effet que si la variable 'packager' est vide dans le fichier 'pkgbuild')\n%11sd"$e_acute"finir tout les prochains paquets comme "$e_acute"tant cr"$e_acute""$e_acute" par 'name'\v\n\
%7s*%1sLV_BUILD=[on/y/yes]\n%11scompiler, cr"$e_acute"er un paquet voire l'installer de mani"$e_grave"re interactive plut"$o_circumflex"t que d'utiliser le fichier '$BUILDFILE'\v\v\n\
\e[1mINITIALISATION DU FICHIER:\e[0m '$BUILDFILE' \n\
voici un exemple de configuration de ce fichier\n\
cat $BUILDFILE\n\n\e[90m\
pkgname=foo\n\
pkgver=2.3\n\
pkgrev=1\n\
pkgdesc="'"'"Le paquet foo etc... ."'"'"\n\
url="'"'"https://www.source-foo.org/release/"'"'"\n\
groups=base\n\
depends=(xxx yyy)\n\
makedepend=()\n\
packager="'"'"name"'"'"\n\
tfext=tar.gz\n\n\n\n\
build() {\n\
./configure --prefix=/usr              \\\ \n\
            --with-XXX-YYY             \\\ \n\
            --disable-XXX-ZZZ          \\\ \n\
            --docdir=/dossier/dossier\n\n\
make\n\
make check\n\
make DESTDIR="'$'"pkgdir install\n\
}\e[0m\n\n\
astuce:%3sle nom de la fonction n'a aucune importance build_foo() { commands }, foo() { commands },\n\
%9s foo_build() { commands } ou tout simplement build() { commands } marchera.\v\n\
remarque: si la variable 'tfext' dans le fichier (pkgbuild) est vide,\n\
%9s sspm tentera de d"$e_acute"tecter automatiquement l'extension du fichier source.\n\
%9s si vous appliquez un patch et que vous avez une erreur de type:\n\
\t\t\t**** can't find file to patch at input line 23 ****\n\
%9s faitent un 'cd r"$e_acute"pertoire_d_extraction_exacte' avant la commande 'patch' dans le fichier (pkgbuild)\n\n\

\e[1mSTATUT DE SORTIE:\e[0m\n\
        0        si OK,\n\
        1        si erreur, etc ...\n\
	la plupart du temps vous aurez un message expliquant +/- la raison de l'erreur, enfin presque\v\n\
\e[1mAUTEUR\e[0m\n\
      Ecrit par Joe Packar.\n\
      rapporter les bugs "$a_grave" https://github.com/jpsspm/sspm/issues/.\n\
      Pour plus d'informations, consultez la page d'accueil de sspm\n\
      "$a_grave" l'adresse suivante: https://jpsspm.github.io/sspm/.\n\n\
\e[1mDROITS D'AUTEUR\e[0m\n\
            Copyright \xc2\xa9 2021-2022 Free Software Foundation, Inc.\n\
            License GPLv3+: GNU GPL version 3 ou ult"$e_acute"rieure <https://gnu.org/licenses/gpl.html>.\n\
            Ce programme est un logiciel libre: vous pouvez le redistribuer ou le modifier.\n\
            Il n'y a AUCUNE GARANTIE, dans la mesure permise par la loi.\v\v\n
sspm $SSPM_VER%66sJanvier 2022%66sSSPM(1)   \n"
}






sspm_err_infos() {
clear
printf "\e[93mNB:\e[0m il ya (3) variables tr"$e_grave"s importantes\v\n\
%7s*%1sSRC\n%10sr"$e_acute"pertoire contenant le ou les fichiers sources (ex: export SRC=~/tout_les_fichiers_sources) \n\n\
%7s*%1sPATH\n%11svous "$e_circumflex"tes au stade du chroot (c'est-"$a_grave"-dire vous venez de chrooter dans vos outils temporaires).\n\
%11s'sspm' a besoin de ces paquets: 'bsdtar (libarchive), zstd, coreutils, e2fsprogs, which, tar\n\
%11spkg-config, grep, sed, xz, gawk, Procps' dans ce environnement pour fonctionner.\n\
%11squi eux m"$e_circumflex"me doivent "$e_circumflex"tre install"$e_acute"s par 'sspm' dans un ordre d"$e_acute"fini par vous ou votre livre linux.\n\
%11spour ne pas d"$e_acute"stabiliser vous outils ou corrompre certaines biblioth"$e_grave"ques;\n\n\
%11scr"$e_acute"ez un r"$e_acute"pertoire temporaire puis installez manuellement les paquets list"$e_acute"s ci-dessus\n\
%11s(uniquement ceux qui ne sont pas encore disponible dans votre environnement) dans ce r"$e_acute"pertoire.\n\
%11spour que cela fonctionne il faut installer ces paquets avec peu de configurations\n\n\
%11s(ex: ./configure --disable-XXXXX --without-YYYYY && make && make DESTDIR=/repertoire/tmp_outils install)\n\
%11sApr"$e_grave"s avoir r"$e_acute"ussi d'installer ces paquets, d"$e_acute"finissez la variable 'PATH' temporairement pour que \n%11sces paquets et leurs biblioth"$e_grave"ques soient visible. Ces paquets temporaires seront suprim"$e_acute"s\n%11sune fois qu'ils seront cr"$e_acute$e_acute"s \
et install"$e_acute"s d"$e_acute"ffinitivement \n\
%11s(selon l'ordre d"$e_acute"fini par votre manuel, livre linux ou autre, etc ... ).\n\n%11svoici "$a_grave" quoi va ressembler cette variable:\n\
%11scat > ~/.bashrc <<EOF\n\
%11s\e[90mexport PATH=\$PATH:/tools/sspm_tools/bin:/tools/sspm_tools/usr/bin\n%11sexport SRC=/sources\e[0m\n%11sEOF\n\n\
%7s*%1sEXCLUDE/IGNORE ou NOT_TRACE_PATH\n%11svous avez besoin de cette variable seulement si vous manipul"$e_acute"s \
les donn"$e_acute"es d'un autre syst"$e_grave"me\n%11sc'est-"$a_grave"-dire que vous install"$e_acute"s ou d"$e_acute"sinstall"$e_acute"s un paquet dans votre syst"$e_grave"me d'exploitation\n\
%11sen m"$e_circumflex"me temps vous avez 'un disk mont"$e_acute", un r"$e_acute"pertoire' qui contient un autre syst"$e_grave"me, une toolchain\n\
%11salors vous devez imp"$e_acute"rativement export"$e_acute" cette variable\n%11s\e[90m(ex: root:# export NOT_TRACE_PATH=/mnt/buildroot) ou dans \
le fichier ~/.bashrc\e[0m\n%11sau risque de voir les biblioth"$e_grave"ques de l'un se li"$e_acute"es "$a_grave" l'autre. ce que vous ne voulez pas\v\n\
%11spourquoi ainsi ? :  parce que "$a_grave" chaque installation ou d"$e_acute"sinstallation d'un paquet\n%11ssspm cherche les liens symboliques \
cass"$e_acute"s dans le syst"$e_grave"me or les liens symboliques\n%11sde votre 'toolchain' par exemple appara"$i_circumflex"tront comme rompu, il va alors tenter de les restaur"$e_acute"s\n%11sen les liant aux biblioth"$e_grave"ques de votre syst"$e_grave"me et donc rendre votre syst"$e_grave"me inutilisable\v\v\n"

}



case "$1" in
      "err" )  sspm_err_infos ;;
      '' )   sspm_man_infos ;;
      *)    exit $ERCODE ;;
esac


}





                                   if [[ -n $PRINT_INFOS && $PRINT_INFOS == "YES" ]]; then
                                       sspm_infos err
                                      printf '\n'
                                    printf '\n'
                                  printf '\n'
                                printf "\e[91m==> ERREUR: \e[0mCertaines d"$e_acute"pendances manquent\n"
                               printf "\e[90massurez vous qu'au minimum ces paquets sont install"$e_acute"s:\e[0m\n"
                               printf "\e[90mwhich, tar, gawk, grep, pkg-config, find, sed, xz, zstd, libarchive, coreutils, Procps, e2fsprogs\e[0m\n"
                               printf '\n'
                               printf '\n'
                               exit $DEPEND_ERCODE
                               fi










                                                                   # ces repertoires sont utilises comme reference pour indiquer
                                                                   # au script les repertoires de base, n'hesitez pas a
                                                                   # mettre a jour cette liste selon vos optimisations
                                                                          sysdirs=(bin boot color cache dev doc etc lib \
                                                                          lib64 firmware locale home opt srv sbin usr \
                                                                          include local locate sysconfig media floppy \
                                                                          cdrom info log mail opt pkgconfig proc spool \
                                                                          man man1 man2 man3 man4 man5 man6 man7 man8 \
                                                                          share sys dict misc mnt run root var lock tmp \
                                                                          terminfo zoneinfo)


####################################################################################################################################################################################################
############ but du bloc de code:                                                                                                                                                                  #
############ * si vous executez ce script en tant qu'utilisateur 'root' ou avec les privileges 'root' pas grand chose ne sera fait ici                                                             #
############ * si vous executez ce script en tant qu'utilisateur 'non-root' le script tentera d'accerder au repertoire de configuration par defaut                                                 #
############   qui est '~/.config/nom_du_script' sauf si vous indiquez un autre repertoire dans 'PM_CONFDIR'                                                                                       #
############   dans les deux cas ce dernier sera cree s'il n'existe pas ( assurez vous d'avoir les droits d'ecriture necessaires dans l'arborescence que vous indiquez dans 'PM_CONFDIR' )         #
############ * puis un tube restreint a l'utilisateur sera cree pour des besoins de synchronisation ( au cas ou vous lancez plusieurs instances de ce script dans des terminaux differents )       #
############ * enfin si 'PM_CONFDIR' a ete definie sa valeur sera sauvegarder dans ce script                                                 voir apres ce bloc pour plus d'informations           #
####################################################################################################################################################################################################
#  si 'sudo' est installe et que vous utilises la commande avec des options ou une configuration particuliere vous devez ajuster ce bloc de codes ci-dessous pour qu'il correspond a vous besoins  #
####################################################################################################################################################################################################
                                                                                                                                                                                                   #
                                                                                                                                                                                                   #
                                                                                                                                                                                                   #
                if [[ "${EUID:-$(id -u)}" -eq 0 ]]; then                                                                                                                                           #
                [[ ! -p "$PIPE" ]] && mkfifo -m 660 "$PIPE"                                                                                                                                        #
                else                                                                                                                                                                               #
                if [[ -z "$PERM_PM_CONFDIR" || (( -n "$PM_CONFDIR" && ! "$PM_CONFDIR" =~ "$PERM_PM_CONFDIR" )) ]]; then                                                                            # 
                if [[ -n "$PM_CONFDIR" ]]; then                                                                                                                                                    #
                if [[ ! -d "$PM_CONFDIR" ]]; then                                                                                                                                                  #
                printf "===> '$PM_CONFDIR' non trouv"$e_acute"\ncr"$e_acute"ation du r"$e_acute"pertoire de configuration\n\n"                                                                     #
                mkdir -p "$PM_CONFDIR"                                                                                                                                                             #
                fi                                                                                                                                                                                 #
                if [[ $? -ne 0 ]]; then                                                                                                                                                            #
                printf "assurez-vous d'avoir les droits d'"$e_acute"criture appropri"$e_acute"s sur les r"$e_acute"pertoires parents\n"                                                            #
                printf "ou d"$e_acute"initialisez cette variable afin d'utiliser le r"$e_acute"pertoire par d"$e_acute"faut '~/.config/$(basename $SCRIPTFILE)'\n\n"                               #
                printf "\e[91merreur :\e[0m  avort"$e_acute"\n"                                                                                                                                    #
                exit $ERCODE                                                                                                                                                                       #
                else                                                                                                                                                                               #
                CHECK_VAR=Y                                                                                                                                                                        #
                fi                                                                                                                                                                                 #
                [[ "$PM_CONFDIR" =~ /$ ]] && PM_CONFDIR="${PM_CONFDIR%?}"                                                                                                                          #
                PIPE="$PM_CONFDIR/ilpc"                                                                                                                                                            #
                else                                                                                                                                                                               #
                DEFAULT_USER_CFG_DIR="$HOME/.config/$(basename $SCRIPTFILE)"                                                                                                                       #
                [[ -d $DEFAULT_USER_CFG_DIR ]] || mkdir -p $DEFAULT_USER_CFG_DIR                                                                                                                   #
                PIPE="$DEFAULT_USER_CFG_DIR/ilpc"                                                                                                                                                  #
                fi                                                                                                                                                                                 #
                [[ ! -p "$PIPE" ]] && mkfifo -m 660 "$PIPE"                                                                                                                                        #
                else                                                                                                                                                                               #
                PIPE="$PERM_PM_CONFDIR/ilpc"                                                                                                                                                       #
                [[ -d "$PERM_PM_CONFDIR" ]] || mkdir -p $PERM_PM_CONFDIR                                                                                                                           #
                [[ -p "$PIPE" ]] || mkfifo -m 660 "$PIPE"                                                                                                                                          #
                fi                                                                                                                                                                                 #
                fi                                                                                                                                                                                 #
                                                                                                                                                                                                   #            
                # NB: pour 'root' le foyer est '/dev'                                                                                                                                              #
                #     pour 'les non-root' nous ne pouvons pas ecrire dans '/dev' on change de foyer c'est prevu, on se loge par defaut dans '~/.config/nom_du_script'                              #
                #     la suite ne s'executera que si vous decidez de changer le foyer par defaut 'd'un utilisateur non-root' par le billet de 'PM_CONFDIR'                                         #
                if [[ -n $CHECK_VAR && $CHECK_VAR = [yY] ]]; then                                                                                                                                  #
                                                                                                                                                                                                   #                
                # nous voulons executer une seule commande avec les privileges 'root'                                                                                                              #
                # pour donner du sens a la condition ( $EUID -qe 0 ) ci-dessus nous devons executer 'sudo' dans le script                                                                          #
                # car lancer tout le script avec 'un sudo sans options' vous donnes un EUID = 0 et donc la condition root est remplie                                                              #
                                                                                                                                                                                                   #                
                # l'astuce consiste: si le script est execute entant qu'utilisateur non-privilege                                                                                                  #
                # et que une configuration necessite les privileges 'root', on demande les privileges,                                                                                             #
                # on execute la commande puis on reinitialise le timestamp de la commande 'sudo' ( voir la page de manuel de sudo )                                                                #
                # pour continuer l'execution du script en tant qu'utilisateur non-privilege                                                                                                        #
                                                                                                                                                                                                   #                
                                                                                                                                                                                                   #      
                if grep -q ^"PERM_PM_CONFDIR=" $SCRIPTFILE; then                                                                                                                                   #
                    if [[ ! "$PM_CONFDIR" =~ ^"$PERM_PM_CONFDIR"$ ]]; then                                                                                                                         #
                      PM_CONFDIR="$(printf "$PM_CONFDIR" | sed 's/\//\\\//g')"                                                                                                                     #
                       if ( type -t sudo &>/dev/null ); then                                                                                                                                       #
                       printf "\n%2s*%1schangement du r"$e_acute"pertoire de configuration\n\n"                                                                                                    #
                       sudo -k sed -i '/^PERM_PM_CONFDIR=.*/s/PERM_PM_CONFDIR=.*/PERM_PM_CONFDIR="'$PM_CONFDIR'"/' "$SCRIPTFILE"                                                                   #
                       else                                                                                                                                                                        #
                       printf "\e[91merreur:\e[0m  'sudo' non trouv"$e_acute"\nlancez la commande en tant que root\n\n"                                                                            #
                       exit $ERCODE                                                                                                                                                                #
                      fi                                                                                                                                                                           #
                    fi                                                                                                                                                                             #
                else                                                                                                                                                                               #
                    if ( type -t sudo &>/dev/null ); then                                                                                                                                          #
                      printf "\n%2s*%1schangement du r"$e_acute"pertoire de configuration\n\n"                                                                                                     #
                       PM_CONFDIR="$(printf "$PM_CONFDIR" | sed 's/\//\\\//g')"                                                                                                                    #
                       sudo -k sed -i "/^DTBFILE1=/aPERM_PM_CONFDIR=\"$PM_CONFDIR\"" $SCRIPTFILE                                                                                                   #
                       else                                                                                                                                                                        #
                       printf "\e[91merreur:\e[0m  'sudo' non trouv"$e_acute"\nlancez la commande en tant que root\n\n"                                                                            #
                      exit $ERCODE                                                                                                                                                                 #
                    fi                                                                                                                                                                             #
                fi                                                                                                                                                                                 #
                  if [[ $? -ne 0 ]]; then                                                                                                                                                          #
                   printf "\nvous avez besoin des privil"$e_grave"ges 'root' pour d"$e_acute"finir la valeur\nde 'PM_CONFDIR' comme r"$e_acute"pertoire de configuration par d"$e_acute"faut\n\n"  #
                   printf "%2s*%1srelancer votre commande avec 'sudo'\n%2s*%1sou d"$e_acute"sinitialisez 'PM_CONFDIR' pour utiliser le r"$e_acute"pertoire par d"$e_acute"faut\n\n"                #
                   printf "\e[91merreur :\e[0m  avort"$e_acute"\n"                                                                                                                                 #
                   exit $ERCODE                                                                                                                                                                    #
                  fi                                                                                                                                                                               #
                fi                                                                                                                                                                                 #
                                                                                                                                                                                                   #  
####################################################################################################################################################################################################                

                                           # on suspend un message dans le canal (tube) ipc '$PIPE'
                                           # pendant l'execution d'un processus de type (installation, desinstallation ou compilation)
                                           # si un autre processus de ce type est lance depuis une autre instance de sspm alors:
                                           # echouer si ce dernier est une installation aussi ou creer les fichiers communs 
                                           # (notament le fichier temporaire '.BUILDFILE') de maniere incrementielle
                                           # si vous compilez plusieurs paquets simultanements
                                           # NB: a chaque installation ou desinstallation d'un ou des paquet(s),
                                           #     sspm manipule des fichiers de base de donnees, il est primordial que
                                           #     ces derniers ne se manipulent simultanement par deux instances du script sous pene de creer
                                           #     une confusion ou des erreurs de hashage d'ou le fameux controleur 'ipc_tool' fait maison.
                                           ipc_tool() 
                                           {
                                           local ERCODE=89
                                           local rep0='1'
                                           if [[ -n "$1" && "$#" = 1 ]]; then
                                             if [[ "$1" == "-c" || "$1" == "-C" ]]; then local option='1';
                                             elif [[ "$1" == "-l" || "$1" == "-L" ]]; then local option='2';
                                             elif [[ "$1" == "--break" || "$1" == "-s" ]]; then local option='0';
                                             else printf "param"$e_grave"tre non \e[91mreconnu\e[0m\n" && exit $ERCODE; fi
                                             else
                                             printf "param"$e_grave"tre non \e[91mreconnu\e[0m\n"; exit $ERCODE
                                           fi                                              
                                            if [[ "$option" = "0" ]]; then
                                            timeout 0.5s cat "$PIPE" &>/dev/null
                                            if [ ! $? = 0 ]; then
                                            printf "\e[91merreur: \e[0ml'interruption du signal ipc n'a pas r"$e_acute"ussi\n"
                                            exit $ERCODE
                                            fi
                                            fi
                                           if [[ "$option" == "1" ]]
                                           then
					      count() { printf "$(( $(printf $#) + 1 ))"; }
                                              export SUFIX="$(count $(ls -pa1 $TMP | sed -n '/\(.*'"$BUILDFILE"'*.\)/p' | tr '\n' ' '))"
                                              export TMPFILE=""$TMPFILE"$SUFIX"
                                           elif [[ "$option" == "2" ]]
                                           then
                                           local pid0="$(timeout --preserve-status 0.10s cat "$PIPE")"
                                           if [ -z "$pid0" ]; then
                                             printf "$$" > $PIPE &
                                           else
                                           if [ "$pid0" != "$$" ]; then
                                           if ps -fs --pid "$pid0" &>/dev/null; then
                                           case $RANDOM in
                                             *45*|1*2*8| *3*3)  printf "erreur: il semble que la base de donn"$e_acute"es est occup"$e_acute"e\n" ;;
                                             *9*1|*2*6| *7*4*)  printf "erreur: ne peut pas aboutir \e[90mbase de donn"$e_acute"es en cours d'utilisation\e[0m\n" ;;
                                             *7*0*|*2*0*|5*4*)  printf "erreur: base de donn"$e_acute"es en cours d'utilisation\n" ;;
                                              ''|*)             printf "erreur: impossible de verrouiller la base de donn"$e_acute"es\n" ;;
                                           esac
                                           printf "$pid0" > $PIPE &
                                           exit $ERCODE
                                           else
                                           printf "$$" > $PIPE &
                                           fi
                                           else
                                           printf "$$" > $PIPE &
                                           fi                            
                                           fi
                                           fi
                                         }
                                               






make_sum_check() {
local ERCODE=6
local TMPFILE=$(mktemp $TMP/msc.XXXXXX)
####################Options d'analyse
######################################################
if [[ -z "$1" ]]; then
printf "\e[93mavertissement: \e[0m'make sum check' a besoin d'arguments pour fonctionner.\n"
return $ERCODE
fi


if [ "$#" = "4" ] && [[ "$1" = "-c" || "$1" = "--check" ]] && [ -e "$2" ] && [[ "$3" = "-i" || "$3" = "--input" ]] && [ ! -z "$4" ]; then
local MODE=check
local TARGET="$2"
local INPUT="$4"
elif [ "$#" = "4" ] && [[ "$1" = "-g" || "$1" = "--gen" ]] && [ -e "$2" ] && [[ "$3" = "-o" || "$3" = "--output" ]] && [ ! -z "$4" ]; then
local MODE=gen
local TARGET="$2"
local OUTPUT="$4"
else
printf "\e[91m==> ERREUR:  \e[0mparam"$e_grave"tre(s) non reconnu.\n\
\e[90mex: make_sum_check -g quelque_chose -o redirig"$e_acute"_le_r"$e_acute"sultat_du_hachage_dans_ce_fichier\e[0m\n\
\e[90mex: make_sum_check -c v"$e_acute"rifie_quelque_chose -i dont_son_hash_se_trouve_dans_ce_fichier\e[0m\n\
\e[90mnote: v"$e_acute"rifier que vous "$e_circumflex"tes au bon endroit avant le check\e[0m\n"
exit 13
fi


###########  si la condition pour le mode "check" ou "gen" est rempli
########################################################################

if [[ -n "$MODE" && "$MODE" == "check" ]]; then
sha256sum --quiet -c "$INPUT" &>/dev/null
if [ "$?" != "0" ]; then
if [[ "$INPUT" == "$FILES_SHA" ]]; then
printf "\e[93mavertissement: \e[0mdes erreurs se sont produites lors de la v"$e_acute"rification de certains fichiers.\n\n"
read -p "souhaitez-vous poursuivre l'installation (o/n) : " REP
case $REP in [oO] | '')  printf '\n' ;; [nN] )  exit ;; *) exit ;; esac
fi
fi
elif [[ -n "$MODE" && "$MODE" == "gen" ]]; then
printf "#%13shash de "$pkgname-$pkgver" du '$BUILDDATE' g"$e_acute"n"$e_acute"r"$e_acute" par 'make sum check'\n\
#....................................................................................................\n" > "$TMPFILE";
find $TARGET -type f -exec sha256sum {} \; | tee >> "$TMPFILE" && cat $TMPFILE > $OUTPUT && rm -f $TMPFILE;
sleep 1; else printf "Sum check non abouti\n"; exit 12
fi
}









check_dtb() {
local ERCODE=143
local FNAME=".asosdtb"
if [[ -n "$2" ]]; then
if [[ "$2" =~ ^-[[:alpha:]]$ && (( "$2" = "-i" || "$2" = "-r" || "$2" = "-f" )) ]]; then
[[ "$2" == "-i" ]] && local processtype="l'installation"
[[ "$2" == "-r" ]] && local processtype="la d"$e_acute"sinstallation"
else printf "\e[91mparam"$e_grave"tre non reconnu\e[0m\n" && exit $ERCODE; fi
fi; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set +x
# sspm utilise deux simple fichiers comme base de donnees pour stocker les informations relatives aux paquets.
# normalement seul un acces root pourrait permettre la modification de ces fichiers; ici le hashage sert juste a
# verifier et a authentifier les dernieres informations stockees, afin de supprimer ou d'en stocker d'autres.
# des la premiere installation d'un paquet, la variable 'PKGDTB_DIGIT0' gardera en memoire la partie numerique
# de la somme des hashs de ces fichiers et sera matcher avant la prochaine installation ou desinstallation d'un paquet.
# et s'il y'a une erreur ou une quelconque alteration des fichiers, alors restaurer la derniere sauvegarde de la base de donnees.
# Note: si vous manipulez un autre systeme monte dans (le systeme principale ou l'environnement chroote) ou est installe sspm,
# toute cette routine de verification s'effectuera uniquement pour (le systeme principale ou l'environnement chroote)
# ou est installe sspm, mais pas sur le 'ROOT' distant. <<< vous pouvez consulter la page d'informations pour en savoir plus. >>>

local PKGDTB_DIGIT0=()



local PKGDTB_DIGIT1="$(sha256sum "$DTBFILE0" 2>/dev/null | tr -d -c '[[:digit:]]')"
local PKGDTB_DIGIT1+="$(sha256sum "$DTBFILE1" 2>/dev/null | tr -d -c '[[:digit:]]')"
local REFVARFORM="$(sed -n '/\(^local PKGDTB_DIGIT0=(.*)$\)/ {p;q}' < "$SCRIPTFILE")"
local REFVARVALUE="$(cut -d= -f2- <<< "$REFVARFORM" | tr -d -c '[[:digit:]]')"
local REFVARBYTES="$(wc -c <<< "$REFVARVALUE")"

if [[ -z "$1" ]]; then
   if [[ -z "${PKGDTB_DIGIT0:-$REFVARVALUE}" ]]; then
   local ISNOTATABLE="$(sed -n '/^local PKGDTB_DIGIT0=$/p' "$SCRIPTFILE")"
   [[ $ISNOTATABLE ]] && sed -i 's/^local PKGDTB_DIGIT0=/local PKGDTB_DIGIT0=()/' "$SCRIPTFILE"
   printf '\v\v\t\t\tBienvenue sur sspm!\v\v\n'
   else export FIRST_INIT=N
   fi
elif [[ -n "$1" && "$#" -le 2 && "$1" =~ ^-[[:alpha:]]$ ]]; then

         if [[ "$1" = "-g" ]]
           then
            if [[ (( -n "$2" && "$2" = "-f" )) || -z "$2" ]]; then
             if [[ $REFVARBYTES -gt 2 ]]; then            
              [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
              sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE" && sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
              [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
              [[ ! -d "$PKGDIR/database" ]] && mkdir -pv "$PKGDIR/database"
              find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
              chmod 600 $PKGDIR/database/$FNAME
              [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
             else
              [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
              [[ "$REFVARFORM" =~ \" || "$REFVARFORM" =~ \' ]] && sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE"
              sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
              [ $(stat -c "%a" "$SCRIPTFILE") != '755' ] && chmod 755 "$SCRIPTFILE"
              [[ ! -d "$PKGDIR/database" ]] && mkdir -pv "$PKGDIR/database"
              find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
              chmod 600 $PKGDIR/database/$FNAME
              [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
             fi         
            fi      
         elif [[ "$1" = "-c" && "$#" -eq 2 && -n "$processtype" ]]
            then
             [[ "$2" = '-r' ]] || printf 'lecture de la base de donn'$e_acute'es\n'
              if [[ "$PKGDTB_DIGIT1" != "$PKGDTB_DIGIT0" ]]; then
               printf 'une \e[91merreur\e[0m est survenue lors de synchronisation de la base de donn'$e_acute'es\n\n'
               printf "Voulez-vous :\n\n%4s(a)%4sr"$e_acute"parer et proc"$e_acute"der "$a_grave" ${processtype[@]}?\n"
               printf "%4s(i)%4signorer et proc"$e_acute"der "$a_grave" ${processtype[@]}?\n"
               printf "%4s(f)%4spariel que 'i' forcer ${processtype[@]}?\n"
               printf "%4s(r)%4srestaurer "$a_grave" la derni"$e_grave"re base de donn"$e_acute"es?\n"
               printf "%4s(s)%4ssortir?\n\n\n"
               read -p ":: " REP
               case $REP in
               [aA]) ;;
               [iI]) ;;
               [fF]) ;;
               [rR])
               [[ ! -f "$PKGDIR/database/$FNAME" ]] && printf "\e[91merreur fatale: \e[0mimpossible d'acceder "$a_grave" $PKGDIR/database/$FNAME\n" && exit $ERCODE
               sleep 0.24; printf "\e[94mrestauration de la base de donn"$e_acute"es...\e[0m\n"
               if [ -f "$DTBFILE1" ]; then [ ! -w "$DTBFILE1" ] && chattr -i "$DTBFILE1" && rm -f "$DTBFILE1" || rm -f "$DTBFILE1"; fi
               if [ -f "$DTBFILE0" ]; then [ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0 && rm -f $DTBFILE0 || rm -f $DTBFILE0; fi
               tar -xf "$PKGDIR/database/$FNAME" -C "$PKGDIR/database/" && chattr +i "$DTBFILE0" "$DTBFILE1"; sleep 0.30
               printf "\e[94mv"$e_acute"rification de la base de donn"$e_acute"es:\e[0m"
               local MATCH0="$(sed '/./!d' $DTBFILE1| tac | sed -n '2,2 p'|cut -d. -f1|tr -d '{}')"
               local MATCH1="$(grep -v '^$' $DTBFILE1|tail -n2|head -n1|cut -d. -f1|tr -d '{}')"
               local LASTPKG="$([[ "$MATCH0" = "$MATCH1" ]] && printf "$MATCH1")"
               if $DTBFILE0 "$LASTPKG"_pth &>/dev/null; then
               printf "%1sfait\n"
               if [[ $REFVARBYTES -gt 2 ]]; then
               [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
               sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE" && sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
               [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
               [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
               else
               [[ "$REFVARFORM" =~ \" || "$REFVARFORM" =~ \' ]] && sed -i -e 's/\(^local PKGDTB_DIGIT0=(\).*\()$\)/\1\2/' "$SCRIPTFILE"
               [ ! -w "$SCRIPTFILE" ] && chattr -i "$SCRIPTFILE" && local PERM0=ro
               sed -i -e '0,/\(^local PKGDTB_DIGIT0=(\)/s//\1"'$PKGDTB_DIGIT1'"/' "$SCRIPTFILE"
               [ $(stat -c "%a" "$SCRIPTFILE") != "755" ] && chmod 755 "$SCRIPTFILE"
               [[ -f "$PKGDIR/database/$FNAME" ]] && rm -f $PKGDIR/database/$FNAME
               find "$PKGDIR/database/" ! -name "$FNAME" -type f -execdir tar -cpf - {} + | zstd -9 - > $PKGDIR/database/$FNAME
               [[ -n "$PERM0" && "$PERM0" = "ro" ]] && chattr +i "$SCRIPTFILE"
               fi
               else
               printf "\n\e[91merreur fatale \e[0m une erreur est survenue\nlors de la v"$e_acute"rification de la base de donn"$e_acute"es\n" && exit $ERCODE
               fi ;; [sS] | '' | *) exit ;; esac
               fi
              fi
            
else
printf '\e[91msyntaxe\e[0m non reconnue\n'
return $ERCODE
fi; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
}











pkg_infos () {
# Afficher soit: tout les paquets installes, l'historique d'installation d'un paquet
# ou les informations d'un paquet
local GROUP0="base" GROUP1="add" GROUP2="opt" GROUP3="other"

if [[ $# -gt 1 ]]; then
 local PKG_NAME="$2"
else
    if [[ -n "$extra_0" ]]; then
  if [[ -d "$extra_0" ]]; then
  if [[ "$extra_0" =~ /$ ]]; then
  local DTBFILE1=""${extra_0%?}"$DTBFILE1"
  else local DTBFILE1=""$extra_0"$DTBFILE1"
  fi; else
  printf "%serreur:  impossible d'acceder au r"$e_acute"pertoire '$extra_0'\n"
  exit $ERCODE
  fi
    fi
fi


case $1 in  -l) LIST=y ;;  -p|-pi) PKGI=y ;;  *) exit $ERCODE ;; esac

if [[ $LIST = y ]]; then
   if [[ -f "$DTBFILE1" ]]; then
   printf "\n\t\e[100m\e[1mS\e[0m\e[100mimple \e[1mS\e[0m\e[100mcript \e[1mP\e[0m\e[100mackages \e[1mM\e[0m\e[100manager\e[0m\v\n"
   printf "\e[2mthis list is based on given $BUILDFILE file instructions\e[0m\v\n"
   printf "%3s\e[1mpaquets fondamentaux\e[0m\v\n"
   sed -n -e "/^{.*$GROUP0/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1mpaquets additionnels\e[0m\v\n"
   sed -n -e "/^{.*$GROUP1/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1mpaquets optionnels\e[0m\v\n"
   sed -n -e "/^{.*$GROUP2/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/'
   printf "\n%3s\e[1mautres paquets\e[0m\v\n"
   sed -n -e "/^{.*$GROUP3/p"  "$DTBFILE1"|sed 's/).{/ /'|cut -d ' ' -f1|sed 's/^[[:punct:]]/     \xE2\x80\xA2 /; s/}.{/ /; s/}.(/\-/; $s/$/\n/' 
   else  LINE="$(cat "$SCRIPTFILE"|grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0"|cut -d'=' -f2|tr -d '()'|tr -d '"'|tr -d "'")"
   if [ -z "$LINE" ]; then printf "aucun paquet install"$e_acute" avec $(basename $SCRIPTFILE)\n"; exit $ERCODE; else
   printf "\e[91m==> ERREUR:\e[0m impossible de lire la base de donn"$e_acute"es\n\e[90mverifiez si '$(dirname "$DTBFILE1")' existe\e[0m\n"
   exit $ERCODE; fi fi
   exit $OKCODE
fi




if [[ $PKGI = y ]]; then
local ERCODE=119
#######################  options d'analyse
###############################################################
if [[ -n $1 && -n $2 && $# = "2" ]]; then
if [ ! -d $PKGDIR ]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "aucun paquet install"$e_acute" avec sspm\n"; exit $ERCODE; fi
sleep 0.10
printf "une \e[91merreur \e[0mc'est produite lors de la lecture de certains fichiers\n\
\e[90messayez de voir si le r"$e_acute"pertoire: '$PKGDIR' existe\e[0m\n"; exit $ERCODE
elif [ ! -d "$PKGDIR/database" ]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "aucun paquet install"$e_acute" avec sspm\n"; exit $ERCODE; fi
sleep 0.10; printf 'Oops!\n'
printf "une \e[91merreur \e[0mc'est produite lors de la lecture de certains fichiers\n\
\e[90messayez de voir si le r"$e_acute"pertoire: '$PKGDIR/database' existe\e[0m\n"
exit $ERCODE
elif [[ ! (( -f "$DTBFILE0" || -f "$DTBFILE1" )) ]]; then
LINE="$(cat "$SCRIPTFILE" | grep -E "^PKGDTB_DIGIT0|^local PKGDTB_DIGIT0" \
| cut -d'=' -f2 | tr -d '()' | tr -d "\"'")"
if [ -z "$LINE" ]; then printf "aucun paquet install"$e_acute" avec sspm\n"; exit $ERCODE; fi
sleep 0.10
printf "\e[91m===> ERREUR: \e[0mimpossible de lire la base de donn"$e_acute"es\n\
\e[90mla synchronisation a "$e_acute"chou"$e_acute"e\e[0m\n"
exit $ERCODE
fi
elif [[ -n $1 && -n $2 && -n $3 && $# = "3" ]]; then
local PKGDIR="$3"$PKGDIR; local DTBFILE0="$3"$DTBFILE0; local DTBFILE1="$3"$DTBFILE1
if [ ! -d $PKGDIR ]; then
sleep 0.10
printf "une \e[91merreur \e[0mc'est produite lors de la lecture de certains fichiers\n\
\e[90messayez de voir si le r"$e_acute"pertoire: '$PKGDIR' existe\e[0m\n"
exit $ERCODE
elif [ ! -d "$PKGDIR/database" ]; then
sleep 0.10; printf 'Oops!\n'
printf "une \e[91merreur \e[0mc'est produite lors de la lecture de certains fichiers\n\
\e[90messayez de voir si le r"$e_acute"pertoire: '$PKGDIR/database' existe\e[0m\n"
exit $ERCODE
elif [[ ! (( -f "$DTBFILE0" || -f "$DTBFILE1" )) ]]; then
sleep 0.10
printf "\e[91m===> ERREUR: \e[0mimpossible de lire la base de donn"$e_acute"es\n\
\e[90mla synchronisation a "$e_acute"chou"$e_acute"e\e[0m\n"; exit $ERCODE
fi
else
printf "\e[91merreur \e[0mde syntaxe\n"
exit $ERCODE
fi  ######## fin des analyses



if [ "$1" = '-p' ]; then
if "$DTBFILE0" "$2"_pth &>/dev/null; then
"$DTBFILE0" "$2"_pth
else
printf "$(basename $SCRIPTFILE): '$2' paquet non trouv"$e_acute"\n"; exit $ERCODE 
fi
elif [ "$1" = '-pi' ]; then
  local LINE="$(sed -n -e "/\(^{$2}\)/p" $DTBFILE1|rev|sed 's/\((.}\)/( }/'|rev)"
if test -n "$LINE"; then
  local DEPPART="$(cut -d' ' -f2- <<< $LINE)"
  local LINE="$(cut -d' ' -f1 <<< $LINE)"
  local LINE0="$(sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g' <<< "$LINE")"
  local LINE1=($(sed -n -e "/\(^$2_desc\)/p" $DTBFILE1|sed "s/^$2_desc[[:punct:]]/\"/; s/[[:punct:]]url[[:punct:]]/\" \"/; s/[[:punct:]]$/\"/"))
  local pkgname="$(cut -d' ' -f1 <<< $LINE0)"
  local pkgver="$(cut -d' ' -f2 <<< $LINE0)"
  local pkgrev="$(cut -d' ' -f3 <<< $LINE0)"
  local arch="$(cut -d' ' -f4 <<< $LINE0)"
  local builddate="$(date --date="@$(cut -d' ' -f5 <<< $LINE0)" +%d/%m/%y)"
  local buildtime="$(date --date="@$(cut -d' ' -f5 <<< $LINE0)" +%R)"
  local pkgtype="$(cut -d' ' -f6 <<< $LINE0)"
  local pkgsize="$(cut -d' ' -f7 <<< $LINE0)"
  local packager="$(cut -d' ' -f8 <<< $LINE0|tr '<>' ' ')"
  local pkgdesc="$(cut -d'"' -f2 <<< ${LINE1[@]})"
  local pkg_url="$(cut -d'"' -f3- <<< ${LINE1[@]}|tr -d '"[[:space:]]')"
  local depends="$(cut -d')' -f1 <<< "$DEPPART"))"
  local makedepend="$(cut -d')' -f2- <<< "$DEPPART")"
else
printf "$(basename $SCRIPTFILE): '$2' paquet non trouv"$e_acute"\n"
exit $ERCODE
fi


cat << EOF
======================================================================
                   G$(printf '\xc3\xa9')n$(printf '\xc3\xa9')r$(printf '\xc3\xa9') par sspm (install) $SSPM_VER
======================================================================
$pkgdesc 
site: $pkg_url

$TEXT0           = $pkgname
$TEXT1                 = $pkgver
$TEXT2                = $pkgrev
$TEXT3            = $arch
$TEXT4     = $builddate
$TEXT5    = $buildtime
$TEXT6          = $pkgtype
$TEXT7               = $depends
$TEXT8     = $makedepend
$TEXT9        = $pkgsize
$TEXT10             = $packager

EOF
exit $OKCODE

fi




fi




}





                                       sspm_depends () {
                                       if [[ -z $1 ]]; then
                                       bsdtar_ver="$(bsdtar --version | cut -d '-' -f1 | sed 's/ $//g')"
                                       zstd_ver="zstd $(zstd --version | cut -d 'v' -f2 | cut -d ',' -f1)"
                                       tar_ver="tar $(tar --version | tr '\n' ' ' | cut -d ' ' -f4)" 
                                       pkg_config_ver="pkg-config $(pkg-config --version)"
                                       procps_ng_ver="$(ps --version | rev | cut -d ' ' -f1,2 | rev )"
                                       which_ver="which $(which --version | head -1 | tr -d "[:alpha:],[:space:]" | cut -d '(' -f1)"
                                       printf "$bsdtar_ver%2s$pkg_config_ver%2s$procps_ng_ver%2s$tar_ver%2s$which_ver%2s$zstd_ver\n"
                                       exit $OKCODE
                                       fi
                                       }
                  
pkgbuild_example () {
local DEST_DIR=
if [ -n "$extra_1" ]; then
 if [[ "$extra_1" =~ /$ ]]
  then local DEST_DIR="$extra_1"
  else  local DEST_DIR=""$extra_1"/"
 fi
fi

tee $DEST_DIR"$BUILDFILE" 1>/dev/null << EOF
pkgname=
pkgver=
pkgrev=
pkgdesc=""
url=""
groups=""
depends=()
makedepend=()
packager=""
tfext=""


build() {





}

EOF
}



make_build() {
# erreur quelque chose manque
local ERCODE=3
# certains dialogues marche mieux si la variable RANDOM existe
# peut etre retirer si RANDOM sera toujours disponible
local RANDOM=${RANDOM:-$(od -A n -t d -N 3 /dev/random)}
# si la variable 'LV_BUILD' est initialiser, lancer du mode interactif 
if [[ -v LV_BUILD && -n "$LV_BUILD" ]]; then
local INT_MODE="$(tr '[:upper:]' '[:lower:]' <<< ${LV_BUILD//[[:punct:][:digit:]]})"
while [[ "$INT_MODE" = on || "$INT_MODE" = y || "$INT_MODE" = yes  ]]; do
clear; printf "\e[90mEntrez le nom du paquet\e[0m\n\nnom du paquet :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ -n "$val" && ! "$val" =~ [[:cntrl:]] ]]; then pkgname="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEntrez la version du paquet\e[0m\n\nnom du paquet : "$pkgname"\nversion       :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ -n "$val" && ! "$val" =~ [[:cntrl:]] ]]; then pkgver="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEntrez la r"$e_acute"vision du paquet (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then pkgrev="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%b\e[90mEntrez une courte description (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\ndescription   :\n\n" 
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then pkgdesc=("$val") && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mEntrez une adresse (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\nr"$e_acute"vision      : "$pkgrev"\n"
printf "%sdescription   : ${pkgdesc[@]}\n"; printf "url           :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then url="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mLe type de paquet  '(base)%3s(add)%3s(opt)%3s( )'  (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"; printf "groupe        :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then groups="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mLes d"$e_acute"pendances du paquet s"$e_acute"par"$e_acute"es par un espace ou une virgule (facultatif)\e[0m\n\n\
nom du paquet : "$pkgname"\nversion       : "$pkgver"\nr"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"
printf "%burl           : $url\n"; printf "groupe        : $groups\n"; printf "d"$e_acute"pend de     :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then depends="$(tr ',;' ' ' <<< "$val")" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mLes paquets qui d"$e_acute"pendent du paquet (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"
printf "groupe        : $groups\n"; printf "d"$e_acute"pend de     : $depends\n"; printf "d"$e_acute"pendant     :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then makedepend="$(tr ',;' ' ' <<< "$val")" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mcompil"$e_acute" par (facultatif)\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"; printf "groupe        : $groups\n"
printf "d"$e_acute"pend de     : $depends\n"; printf "d"$e_acute"pendant     : $makedepend\n"; printf "packager      :\n\n"
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then packager="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mL'extension de l'archive source  'tar.gz'\e[0m\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"; printf "groupe        : $groups\n"
printf "d"$e_acute"pend de     : $depends\n"; printf "d"$e_acute"pendant     : $makedepend\n"; printf "packager      : $packager\n"; printf "tfext         :\n\n" 
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then tfext="$val" && break; else read -p ':: ' val && continue; fi done
clear; printf "%s\e[90mLassez vide si vous avez d"$e_acute"j"$a_grave" initialiser la variable 'SRC'\e[0m\
\n\nnom du paquet : "$pkgname"\nversion       : "$pkgver"\n\
r"$e_acute"vision      : "$pkgrev"\n"; printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"; printf "groupe        : $groups\n"
printf "d"$e_acute"pend de     : $depends\n"; printf "d"$e_acute"pendant     : $makedepend\n"
printf "packager      : $packager\n"; printf "tfext         : $tfext\n"; printf "SRC           :\n\n" 
read -p ':: ' val; [[ "$val" = [qQ] ]] && exit; until false; do if [[ ! "$val" =~ [[:cntrl:]] ]]; then SRC_DIR="$val" && break; else read -p ':: ' val && continue; fi done


                      clear
                      f_state() {
                            if [[ "$build" =~ [[:cntrl:]] || "$config" =~ [[:cntrl:]] ]]; then
                              case $RANDOM in
                                 2*2*3* | 2*6* | 4*4 | *9*9*3* | 6*7*1*1 | *0*0 | *1*9* | *5*7* )
                                 printf "%s\e[90msaisissez plut"$o_circumflex"t que de coller, pour eviter certains comportements\n"
                                 printf "%savec le retour $a_grave la ligne. [q] quitter, [}] terminer\e[0m\n\n" ;;
                                 * )
                                 printf "%s\e[90mla touche [q] pour quitter, [}] pour terminer\e[0m\n\n" ;;
                              esac
                            else printf "%s\e[90msaisissez ou collez toute la configuration du paquet puis '}'\e[0m\n\n"
                            fi
                                printf "nom du paquet : "$pkgname"\nversion       : "$pkgver"\nr"$e_acute"vision      : "$pkgrev"\n"
                                printf "%sdescription   : ${pkgdesc[@]}\n"; printf "%burl           : $url\n"; printf "groupe        : $groups\n"
                                printf ""$e_acute"pend de     : $depends\n"; printf "d"$e_acute"pendant     : $makedepend\n"
                                printf "packager      : $packager\n"; printf "tfext         : $tfext\n"
                                printf "%bSRC           : $SRC_DIR\n\n"
                                [[ "$build" ]] && printf "%b$build\n" || printf "build%1s()%1s\n{\n"
                            }


while true; do
clear; f_state; read config
if [[ -n "$config" && ! "$config" =~ [[:cntrl:]] ]]; then
   [[ "$config" == '}' ]] && break
   [[ "$config" == [qQ] ]] && exit
if [[ "$build" ]]; then
  build="$build
  $config
  "
  else
  build="build()
  {
  $config
  "
fi
continue
else
continue
fi
done
unset f_state
# les espace de la commande 'sed' ci-dessous correspandes a la position du contenu de la variable build ci-dessus
# NB: si pour quelconque raison vous modifiez la position de la variable build ci-dessus vous devez aussi ajuster 
# les espaces de la commande 'sed' ci-dessous. car il est primordiale pour les lignes contenant les commandes
# 'make' ne commencent pas par des espaces. voir la page d'infos pour un exemple precis.
build="$(sed 's/^  //g' <<< $build)
}"
if [[ -z "$pkgrev" ]]; then pkgrev=1; fi
if [[ -n "$url" ]]; then [[ $url =~ ^\".*\"$ ]] || url="$(sed 's/^\|$/"/g' <<< $url)"; fi
if [[ -n "$pkgdesc" ]]; then [[ $pkgdesc =~ ^\".*\"$ ]] || pkgdesc="$(sed 's/^\|$/"/g' <<< $pkgdesc)"; fi
if [[ -n "$packager" ]]; then [[ $packager =~ ^\".*\"$ ]] || packager="$(sed 's/^\|$/"/g' <<< $packager)"; fi


                       sleep 0.20 && clear
                       if [[ -n $SRC_DIR && -d $SRC_DIR ]] || [[  -n $SRC && -d $SRC ]]; then
                       [[ -d $SRC ]] || SRC="$SRC_DIR"
                       [[ "$SRC" =~ /$ ]] && SRC="${SRC%?}"
                       printf "%1sSouhaitez vous g"$e_acute"n"$e_acute"ner une somme de contr"$o_circumflex"le ? (o/n)\n"
                       printf "%1s\e[90mtouche [entrer] pour 'non'\e[0m\n\n"
                       read -p ':: '  REP && case $REP in [nN]|'') ;; [oO]|[yY]) PKG_HASH=yes ;; *) exit $ERCODE ;; esac
                       OLDBDIR="$BDIR"    OLDBUILDFILE="$BUILDFILE"         BDIR=/tmp    BUILDFILE=""$BUILDFILE"_$RANDOM"
                       printf "%bpkgname=$pkgname\npkgver=$pkgver\npkgrev=$pkgrev\npkgdesc=$pkgdesc\nurl=$url\ngroups=$groups\n" > "$BDIR/$BUILDFILE"
                       printf "%bdepends=($depends)\nmakedepend=($makedepend)\npackager=$packager\ntfext=$tfext\n\n\n" >> "$BDIR/$BUILDFILE"
                       printf "%b$build\n" >> "$BDIR/$BUILDFILE"
                       RMBLDF=y; printf "%s\n" && sleep 0.15 && clear
                       break
                       else
                       printf "\nerreur:  impossible de trouver le r"$e_acute"pertoire source\n"
                       exit $ERCODE
                       fi

done
fi
# fin d'analyse du mode interactif

                               #### detection s'il ya plusieurs fichiers pkgbuild
                               shopt -s nullglob; local BUILDFILES=("$BUILDFILE"_*); shopt -u nullglob
                               if [[ ${#BUILDFILES[@]} -ge 1 ]]; then
                               [[ ! -f $BUILDFILE ]] || local BUILDFILES+=($BUILDFILE)
                               if [[ ${#BUILDFILES[@]} = 1 ]]; then local BUILDFILE=$BUILDFILES
                                else
                                                                                if [[ $RANDOM == *3*5* ]]
                                                                                then printf '\n\e[2;49;37mveuillez entrer un\e[0m suffixe\n\n\n'
                                                                                elif [[ $RANDOM == 2* ]]
                                                                               then printf '\nveuillez entrer un \e[1mnom\e[0m\n\n\n'
                                                                              elif [[ $RANDOM == *7 ]]
                                                                             then printf '\nentrez un nom\n\n\n'
                                                                           elif [[ $RANDOM == *2*2* ]]
                                                                         then local read_cmd=y
                                                                        printf '\n\n'; read -p "compil$(printf '\xc3\xa9') ? :: " NAME
                                                                        elif [[ $RANDOM == *1* ]]
                                                                        then printf '\nfichiers ('${#BUILDFILES[@]}') entrez un nom\n\n\n'
                                                                         elif [[ $RANDOM == 8* ]]
                                                                           then printf "\nentrer le nom d'un paquet\n\n\n"
                                                                             local read_cmd=y
                                                                              read -p "(${#BUILDFILES[@]}) :: " NAME
                                                                               elif [[ $RANDOM == *6* ]]
                                                                                then printf '\n veuillez entrer un nom\n\n\n'
                                                                                elif [[ $RANDOM == *4* ]]
                                                                                then printf '\n veuillez entrer un suffixe\n\n\n'
                                                                                else printf '\n * veuillez entrer un nom!\n\n\n';fi
                                      
                                   while true; do
                                     if [[ $read_cmd ]]; then
                                   if [[ -n "$NAME" && "$NAME" != q ]] && \
                                   [[ "$NAME" =~ ^[[:print:]]+$ ]]; then
                                   printf '\n'; break                                
                                   else
                                   [[ -z "$NAME" || "$NAME" = q ]] && printf '\n' && exit 
                                   read_cmd=y; read -p ':: ' NAME ; continue
                                   fi
                                   else
                                   read_cmd=y; read -p ':: ' NAME ; continue
                                     fi
                                   done
                                   
                                   [[ $NAME == "$BUILDFILE"_* ]] && local OLDBUILDFILE=$BUILDFILE BUILDFILE=$NAME \
                                   || local OLDBUILDFILE="$BUILDFILE" BUILDFILE=""$BUILDFILE"_$NAME"
                                   unset NAME read_cmd
                                 fi
                                fi


#### routine de verification du fichier pkgbuild
local BUILDDATE="`date '+%D'`"  BUILDTIME="`date '+%R'`" PKGBID="$([[ "${EUID:-$(id -u)}" -ne 0 ]] && printf '1' || printf '0' )"
local TMPFILE="$TMP/.$BUILDFILE"; ipc_tool -c; set -e; [[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x; if [[ -n "$extra_1" ]]; then
if [[ ! -d "$extra_1" ]]; then printf "\e[91merreur:\e[0m  impossible d'acceder au r"$e_acute"pertoire '$extra_1'\n"; exit $ERCODE; fi
local DEST_DIR=""$(realpath -e $extra_1)"/"; fi; if [ -f "$BDIR/$BUILDFILE" ]; then if [ -s "$BDIR/$BUILDFILE" ]; then 
local REF_VAR=($(grep -E 'pkgname=|pkgver=|pkgrev=|tfext=' "$BDIR/$BUILDFILE" | cut -d'=' -f1 | tr '\n' ' '))
local NO_EMPTY=($(grep -E 'pkgname=|pkgver=' "$BDIR/$BUILDFILE" | cut -d'=' -f2 | tr -d "\"'" | tr '\n' ' '))
if ! [[ "${#REF_VAR[@]}" = 4 && "${REF_VAR[@]}" =~ ^[pkgname_pkgver_pkgrev_tfext_[:space:]_]+$ && "${#NO_EMPTY[@]}" = 2 ]]; then
if [[ "${#NO_EMPTY[@]}" -eq 0 || (( "${#REF_VAR[@]}" = 4 && "${#NO_EMPTY[@]}" -lt 2 )) ]]; then
printf "\e[91merreur:  \e[0m veuillez remplir le fichier ($BUILDFILE)\n"; exit $ERCODE
elif [[ "${#REF_VAR[@]}" -lt 4 ]]; then local MISSING_REF_VAR=()
for name in pkgname pkgver pkgrev tfext; do [[ "${REF_VAR[@]}" =~ $name ]] || MISSING_REF_VAR+=("$name"); done
printf "\e[91merreur:  \e[0m'${MISSING_REF_VAR[@]}=' manquant dans le fichier ($BUILDFILE)\n"; exit $ERCODE
else printf "\e[91merreur: \e[0m impossible de lire correctement le fichier ($BUILDFILE)\n\
%9sassurez-vous de l'avoir correctement rempli\n"; exit $ERCODE; fi
else local NO_EMPTY_FUNC0="$(sed -n '/^\(.*().*{\)\|^\({\)/,/^\(.*}.*\)/p' "$BDIR/$BUILDFILE"\
|sed '/^.*().*{\|^{\|^.*}/s/#.*//'|sed 's/^.*().*{\|^{$\|\(^.*}\)//g'|tr -d '\n[:space:]')"
local NO_EMPTY_FUNC1="$(sed -n '0,/^.*().*{\|^{/!p' "$BDIR/$BUILDFILE" | tac | sed -n '0,/^}\|^.*}/!p'|tac|tr -d '\n[:space:]')"
if ( test $(wc -m <<< "$NO_EMPTY_FUNC0") -eq 1 && test $(wc -m <<< "$NO_EMPTY_FUNC1") -lt 2 ); then
printf "\e[91merreur: \e[0m impossible de lire correctement le fichier ($BUILDFILE)\n\
%9sassurez-vous de l'avoir correctement rempli\n\n\t%2s***** the build function is empty *****\n"; exit $ERCODE; fi fi
else printf "\e[91merreur:  \e[0mle fichier ($BUILDFILE) est vide\n\
Essayer 'sspm --pkgbuild-example' Pour avoir un exemple du fichier de construction\n"; exit $ERCODE; fi
else case $RANDOM in 2*2* | *0*4 | *3*5 | 6*1* | *0*0 | *9*1* )
printf "\e[91merreur:\e[0m  ($BUILDFILE) \e[2mfichier inexistant\e[0m\n" ;;
*) printf "\e[91merreur:  \e[0mle fichier ($BUILDFILE) n'existe pas\n"  ;; esac; exit $ERCODE; fi
[[ -n "$1" && "$1" == "-wh" ]] && local PKG_HASH=yes
printf "\e[1msspm (build)\e[0m\nOutil de cr"$e_acute"ation de paquets compatibles\n\
pour une utilisation avec le gestionnaire sspm\n"; sleep 0.60; cd $TMP; if [ $(pwd -P) != $TMP ]; then
printf "\e[91merreur: \e[0mnous ne pouvons pas cr"$e_acute"er de paquets dans ce r"$e_acute"pertoire\n"; exit $ERCODE; fi

# S'assurer que la variable "SRC" est bien definie 
printf '\e[36mInitialisation de la source...\e[0m\n'
sleep 0.20;
                source_dir() 
                {
                printf '\n'; read -p "::" REP
                if [[ -n "$REP" ]]; then
                if [[ -d "$REP" && -n $(ls -A $REP) ]]; then
                [[ "$REP" =~ /$ ]] && REP="${REP%?}"
                CHECK_FILES=($REP/*)
                if [[ ${#CHECK_FILES[@]} > 0 ]]; then
                export SRC="$REP"
                sleep 0.40 && printf '\n'
                else
                printf "\nsspm: fichiers introuvables dans  '$REP'\n"
                exit $ERCODE
                fi
                elif [[ -d "$REP" && -z $(ls -A $REP) ]]; then
                printf "\nsspm: '$REP'  r"$e_acute"pertoire vide\e[0m\n"
                exit $ERCODE
                else
                printf "\nsspm: r"$e_acute"pertoire '$REP' non trouv"$e_acute"\n"
                exit $ERCODE
                fi
                else
                printf '\n'
                exit $OKCODE
                fi
                }
                               if ! (set -u; : $SRC) &>/dev/null && ! (set -u; : $PKG_SRC) &>/dev/null; then
                               printf "\e[91m==> ERREUR:%3s\e[0mj'ai pas pu trouver la source\n"
                               printf "\e[90massurez-vous que la variable SRC est bien d"$e_acute"finie.\e[0m\n\n"
                               read -p "souhaitez-vous l'indiqu$(printf '\xc3\xa9')e maintenant ? (o/n) " REP
                               case $REP in [oO] | '') source_dir ;; [nN] | *) exit ;; esac
                               else [[ $SRC ]] && [[ "$SRC" =~ /$ ]] && SRC="${SRC%?}"
                               fi
# verification et detection dans le fichier de construction
# le nom de la seule fonction de construction qui devrait y exister
printf "\e[36mlecture du fichier de construction\e[0m\n"; sleep 0.70
## detection si le paquet a une configuration: simple, pseudo complexe ou aucune.
## afin de parametrer en consequence (ex: si le fichier de construction contient la commande "ln": 
## alors celle-ci et le reste des commandes seront transferees dans le script d'installation ...etc)

local B_FUNCTION_CMD="$(sed -ne '/\(^make.*install\)\|\(^DESTDIR.*install\)/,/\(^}.*\)/p' $BDIR/$BUILDFILE | sed '/cat.*EOF\|cat.*eof/,/EOF\|eof/d ; /^#/d ; /\(^make.*install\)\|\(^DESTDIR.*install\)\|^#$\|^[[:space:]]\}$\|\(^}.*\)\|^$/d' | tr -d "\"[:space:]'" |cut -d ' ' -f 1)"


                      if [[ -z $B_FUNCTION_CMD ]] || [[ ! $B_FUNCTION_CMD =~ "ln" && (( $B_FUNCTION_CMD =~ ^[install_]+$ || $B_FUNCTION_CMD =~ ^[mv_]+$ || \
                      $B_FUNCTION_CMD =~ ^[mv_rm_]+$ || $B_FUNCTION_CMD =~ ^[mv_cp_]+$ || $B_FUNCTION_CMD =~ ^[rm_]+$ || $B_FUNCTION_CMD =~ ^[cp_]+$ || \
                      $B_FUNCTION_CMD =~ ^[mv_install_]+$ || $B_FUNCTION_CMD =~ ^[cp_install_]+$ || $B_FUNCTION_CMD =~ ^[unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_rm_]+$ || $B_FUNCTION_CMD =~ ^[install_rm_]+$ || $B_FUNCTION_CMD =~ ^[install_unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_unset_]+$ || $B_FUNCTION_CMD =~ ^[mv_unset_]+$ || $B_FUNCTION_CMD =~ ^[rm_unset_]+$ || \
                      $B_FUNCTION_CMD =~ ^[touch_]+$ || $B_FUNCTION_CMD =~ ^[install_touch_]+$ || $B_FUNCTION_CMD =~ ^[mv_touch_]+$ || \
                      $B_FUNCTION_CMD =~ ^[cp_touch_]+$ || $B_FUNCTION_CMD =~ ^[rm_touch_]+$ || $B_FUNCTION_CMD =~ ^[install_tar_]+$ )) ]]
                      then    local CONFIG_TYPE=; cp "$BDIR/$BUILDFILE" $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" && $B_FUNCTION_CMD =~ "localedef" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "localedef" || $B_FUNCTION_CMD =~ "localedef" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" && $B_FUNCTION_CMD =~ "rpc" || \
                      $B_FUNCTION_CMD =~ "ZONEINFO" && $B_FUNCTION_CMD =~ "zic" ]]
                      then if grep -qiF '=glibc' $BDIR/$BUILDFILE; then
                              if grep -qiF 'tzselect' $BDIR/$BUILDFILE; then
                              printf "erreur: le fichier '$BUILDFILE' ne devrait pas contenir la commande '\e[1mtzselect\e[0m'\n"
                              exit $ERCODE
                              elif [[ $B_FUNCTION_CMD == *ln*localtime* ]]
                              then local CONFIG_TYPE="C"
                              sed "/\(^ln.*localtime\)\|\(.*ln.*localtime.*\)/s/^/##/"  < $BDIR/$BUILDFILE > $TMPFILE
                              else local CONFIG_TYPE=; cp $BDIR/$BUILDFILE  $TMPFILE
                              fi
                            fi
                      elif [[ $B_FUNCTION_CMD =~ ^"for".* ]]; then local CONFIG_TYPE="C"
                        sed "/\(^for.* in .*\)\|\(.*for.* in .*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                        ( grep -E ^'##install|##make*-ln*|##cp*|##mkdir*' $TMPFILE 1>/dev/null ) && \
                        sed -i '/^##install \|^##make.*-ln.*\|^##mkdir\|^##cp/s/^##//g' $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ "ln" ]]; then  local CONFIG_TYPE="C"
                        sed "/\(^ln.*\)\|\(.*ln.*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                        ( grep -E ^'##install|##make*-ln*|##cp*|##sed*ln*|##sed*Makefile|##make*|##mkdir*' $TMPFILE 1>/dev/null ) && \
                        sed -i '/^##install \|^##make.*-ln.*\|^##make\|^##sed.*ln.*\|^##sed.*Makefile\|^##mkdir\|^##cp/s/^##//g' $TMPFILE
                      elif [[ $B_FUNCTION_CMD =~ ^[chmod_]+$ ]]; then  local CONFIG_TYPE="C"
                        sed "/\(^chmod.*\)\|\(.*chmod.*\)/,/^[[:space:]]\}$\|\(^}.*\)/ s/^/##/; \
                        /^##$\|\(^}.*\)\|\(^##}.*\)\|^[[:space:]]\}$/s/^##//g"  < $BDIR/$BUILDFILE > $TMPFILE
                      else  local CONFIG_TYPE= ; cp "$BDIR/$BUILDFILE" $TMPFILE                   
                      fi


if [[ "$INT_MODE" != on && "$INT_MODE" != y && "$INT_MODE" != yes ]]; then
local check1_fonction_name=$(cat $TMPFILE | grep "()" | sed 's/=()//g' | sed '/'depends'\|'makedepend'\|'pkgname'\|'pkgver'\|'pkgrev'\|'pkgdesc'\|'url'\|'"groups"'\|'tfext'/d' | sed 's/()//g' | sed 's/{//g')
local check2_fonction_name="$(sed -n '/\(^.*().*\)/h; ${x;p;}' $TMPFILE | tr -d '(){}')"
shopt -s extglob
local check1_fonction_name="${check1_fonction_name##*( )}"
local check1_fonction_name="${check1_fonction_name%%*( )}"
local check2_fonction_name="${check2_fonction_name##*( )}"
local check2_fonction_name="${check2_fonction_name%%*( )}"
shopt -u extglob
local auto_genereted_vars_found="$(sed -n '/^pkgbid=\|^builddate=\|^buildtime=/p' $TMPFILE|wc -w)"
[[ $auto_genereted_vars_found -gt 0 ]] && sed -i '/^pkgbid=\|^builddate=\|^buildtime=/d' $TMPFILE
. $TMPFILE
if [[ -n "$check1_fonction_name" && -n "$check2_fonction_name" ]] && (( "$check1_fonction_name" == "$check2_fonction_name" )); then
run_build_safe()
{
if type  $check1_fonction_name 1>/dev/null; then  
  start_day="$(date +"%F")"
  start_time="$(date +"%s")"
  [[  -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && $check1_fonction_name || $check1_fonction_name 1>/dev/null 2>&1
else
  printf "\e[91m==> ERREUR:  \e[0mimpossible de lire la fonction de construction dans le fichier '$BUILDFILE'\n"
  printf "\e[90massurez-vous qu'elle existe et que sa syntaxe est correcte.\e[0m\n"; exit $ERCODE
fi
}
fi
else
. $TMPFILE
run_build_safe()
{
if type -t build 1>/dev/null; then
  start_day="$(date +"%F")"
  start_time="$(date +"%s")"
  [[  -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && build || build 1>/dev/null 2>&1
else
  printf "\e[91m==> ERREUR:  \e[0mimpossible de lire la fonction de construction\n"
  printf "\e[90massurez-vous qu'il n'y a pas eu une erreur de saisie.\e[0m\n"
  printf "\e[90mtapez 'sspm info' pour avoir une exemple de la fonction build\e[0m\n"; exit $ERCODE
fi
}
fi



## verification du type de paquet specifie dans '$groups'
# si la variable est vide alors on verifie du cote de 'PKG_GROUP' ou alors le paquet sera de type 'autre' 
if [[ -n "$groups" && (( "$groups" != base && "$groups" != add && "$groups" != opt )) ]]; then
printf "\e[93mavertissement:\e[0m le groupe sp"$e_acute"cifi"$e_acute" n'est pas reconnu, assurez vous d'utiliser une de ces valeurs:\n\
\e[2m%6sbase%20sadd%20sopt%15sother/vide\e[0m\n\e[90m(paquets de base)%3s(paquets additionnels)%3s(paquets optionnels)%3s(autres paquets)\e[0m\n"
sleep 0.82
fi

if [[ -z "$groups" ]]; then
 if [[ -n "$PKG_GROUP" ]]; then 
    if [[ "$PKG_GROUP" = base || "$PKG_GROUP" = add || "$PKG_GROUP" = opt || "$PKG_GROUP" = other ]]; then
    local groups="$PKG_GROUP" set_env_group="yes"; else local groups="other"  set_env_group="yes"; fi
 fi
fi
if [[ -z $packager ]]; then [[ -z "$PACKAGER" ]] || local packager="$PACKAGER"  set_env_pack="yes"; fi
if [[ -z "$pkgrev" ]]; then local pkgrev="1"  set_rev_val="yes"; fi


## on verifient si un chemin d'acces direct vers "l'archive source" a ete donne 
## au cas ou on rencontraient des dificultes pour acceder au fichier source
## on suppose que l'archive est stockee quelque part et que la variable "SRC" pointe vers
## cet emplacement; si on ne parvient pas on cherche du cote de la variable "PKG_SRC"
## (ex: user0:$ export PKG_SRC=/chemin/d_acces/foo.tar.gz) puis re-executez votre commande
#########################################
local sufix="$SUFIX"
if [ -z $PKG_SRC ]; then
local PKG_SRC="$SRC/${pkgname}-${pkgver}.$tfext"
[[ -f "$PKG_SRC" ]] && local REFIND=NO || local REFIND=YES
fi
if [[ -z "$REFIND" || (( -n "$REFIND" && "$REFIND" = 'YES' )) ]]; then
local PKG_SRC_MATCH=(${PKG_SRC%%.*}*)

if [[ ${#PKG_SRC_MATCH[@]} -gt 0 ]]; then
if [[ "${PKG_SRC_MATCH[@]}" =~ "docs" || "${PKG_SRC_MATCH[@]}" =~ "html" \
|| "${PKG_SRC_MATCH[@]}" =~ "fixe" || "${PKG_SRC_MATCH[@]}" =~ "patch" \
|| "${PKG_SRC_MATCH[@]}" =~ "fhs" ]]
    then local PKG_SRC_MATCH1=()
    for psm in ${PKG_SRC_MATCH[@]}; do
    [[ "$psm" = *"docs"* || "$psm" = *"html"* || "$psm" = *"fixe"* || "$psm" = *"patch"* || "$psm" = *"fhs"* ]] || \
    local PKG_SRC_MATCH1+=("$psm")
    done
    local PKG_SRC_MATCH=(${PKG_SRC_MATCH1[@]})
    unset PKG_SRC_MATCH1
fi
fi

if [[ ${#PKG_SRC_MATCH[@]} -gt 1 ]]; then
local PKG_SRC_MATCH="$(tr '[:space:]' '\n' <<< "${PKG_SRC_MATCH[@]}" | sort -Vr | head -n1)"
fi
if [[ -f $PKG_SRC_MATCH ]]; then
local PKG_SRC="$PKG_SRC_MATCH"
unset PKG_SRC_MATCH
else
local PKG_SRC_MATCH="$(basename "$PKG_SRC")"
local HEAD="${PKG_SRC_MATCH:0:3}"
local HEAD="${HEAD,,}"
local PKG_SRC_FOUND="$(find $SRC -iname "$HEAD*.*" -type f)"
if [ -z "$PKG_SRC_FOUND" ]; then
printf "\e[91m===> ERREUR: \e[0mimpossible de trouver '$(basename "$PKG_SRC")' dans << $SRC >>\e[0m\n"
exit $ERCODE
fi
for FILE in $PKG_SRC_FOUND; do
FNAME="$(basename "${FILE,,}")"
if [[ "$FNAME" =~ "$HEAD" && "$FNAME" =~ "$pkgver" && (( "$FNAME" != *"docs"* && "$FNAME" != *"html"* && "$FNAME" != *"fixe"* && "$FNAME" != *"patch"* && "$FNAME" != *"fhs"* )) ]]
then local PKG_SRC="$FILE"; fi
done
fi
fi

                                        if grep -q '[Zz]ip archive' <<< $( file $PKG_SRC ); then
                                           if type -t 7z &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=7z
                                           elif type -t unzip &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=unzip
                                           elif type -t bsdtar &>/dev/null; then
                                              C_TYPE_FILE=zip; EXTOOL=bsdtar
                                           else
                                              printf "\nerreur:  vous devez installer 'libarchive, p7zip ou unzip'\n"
                                              printf "%9spour manipuler les fichiers zip avec sspm\n\n"
                                              exit $ERCODE
                                           fi
                                        fi

# 4 tests pour detecter le repertoire de base d'une archive peut apparaitre excessif mais croyez moi
# une simple erreur ici peut vous engendrez d'autres erreurs demotivantes.
# la commande ci-dessous s'arrete au premier resultat renvoye, ce qui nous evitent des problemes de performance
# car lire entierement une archive de 200MB par exemple, juste pour trouver le nom d'un repertoire peut apparaitre peu ecologique.
#######################################################
if [[ -n $C_TYPE_FILE && $C_TYPE_FILE = zip ]]; then
   if [[ $EXTOOL = unzip ]]; then
   local CD_DIR0="$(unzip -l "$PKG_SRC" 2>/dev/null | tac | head -n 4 | tail -n 1 | rev | cut -d' ' -f1 | rev)"
   local CD_DIR1="$(unzip -l "$PKG_SRC" 2>/dev/null | tail -n 4 | head -n 1 | rev | cut -d' ' -f1 | rev)"
   [[ ${CD_DIR0%%/*} == ${CD_DIR1%%/*} ]] && local CD_DIR=${CD_DIR0%%/*}
   elif [[ $EXTOOL = 7z ]]; then
   local CD_DIR0="$(7z l "$PKG_SRC" 2>/dev/null | tac | head -n 4 | tail -n 1 | rev | cut -d' ' -f1 | rev)"
   local CD_DIR1="$(7z l "$PKG_SRC" 2>/dev/null | tail -n 4 | head -n 1 | rev | cut -d' ' -f1 | rev)"
   [[ ${CD_DIR0%%/*} == ${CD_DIR1%%/*} ]] && local CD_DIR=${CD_DIR0%%/*}
   elif [[ $EXTOOL = bsdtar ]]; then
   local CD_DIR="$($TAR -tf "$PKG_SRC" 2>/dev/null | head -1)"
   fi
else
local CD_DIR="$(tar -tf "$PKG_SRC" 2>/dev/null | head -1)"
fi

[[ "$CD_DIR" =~ /$ ]] && local CD_DIR="${CD_DIR%?}" || [[ ! "$CD_DIR" =~ \/ ]] || local CD_DIR="$(dirname "$CD_DIR")" 
[[ "$CD_DIR" = "$(basename "$CD_DIR")" ]] || local CD_DIR="${CD_DIR%%/*}"
[[ -z "$CD_DIR" && -f $PKG_SRC ]] && printf "\e[93mavertissement:\e[0m  impossible de detecter le repertoire d'extraction de l'archive source\n"  && sleep 0.56
if [[ "$CD_DIR" = \. ]]; then unset CD_DIR
[[ -f $PKG_SRC ]] && printf "\e[93mavertissement:\e[0m  impossible de detecter le repertoire d'extraction de l'archive source\n" && sleep 0.56
fi
local TGT_PKG_NAME=$pkgname.$TAG.$PKGEXT
local extract_dir="$(mktemp -u extractdir_XXXXXXXXXX)"
pkgdir="$TMP/"$pkgname"_build$sufix"
pkgdir_rm=""$pkgname"_build$sufix"
spkgdir=""$pkgname"_source$sufix"
[ -d "$TMP/$spkgdir" ] && rm -rf "$TMP/$spkgdir"
[ -d "$TMP/$pkgdir_rm" ] && rm -rf "$TMP/$pkgdir_rm"
[ -d "$TMP/$extract_dir" ] && rm -rf "$TMP/$extract_dir"
[[ -n "$CD_DIR" && -d "$TMP/$CD_DIR" ]] && rm -rf "$TMP/$CD_DIR"

mkdir -p $pkgdir
# on cherche dans le fichier de construction si le paquet,
# exige une certaine hierarchie dans son environement de construction
##############################################################################
# pour les commandes de type 'mkdir , install , etc...' il se peut que vous ayez oublie d'indiquer '$pkgdir' comme racine
# les commandes ci-dessous previennent ou du moins essaient de prevenir la creation de ces repertoires 
# afin d'eviter des erreurs comme 'No such file or directory'
##############################################################################

                                        if test -n "$(sed -n '/install/{/make\|sed/!p;}; /cp\|mv\|touch/p' < $TMPFILE | \
                                        cut -d ' ' -f1 | tr -d '[:space:]')"; then
                                        if ! cat $TMPFILE | grep ^'mkdir' &>/dev/null; then
                               sleep 0.30
                               printf "\e[96mcr"$e_acute"ation de certains r"$e_acute"pertoires requis par le paquet\e[0m\n"
                               printf "\e[96mdans l'environement de construction\e[0m\n"
                               sleep 0.60
                                        while IFS= read -r line; do
                                        if [[ "$line" =~ ^"cp" || "$line" =~ ^"ln" || "$line" =~ ^"mv" \
                                        || "$line" =~ ^"install".*$ || "$line" =~ ^"touch" ]]; then
                                        line="$(rev <<< "$line" | cut -d ' ' -f1 | rev | sed 's/\($pkgdir\)//g'|tr -d "\"'")"
                                        subdir="$(basename "$line"|tr -d "\"'")"
					if [[ ${sysdirs[@]} =~ "$subdir" ]]; then
                                        [[ -d "$pkgdir"$line"" ]] || mkdir -p "$pkgdir"$line""
                                        else
					pdir="$(dirname "$line" 2>/dev/null|tr -d "\"'")"
					[[ "$pdir" =~ '$' || "$pdir" == '.' || -d ""$pkgdir"$pdir" ]] || mkdir -p ""$pkgdir"$pdir"
                                        fi
                                        elif [[ "$line" =~ ^"cat" && (( "$line" =~ '>' || "$line" =~ '>>' )) && "$line" =~ '<<' ]]; then
                                        output_file="$(sed 's/\(.*>\)\|\(<.*\)\|$pkgdir//g' <<< "$line" | tr -d '[:space:]')"
                                        output_dir=""$pkgdir"$(dirname $output_file|tr -d "\"'")"
                                        [[ -d "$output_dir" ]] || mkdir -p $output_dir
                                        fi
                                        done < $TMPFILE
                                        else  sleep 0.30; printf "\e[96mv"$e_acute"rification de l'environement de construction\e[0m\n"; sleep 0.60
                                        while IFS= read -r line; do
                                        if [[ "$line" =~ ^"cp" || "$line" =~ ^"mv" || "$line" =~ ^"install".*$ || "$line" =~ ^"touch" ]]; then
                                        line="$(rev <<< "$line" | cut -d ' ' -f1 | rev | sed 's/\($pkgdir\)//g'|tr -d "\"'")"
                                        subdir="$(basename "$line"|tr -d "\"'")"
				        if [[ ${sysdirs[@]} =~ "$subdir" ]]; then
                                        [[ -d "$pkgdir"$line"" ]] || mkdir -p "$pkgdir"$line""
                                        else pdir="$(dirname $line|tr -d "\"'")" ; [[ "$pdir" =~ '$' || "$pdir" == '.' || -d ""$pkgdir"$pdir" ]] || mkdir -p ""$pkgdir"$pdir"
                                        fi ; elif [[ "$line" =~ ^"cat" && (( "$line" =~ '>' || "$line" =~ '>>' )) && "$line" =~ '<<' ]]; then
                                        output_file="$(sed 's/\(.*>\)\|\(<.*\)\|$pkgdir//g' <<< "$line" | tr -d '[:space:]')"
                                        output_dir=""$pkgdir"$(dirname $output_file|tr -d "\"'")"
                                        [[ -d "$output_dir" ]] || mkdir -p $output_dir
                                        fi  done < $TMPFILE;  fi  fi   
                                                           

case "${pkgname,,}" in 'glibc') set +e ;; esac
cd $TMP && if [[ -f $PKG_SRC ]]; then
[ ! -d "$extract_dir" ] || rm -rf "$extract_dir"
local options="$([[ -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "q" ]] && printf 'xvf'||printf 'xf')"
mkdir $extract_dir &&
if [[ $C_TYPE_FILE ]]; then
 if [[ $C_TYPE_FILE = "zip" ]]; then
   case $EXTOOL in
        'unzip' ) unzip $PKG_SRC -d $extract_dir ;;               
             7z )  7z x -bd -y $PKG_SRC -o$extract_dir ;;
         bsdtar ) $TAR $options $PKG_SRC -C $extract_dir ;;
   esac
 fi
 else
 tar $options $PKG_SRC -C $extract_dir
fi
if (shopt -s nullglob dotglob; count=($extract_dir/*); test ${#count[@]} -eq 1 && test -d "$extract_dir/$CD_DIR"); then
rename "$extract_dir/$CD_DIR" $spkgdir "$extract_dir/$CD_DIR" && rm -rf $extract_dir
cd $spkgdir && run_build_safe
else
mv $extract_dir $spkgdir && cd $spkgdir && run_build_safe
fi
else
  printf "\e[91m==> ERREUR:  \e[0mimpossible de trouver le fichier $PKG_SRC\n\
  \e[90massurez-vous que le fichier existe \n\
  et que son extention est bien celle d"$e_acute"clar"$e_acute"e dans '$BUILDFILE'\n\
  vous pouvez directement indiquer le fichier source dans 'PKG_SRC'\n\
  (ex: export PKG_SRC=/r"$e_acute"pertoire/r"$e_acute"pertoire/fichier.bzip2)\e[0m\n"
  [ -f "$TMPFILE"  ] && rm -f $TMPFILE
  [ -d "$extract_dir" ] && rm -rf "$extract_dir"
  [ -d "$TMP/$spkgdir" ] && rm -rf "$TMP/$spkgdir"
  [ -d "$TMP/$pkgdir_rm" ] && rm -rf "$TMP/$pkgdir_rm"
  [[ -n "$CD_DIR" && -d "$TMP/$CD_DIR" ]] && rm -rf "$TMP/$CD_DIR"
  exit $ERCODE
fi
local error_code="$?"
[ $error_code -ne 0 ] && exit $error_code
printf "copie du fichier de construction\n"
[[ "$OLDBUILDFILE" ]] && local PKGFILE="$OLDBUILDFILE" || local PKGFILE="$BUILDFILE"
sed "3a pkgbid=$PKGBID\nbuilddate='"$BUILDDATE"'\nbuildtime='"$BUILDTIME"'"  < $TMPFILE | sed 's/^##//g' > $pkgdir/$PKGFILE
[[ -n $set_rev_val && $set_rev_val = yes ]] && sed -i '/^pkgrev/s/=.*/="'$pkgrev'"/' $pkgdir/$PKGFILE
[[ -n $set_env_group && $set_env_group = yes ]] && sed -i '/^groups/s/=.*/="'$groups'"/' $pkgdir/$PKGFILE
[[ -n $set_env_pack && $set_env_pack = yes ]] && sed -i "/^packager/s/=.*/=\"$packager\"/" $pkgdir/$PKGFILE
printf "cr"$e_acute"ation du script d'installation\n"
cat > $pkgdir/$PKG_INSTALL <<EOF
# fichier de configuration de $pkgname-$pkgver 

EOF
if [[ -n "$CONFIG_TYPE" && "$CONFIG_TYPE" == "C" ]]; then
cat $TMPFILE | sed -n '/\(^##.*\)/p' | sed 's/^##\|$pkgdir//g' >> $pkgdir/$PKG_INSTALL;
fi
rm -f $TMPFILE
if [ "$RMBLDF" = y ]; then rm -f "$BDIR/$BUILDFILE"; local BDIR="$OLDBDIR"; fi
chmod a+x $pkgdir/$PKG_INSTALL;
# on verifie s'il existe des liens symboliques rompu du paquet 
# pour les recrees plutard lors de son installation           
              while IFS= read -r line; do
              test -z "$line" && continue
                if [[ -n $(find $pkgdir -name "$(basename $(readlink $line))") ]]
                 then
                   target="$(find $pkgdir -name "$(basename $(readlink $line))" | sed 's|'$pkgdir'||g')"
                   name="$(printf "$line" | sed 's|'$pkgdir'||g')"
                   if ! grep "$(basename $line)" $pkgdir/$PKG_INSTALL 1>/dev/null; then
                   printf "ln -sfv $target $name\n" >> $pkgdir/$PKG_INSTALL
                   fi
                 else continue; fi
              done <<< $(find $pkgdir -xtype l -print)
# Creation du paquet
sleep 0.30; printf "\n\e[100mCr"$e_acute"ation du paquet\e[0m\n"; sleep 0.60
if [ -z "$DEST_DIR" ]; then
[ -f $BDIR/$TGT_PKG_NAME ] && rm -f $BDIR/$TGT_PKG_NAME
cd $pkgdir && make_sum_check -g "." -o $FILES_SHA && $TAR -cpf $BDIR/$TGT_PKG_NAME --zstd $COMPRESS_AS .
if [[ ! -z $PKG_HASH && $PKG_HASH = "yes" ]]; then 
if [ -f $BDIR/$TGT_PKG_NAME ] && ( file $BDIR/$TGT_PKG_NAME 2>/dev/null | grep 'Zstandard compressed' 1>/dev/null ); then
cd $BDIR && make_sum_check -g "$TGT_PKG_NAME" -o "$PKG_SHA"; fi; fi
else
[ -f "$DEST_DIR"$TGT_PKG_NAME ] && rm -f "$DEST_DIR"$TGT_PKG_NAME
cd $pkgdir && make_sum_check -g "." -o $FILES_SHA && $TAR -cpf ""$DEST_DIR"$TGT_PKG_NAME" --zstd $COMPRESS_AS .
if [[ ! -z $PKG_HASH && $PKG_HASH = "yes" ]]; then 
if [ -f "$DEST_DIR"$TGT_PKG_NAME ] && ( file "$DEST_DIR"$TGT_PKG_NAME 2>/dev/null | grep 'Zstandard compressed' 1>/dev/null ); then
cd $DEST_DIR && make_sum_check -g "$TGT_PKG_NAME" -o "$PKG_SHA"; fi; fi
fi;    rm -rf $TMP/$pkgdir_rm; rm -rf $TMP/$spkgdir; [ -f $TMPFILE ] && rm -f $TMPFILE; sleep 0.27


if [[ -z "$DIALOG" || (( "$DIALOG" != "off" && "$DIALOG" == "on" )) ]]; then
if [[ (( -z "$STDOUT_MODE" || ! "$STDOUT_MODE" =~ "s" )) && (( -z "$PERM_STDOUT_MODE" || "$PERM_STDOUT_MODE" != "y" )) ]]; then
if [[ "$(date +"%F")" == "$start_day" ]]; then   local end_time="$(date +"%s")"
local timer="$(date -u -d "0 $end_time sec - $start_time sec" +"%Hh:%Mm:%Ss"|tr ':' ' ')"
                            for time_segment in $timer; do
                              if [[ ! "$time_segment" =~ ^00 ]]
                              then
                              if [[ "${time_segment:0:1}" = 0 ]]
                              then  build_time+=("${time_segment:1}")
                              else  build_time+=("$time_segment")
                              fi
                              fi
                            done
fi

# ceci verrouille un seul nombre de la variable RANDOM pour tout les tests
# sinon vous aurez une variable RANDOM differente pour chaque test
# l'idee c'est d'avoir le meme resultat mais vari souvent. plutot de varier tout le temps
# c'est pourquoi certains dialogues sont redondants (desactivable avec l'option -q)
local RANDOM="$RANDOM"

while true; do
[[ "$RANDOM" =~ ^"9" && "$RANDOM" =~ "2" ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "8" && "$RANDOM" =~ "1"$ ]] && printf "\v\v\v\e[90mle paquet \e[0m\e[2m$TGT_PKG_NAME\e[0m\e[90m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"9" && "$RANDOM" =~ "0" ]] && printf "\v\v\vle paquet \e[94m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ ^"9" ]] && printf "\v\v\v\e[90mle paquet \e[0m\e[2m$TGT_PKG_NAME\e[0m\e[90m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"2" && "$RANDOM" =~ "2" && "$RANDOM" =~ "3" ]] && printf "\v\v\vtout est ok,%2s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "3"$ && ! "$RANDOM" =~ "7" ]] && printf "\v\v\v$TGT_PKG_NAME: ok\v\n***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "5"$ && ! "$RANDOM" =~ "0" ]] && printf "\v\v\vle paquet $TGT_PKG_NAME a "$e_acute"t"$e_acute" cr"$e_acute$e_acute" avec succ"$e_grave"s\v\n%15s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ ^"2" && "$RANDOM" =~ "2" ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a "$e_acute"t"$e_acute" cr"$e_acute$e_acute" avec succ"$e_grave"s\v\n" && break
[[ "$RANDOM" =~ ^"8" || "$RANDOM" =~ ^"6" ]] && [[ "$RANDOM" =~ "8"$ || "$RANDOM" =~ "5"$ ]] &&  printf "\v\v\vfait\v\n" && break
[[ "$RANDOM" =~ "1"$ && "$RANDOM" =~ "6" ]] && printf "\v\v\v<<<%1sfait, $TEXT12%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "42"$ ]] && printf "\v\v\v<<<%1sfait, dur"$e_acute"e de compilation%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "7"$ ]] && printf "\v\v\vfait\v\n" && break
[[ "$RANDOM" =~ ^"3" ]] && [[ "$RANDOM" =~ "0" && "$RANDOM" =~ "2" ]] && printf "\v\v\v\e[90mtout est \e[0m\e[2mok\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"3" ]] && printf "\v\v\vle paquet \e[94m$pkgname\e[0m a "$e_acute"t"$e_acute" cr"$e_acute""$e_acute" avec succ"$e_grave"s\v\n%3s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ ^"4" && "$RANDOM" =~ "4" ]] && printf "\v\v\v\e[94mfait\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"1" && "$RANDOM" =~ "2"$ ]] && printf "\v\v\v\e[90mpaquet cr"$e_acute$e_acute": \e[0m\e[2m$TGT_PKG_NAME\e[0m\v\n" && break
[[ "$RANDOM" =~ ^"7" && "$RANDOM" =~ "4" ]] && printf "\v\v\vpaquet compil"$e_acute" avec succ"$e_gave"s\v\n%1s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "5" && "$RANDOM" =~ "8" ]] && printf "\v\v\v\e[90mpaquet cr"$e_acute$e_acute": \e[0m\e[2m$TGT_PKG_NAME\e[0m\n\e[90men%9s:%1s\e[0m\e[2m$(cat <<< "${build_time[@]}")\e[0m\v\n" && break
[[ "$RANDOM" =~ "06"$ ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%11s<<<%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "0" && "$RANDOM" =~ "5" ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%8s<<<%1s$TEXT12%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "9" && ! "$RANDOM" =~ "2" ]] && printf "\v\v\vfait\v\n" && break
[[ "$RANDOM" =~ ^"6" ]] && printf "\v\v\vle paquet \e[94m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n" && break
[[ "$RANDOM" =~ ^"1" && "$RANDOM" =~ "1" ]] && printf "\v\v\vle paquet \e[94m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n" && break
[[ "$RANDOM" =~ ^"5" ]] && printf "\v\v\vtout est ok,%2s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "0"$ ]] && printf "\v\v\vcompilation de \e[36m$TGT_PKG_NAME\e[0m r"$e_acute"ussie\v\n" && break
[[ "$RANDOM" =~ "2"$ ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n" && break
[[ "$RANDOM" =~ "4"$ ]] && printf "\v\v\vtout est ok\v\n%1s<<<%1sdur"$e_acute"e de compilation,%1s$(cat <<< "${build_time[@]}")%1s>>>\v\n" && break
[[ "$RANDOM" =~ "8"$ ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n%10s***%1s"$TEXT11"%1s$(cat <<< "${build_time[@]}")%1s***\v\n" && break
[[ "$RANDOM" =~ "1"$ ]] && printf "\v\v\vfait\v\n" && break
[[ "$RANDOM" =~ "6"$ ]] && printf "\v\v\vle paquet \e[92m$TGT_PKG_NAME\e[0m a bien "$e_acute"t"$e_acute" cr"$e_acute$e_acute"\v\n" && break
[[ "$RANDOM" =~ ^"7" && "$RANDOM" =~ "7" ]] && printf "\v\v\vle paquet \e[95m$TGT_PKG_NAME\e[0m a "$e_acute"t"$e_acute" cr"$e_acute$e_acute" avec succ"$e_grave"s\v\n" && break
[[ "$RANDOM" =~ "5"$ && "$RANDOM" =~ [7-9] ]] && printf "\v\v\vfait\v\n" && break
printf "\v\v\v\e[90mpaquet cr"$e_acute$e_acute": \e[0m\e[2m$TGT_PKG_NAME\e[0m\n\e[90men%9s:%1s\e[0m\e[2m$(cat <<< "${build_time[@]}")\e[0m\v\n" && break
done; if (export -p | grep -q PKG_SRC); then [[ "$RANDOM" =~ "1"$ || "$RANDOM" =~ ^"2" || "$RANDOM" =~ "8" ]] && printf "\e[90mN'oubliez pas de d"$e_acute"sinitialiser la variable 'PKG_SRC'\e[0m\v\n"; fi
fi
fi
if [[ "$INT_MODE" != on && "$INT_MODE" != y && "$INT_MODE" != yes ]]; then
if [[ -n $NOEXIT && $NOEXIT = y ]]; then
   if [ -z "$DEST_DIR" ]
    then
     export PKG_FILE="$BDIR/$TGT_PKG_NAME"
    else
     export PKG_FILE=""$DEST_DIR"$TGT_PKG_NAME"
   fi
else
 [[ -n "$PERM_STDOUT_MODE" && "$PERM_STDOUT_MODE" = "y" ]] || exit $OKCODE
fi
else
printf "%1s\e[2mtouche [Entrer] simple pour 'oui'\e[0m\n\n"
      case $RANDOM in
          5*8* | 2*6* | *3*0*0* | 6*7*1* | *7*3*4 | 1*0*1* | *0*0 | *1*6* | *5*7* )
              read -p " Proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') l'installation ? (o/n) : " REP ;;        
          *)  read -p " Voulez-vous installer le paquet ? (o/n) : " REP
      esac
case $REP in [nN]) exit $OKCODE ;; [oO]|[yY]|oui|yes|'') ;; *) exit $ERCODE ;; esac; printf "%s\n"
PKG_FILE="$BDIR/$TGT_PKG_NAME" BUILDFILE="$OLDBUILDFILE"  BIMODE=y
make_install $PKG_FILE && exit $OKCODE
fi
}





make_install () {
# certains dialogues marchent mieux si la variable RANDOM existe
# peut etre retirer si RANDOM sera toujours disponible
local RANDOM=${RANDOM:-$(shuf -i 1-100000 -n 1)}
#################################################################
local ERCODE=8; if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
if [[ $BIMODE ]]; then printf "ne peut proc"$e_acute"der "$a_grave" l'installation permission non accord"$e_acute"e\n"; exit $ERCODE
else printf "%1svous devez "$e_circumflex"tre root pour ex"$e_acute"cuter cette commande\n"; exit $ERCODE; fi fi
local TMPFILE=$(mktemp $TMP/tif.XXXXXX); [[ -n "$BIMODE" && "$BIMODE" == y ]] && set +e
[[ -z "$2" ]] && check_dtb; if [[ -n "$1" ]]; then if [[ -e "$1" ]]; then
  if ! ( test -f "$1" && file "$1" 2>/dev/null | grep -q 'Zstandard compressed data' && tar tf "$1" | grep -q "$BUILDFILE" )
  then  printf "\e[91merreur:\e[0m  impossible d'initialiser le paquet\n\e[90m '$1' ne ressemble pas "$a_grave" un paquet.\e[0m\n"
  ( test -n "$(ls "$TMP" | sed -n '/\(tif.*\)/p')" ) && find "$TMP" -depth -name 'tif*' -type f -delete
  exit $ERCODE; fi else printf "\e[91merreur:\e[0m '$1' non trouv"$e_acute"\n"; exit $ERCODE; fi
  else printf "\e[91merreur:\e[0m indiquer un paquet "$a_grave" installer\n"; exit $ERCODE; fi
ipc_tool -L
local EMULATED_TERM="$([[ "$(tty)" = '/dev/pts/'* ]] && printf '1')"
#### supprimez la commande ci-dessous si vous ne voulez pas l'effacement du terminal
#### lors d'un processus d'installation << simple >> [ne s'execute pas en tty (login shell)]
if ! [[ $INT_MODE || $BIMODE || $NOEXIT || ! $FIRST_INIT ]]; then [[ $EMULATED_TERM ]] && printf '\e[2J\e[H'; fi
printf "\e[1msspm (install)\e[0m\nOutil d'installation de paquets compatibles\e[0m\n"
[[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
################ verification des repertoires requis
## on s'assure que ces repertoires sont presents dans ce "root" ou "le root distant si indique" 
#### (ici le "root" dont nous parlons est la racine de l'environnement ou est execute sspm;
####  et le "root distant" qui le repertoire ou point de montage du futur systeme en construction)
## NB: si vous construisez un systeme on suppose que le script est execute 
######### dans un environnement chroote ce qui est pour le script sa racine voir ==> "sspm info"
                 if [[ -z "$2" ]]; then
                     if [ ! -d "$PKGDIR/database" ]; then
                     mkdir -p "$PKGDIR/database"
                     if [ $? -ne 0 ]; then
                     printf "\e[91m==> ERREUR:  \e[0mimpossible de cr"$e_acute"er le r"$e_acute"pertoire '$PKGDIR/database'\n"
                     printf "\e[90massurez-vous qu'il existe, ce r"$e_acute"pertoire est util"$e_acute" pour installer certains fichiers.\e[0m\n"
                     exit $ERCODE
                     fi
                     fi
                  else
                  if [ ! -d "$2" ]; then
                  printf "\nle r"$e_acute"pertoire '$2' n'existe pas\n\n"
                  read -p "voulez-vous cr$(printf '\xc3\xa9')er ce r$(printf '\xc3\xa9')rertoire ? (o/n) " REP
                  case $REP in  [oO]|'') ;; [nN]|*) find $TMP -iname tif.* -delete; exit ;; esac;  fi
                     [[ "$2" =~ /$ ]] && local PKGDIR=""${2%?}"$PKGDIR" || local PKGDIR=""$2"$PKGDIR"
                     local DTBFILE0="$PKGDIR/database/$LOGFILE"; local DTBFILE1="$PKGDIR/database/$PKG_DTB"
                     if [ ! -d "$PKGDIR/database" ]; then
                     mkdir -p "$PKGDIR/database" &>/dev/null
                     if [ $? -ne 0 ]; then
                     printf "erreur: ne pe pas cr"$e_acute"er le r"$e_acute"pertoire '$PKGDIR/database'\n"
                     exit $ERCODE
                     fi
                     fi
                  fi


################ Dialogue d'installation
local PKG_NAME=$(tar xf $1 "./$BUILDFILE" -O 2>/dev/null | grep "pkgname=" | cut -d "=" -f2 | tr -d "\"'")
if [[ $PKG_NAME ]]; then
local PKG_VER=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgver=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_REV=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgrev=" | cut -d "=" -f2 | tr -d "\"'")
else local BUILDFILE=$(tar tf $1 | grep "$BUILDFILE"); local BUILDFILE=${BUILDFILE#./}
local PKG_NAME=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgname=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_VER=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgver=" | cut -d "=" -f2 | tr -d "\"'")
local PKG_REV=$(tar xf $1 "./$BUILDFILE" -O | grep "pkgrev=" | cut -d "=" -f2 | tr -d "\"'"); fi
if [ -f "$DTBFILE1" ]; then if grep -q "^[[:punct:]]$PKG_NAME[[:punct:]][[:punct:]][[:punct:]]" $DTBFILE1; then
local LINE="$(sed -n -e "/\(^{$PKG_NAME}.{\)/p" $DTBFILE1|rev|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f1\
|sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g')"
local INSTALLED_PKG_NAME="$(cut -d' ' -f1 <<< $LINE)"  INSTALLED_PKG_VER="$(cut -d' ' -f2 <<< $LINE)"  INSTALLED_PKG_REV="$(cut -d' ' -f3 <<< $LINE)"
if [[ "$PKG_VER" == "$INSTALLED_PKG_VER" ]]
then if [[ "$PKG_REV" == "$INSTALLED_PKG_REV" ]]
     then
     printf "\n\nAvertissement: $PKG_NAME-$PKG_VER-$PKG_REV existe d"$e_acute"j"$a_grave" sous la m"$e_circumflex"me version\v\n"
     read -p "voulez-vous r$(printf '\xc3\xa9')installer le paquet ? (o/n) " REP
     case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n' ; exit ;; esac
     else
  if [[ $PKG_REV > $INSTALLED_PKG_REV ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n \e[2mINSTALL"$E_acute"%5s:%2s\e[0m\e[3m$INSTALLED_PKG_NAME \e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n \e[2m"$A_grave" INSTALLER%2s:%2s\e[0m\e[3m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    ''|*) printf "\n\n INSTALL"$E_acute"%5s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n "$A_grave" INSTALLER%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    esac else printf "\n\n INSTALL"$E_acute"%5s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n "$A_grave" INSTALLER%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n\n"
    fi; read -p "faut-il proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') la mise $(printf '\xc3\xa0') jour ? (o/n) " REP
    case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete ; printf '\n' && exit ;; esac
  elif [[ $PKG_REV < $INSTALLED_PKG_REV ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n \e[2mINSTALL"$E_acute"%5s:%2s\e[0m\e[3m$INSTALLED_PKG_NAME \e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n \e[2m"$A_grave" INSTALLER%2s:%2s\e[0m\e[3m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    ''|*) printf "\n\n INSTALL"$E_acute"%5s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n "$A_grave" INSTALLER%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    esac else printf "\n\n INSTALL"$E_acute"%5s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n "$A_grave" INSTALLER%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n"
    fi; printf "\e[90mla r"$e_acute"trogradation d'un paquet peut\ns"$e_acute"rieusement endommager votre syst"$e_grave"me\e[0m\n\n\n"
    read -p "proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') l'installation ? (o/n) " REP
    case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  fi
    fi
elif [[ "$PKG_VER" != "$INSTALLED_PKG_VER" ]]
then
  if [[ $PKG_VER > $INSTALLED_PKG_VER ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n \e[2mINSTALL"$E_acute"%5s:%2s\e[0m\e[3m$INSTALLED_PKG_NAME \e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n \e[2m"$A_grave" INSTALLER%2s:%2s\e[0m\e[3m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    ''|*) printf "\n\n INSTALL"$E_acute"%5s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n "$A_grave" INSTALLER%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n\n" ;;
    esac else printf "\n\n INSTALL"$E_acute"%5s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n "$A_grave" INSTALLER%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n\n"
    fi; read -p "proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') la mise $(printf '\xc3\xa0') jour ? (o/n) " REP
    case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  elif [[ $PKG_VER < $INSTALLED_PKG_VER ]]; then
    if [[ $EMULATED_TERM ]]; then
    case $RANDOM in
    *4*0*9*|*3*7*8*|*12*0|*9*6|*5*6|*0*1*7|6*8*)
    printf "\n\n \e[2mINSTALL"$E_acute"%5s:%2s\e[0m\e[3m$INSTALLED_PKG_NAME \e[94mv$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n \e[2m"$A_grave" INSTALLER%2s:%2s\e[0m\e[3m$PKG_NAME \e[94mv$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    ''|*) printf "\n\n INSTALL"$E_acute"%5s:%2s\e[3m$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\e[0m\n "$A_grave" INSTALLER%2s:%2s\e[3m$PKG_NAME v$PKG_VER-$PKG_REV\e[0m\n\n" ;;
    esac else printf "\n\n INSTALL"$E_acute"%5s:%2s$INSTALLED_PKG_NAME v$INSTALLED_PKG_VER-$INSTALLED_PKG_REV\n "$A_grave" INSTALLER%2s:%2s$PKG_NAME v$PKG_VER-$PKG_REV\n\n"
    fi; printf "\e[90mla r"$e_acute"trogradation d'un paquet peut\ns"$e_acute"rieusement endommager votre syst"$e_grave"me\e[0m\n\n\n"
    read -p "proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') l'installation ? (o/n) " REP
    case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac
  fi
fi
else printf "\n\nPaquet%3s$PKG_NAME-$PKG_VER-$PKG_REV\n\n"
read -p "proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') l'installation ? (o/n) " REP
case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac fi
else printf "\n\nPaquet%3s$PKG_NAME-$PKG_VER-$PKG_REV\n\n"
read -p "proc$(printf '\xc3\xa9')der $(printf '\xc3\xa0') l'installation ? (o/n) " REP
case $REP in  [oO]|'') ;;  [nN]|*) find $TMP -iname tif.* -delete; printf '\n'; exit ;; esac fi




printf "\n\e[36minitialisation du fakeroot\e[0m\n"
if [ -d $FAKEROOT ]; then
rm -rf $FAKEROOT && mkdir $FAKEROOT && mkdir $FAKEROOT/temproot
else mkdir $FAKEROOT && mkdir $FAKEROOT/temproot; fi
tar xf "$1" -C $FAKEROOT/temproot; cd $FAKEROOT/temproot
printf "\e[36mv"$e_acute"rification de l'int"$e_acute"gralit"$e_acute" du paquet\e[0m\n"; sleep 0.67
make_sum_check -c "." -i "$FILES_SHA" && rm -rf $TMP/msc.*;
find -L . \( -perm 711 -o -perm 555 -o -perm 777 -o -perm 511 -o -perm 775 -o -perm 750 \) -exec chmod 755 {} &>/dev/null \; \
       -o \( -perm 444 -o -perm 666 -o -perm 664 -o -perm 640 -o -perm 400 -o -perm 600 -o -perm 440 \) -exec chmod 644 {} &>/dev/null \;


## recherche du nom, la version, les repertoires d'installation du paquet et autres
###### types de paquet : base --> base , opt --> optionnel , add --> additionnel , [ si var vide ] --> other
## si vous construisez un systeme, ici "base" fait reference aux paquets minimum requis pour la creation
## et l'utilisation d'un systeme linux. n'hesitez pas a indiquer comme base ces premiers paquets.
#### NB: cette version n'a aucun mecanisme de verification des dependances
##### definir le type de paquet n'a aucun effet si ce n'est que de lister les paquets
sleep 0.20; printf "\e[36mCollecte d'informations sur le paquet ...\e[0m\n"
local pkgname=$(grep --binary-files=text -i "pkgname=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgver=$(grep --binary-files=text -i "pkgver=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgrev=$(grep --binary-files=text -i "pkgrev=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgbid=$(grep --binary-files=text -i "pkgbid=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkg_url=$(grep --binary-files=text -i ^"url=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkgdesc=$(grep --binary-files=text -i "pkgdesc=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local depends=$(grep --binary-files=text -i ^"depends=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local pkggroup=$(grep --binary-files=text -i ^"groups=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local packager=$(grep --binary-files=text -i "packager=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'" | tr ' ' '<>')
local buildtime=$(grep --binary-files=text -i "buildtime=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local builddate=$(grep --binary-files=text -i "builddate=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
local makedepend=$(grep --binary-files=text -i "makedepend=" $BUILDFILE | cut -d "=" -f2 | tr -d "\"'")
###########################################################
[[ -n $pkgbid && $pkgbid = 1 ]] && chown -R root:root .
### si pour quelconque raisons vous changez l'emplacement du repertoire "fakeroot" assurez-vous
###### de modifiez le chiffre dans cette section '| cut -c "23"- |' de la commande suivante car;
################ ce dernier correspand aux nombres de caracteres a ignores (ou dossiers parents)
#################### pour que "temproot" soit la fausse 'racine' pour les besoins de la commande
find . -type f,l -exec realpath {} \; | sort -u | cut -c 23- | sed '/'$BUILDFILE'\|'$PKG_INSTALL'\|'$FILES_SHA'/d' | sed '/^$/d' > $FAKEROOT/realpath.bck
###### le fichier temporaire 'realpath' ici illustre la trace des fichiers du paquet
############ apres leur installation.
###### pour ces commandes il ya peut-etre d'autres manieres de proceder plus simple
###### mais faut d'abord les trouvees, bref
###### On classe les informations trouvees sur le paquet
local fonction_name=""$pkgname"_pth() {    ######################### paquet $pkgname"
          printf "%s\n" "$fonction_name" > $FAKEROOT/realpath && \
          printf "%s\n" "printf '$COMMENT0 $pkgname\n$COMMENT1 $COMMENT6\n'"  >> $FAKEROOT/realpath
find . -type d \! -name "." -print0 | while IFS= read -r -d '' line; do
parentdir_name="$(basename $line)"
if [[ -n $parentdir_name && ! "${sysdirs[@]}" =~ $parentdir_name ]]; then
printf "%s\n" "printf '  \e[96m$line\e[0m\n'" | sed 's/.\//\//' >> $FAKEROOT/realpath && continue
else continue; fi; done; printf "%s\n" "printf '$COMMENT2 $COMMENT6\n'" >> $FAKEROOT/realpath
while IFS= read -r line; do
## certains paquets comme 'ruby' ont des fichiers contenant des caracteres difficiles a manipuler avec la commande printf
#################### vous pouvez ignorer ces avertissements (qui n'ont aucun impact sur le systeme) de la commande printf 
#################### si vous lister l'historique d'un de ces paquets
printf "%s\n" "printf '  \e[96m$(basename $line)\t\t\e[90m$SYMBOLE\e[0m  \e[90m$(dirname $line)\e[0m\n'" >> $FAKEROOT/realpath
done < $FAKEROOT/realpath.bck
COUNT() { printf $#; }; shopt -s nullglob dotglob
local ALL_FOUND=$(COUNT $(printf "%s" "$(find . -type f,l,d \! -iname "." \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" -o -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "pkgconfig" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))"))
local ALL_FOUND_DIRS=$(COUNT $(printf "%s" "$(find . -type d \! -iname "." \! \( -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "pkgconfig" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))"))
local ALL_FOUND_FILES=$(COUNT $(printf "%s" "$(find . -type f,l \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" \))"))
local PKG_SIZE="$(printf "%s" "$(find . -type f,l,d \! -iname "." \! \( -iname "$FILES_SHA" -o -iname "$PKG_INSTALL" -o -iname "$BUILDFILE" -o -iname "bin" -o -iname "boot" -o -iname "color" -o -iname "cache" -o -iname "dev" -o -iname "etc" -o -iname "lib" -o -iname "lib64" -o -iname "home" -o -iname "mnt" -o -iname "opt" -o -iname "srv" -o -iname "sbin" -o -iname "usr" -o -iname "var" -o -iname "sysconfig" -o -iname "firmware" -o -iname "media" -o -iname "floppy" -o -iname "cdrom" -o -iname "include" -o -iname "local" -o -iname "locate" -o -iname "log" -o -iname "mail" -o -iname "opt" -o -iname "pkgconfig" -o -iname "proc" -o -iname "spool" -o -iname "share" -o -iname "sys" -o -iname "dict" -o -iname "doc" -o -iname "info" -o -iname "man" -o -iname "man1" -o -iname "man2" -o -iname "man3" -o -iname "man4" -o -iname "man5" -o -iname "man6" -o -iname "man7" -o -iname "man8" -o -iname "misc" -o -iname "run" -o -iname "root" -o -iname "tmp" -o -iname "lock" -o -iname "terminfo" -o -iname "zoneinfo" \))" | du -cah | tail -1 | cut -f 1)B"
shopt -u nullglob dotglob
printf "%s\n" "printf '$COMMENT10[\e[91m$PKG_SIZE\e[0m]; $COMMENT9 $COMMENT5[\e[91m$ALL_FOUND\e[0m], $COMMENT8 $COMMENT3[\e[91m$ALL_FOUND_DIRS\e[0m] $COMMENT7 $COMMENT4[\e[91m$ALL_FOUND_FILES\e[0m]\n'" >> $FAKEROOT/realpath && printf "}  ########################## paquet $pkgname" >> $FAKEROOT/realpath && rm -f $FAKEROOT/realpath.bck;


## le groupe/type de paquet
if [[ -n "$pkggroup" ]]; then 
 if [[ "$pkggroup" = base || "$pkggroup" = add || "$pkggroup" = opt || "$pkggroup" = other ]]; then
    local pkggroup=$(tr -d "\"'" <<< "$pkggroup")
 else
     printf "\n\e[91merreur:\e[0m  groupe non reconnu\n"
     printf "\e[2mindiquez un groupe valide ou laissez vide 'groups'\n"
     printf "\e[2mdans (pkgbuild) ou 'PKG_GROUP' avant la compilation du paquet\n"
     printf "\e[2mtapez 'sspm infos' pour plus d'informations\e[0m\n"
     exit $ERCODE
 fi
else
 local pkggroup=other
fi


#### installation, verification, activation des bibliotheques et reparation des liens symboliques rompus
     
#### si indiquer on ignore ce repertoire et son contenu     
             if [[ "${EXCLUDE:-$IGNORE}" ]]
                then local EXCLUDE_DIR="${EXCLUDE:-$IGNORE}"
                else [[ "$NOT_TRACE_PATH" ]] && local EXCLUDE_DIR="$NOT_TRACE_PATH"
             fi
             if [[ "$EXCLUDE_DIR" ]]; then
             printf "v"$e_acute"rification du chemin "$a_grave" exclure:"
             if [[ -d "$EXCLUDE_DIR" ]]; then printf " trouv"$e_acute"\n"
             [[ "$EXCLUDE_DIR" =~ /$ ]] || EXCLUDE_DIR=""$EXCLUDE_DIR"/"
             else printf "\n\e[91m===> ERREUR:\e[0m r"$e_acute"pertoire '$EXCLUDE_DIR' non trouv"$e_acute"\n\n"
             exit $ERCODE; fi fi

mv "$FILES_SHA" "$BUILDFILE" "$PKG_INSTALL" $FAKEROOT


if [ -z "$2" ]; then
check_dtb -c -i
tar -cpf - ./* | (cd $LOCALROOT && tar --no-overwrite-dir --keep-directory-symlink -xvpf -) | sed 's/^.//g; /\/$/d'
printf "lecture du fichier de configuration\n"
if [[ "$(cat $FAKEROOT/$PKG_INSTALL | wc -l)" -gt "2" ]]; then
printf "cr"$e_acute"ation des liens symboliques\n"
. $FAKEROOT/$PKG_INSTALL
fi
[ -x "/sbin/ldconfig" ] && /sbin/ldconfig &>/dev/null
sleep 0.52; printf "\e[96mv"$e_acute"rification des liens symboliques\e[0m\n"; sleep 0.48
if [[ -z "$EXCLUDE_DIR" ]]; then
find $LOCALROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path \
'/tmp/*' -o -path '/dev/*' -o -path '/run/*' -o -path '/home/*' -o -path '/root/*' \) -delete
else
find $LOCALROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/tmp/*' -o -path \
'/dev/*' -o -path '/run/*' -o -path '/home/*' -o -path '/root/*' -o -path ''$EXCLUDE_DIR'*' \) -delete
fi
else
tar -cpf - ./* | (tar --no-overwrite-dir --keep-directory-symlink -xvpf - -C "$2") | sed 's/^.//g'
sleep 0.52; printf "\e[96mv"$e_acute"rification des liens symboliques\e[0m\n"; sleep 0.48
[ -x "$2/sbin/ldconfig" ] &&  $2/sbin/ldconfig
fi

dtb_ercode=1
[[ "$LC_TIME" = POSIX ]] || export LC_TIME=POSIX
local DATE="$(date +%D)" TIME="$(date "+%I:%M %p")"
local EPOCH="$(date --date="$builddate $buildtime" +%s)"

if [[ -f "$DTBFILE0" ]]; then
[ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0
cp $DTBFILE0 "$DTBFILE0.bck"
if $DTBFILE0 "$pkgname"_pth &>/dev/null; then
sed -i "/"$pkgname"_pth/,/paquet "$pkgname"/d ; /^$/d" $DTBFILE0
else
$DTBFILE0 "$pkgname"_pth 2>&1
   if [[ $? != $dtb_ercode ]]; then
    printf "\n%1sune \e[91merreur\e[0m est survenue lors de la lecture de la base de donn"$e_acute"es\n"
    printf "%1scela n'affecte pas le fonctionnement du syst"$e_grave"me\n\n"
            printf "Voulez-vous :\n\n%4s(a)%4stenter une r"$e_acute"paration automatique?\n"
            printf "%4s(r)%4srestaurer "$a_grave" la derni"$e_grave"re sauvegarde?\n"
            printf "%4s(s)%4ssortir?\n\n\n" ; read -p ":: " REP
            case $REP in [aA]) restore_type -b ;; [rR]) restore_type -r ;; [sS]|*) exit ;; esac
   exit
   fi
fi
sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0; sed -i '/^$/d' $DTBFILE0; sed -i '/^[[:space:]]*$/d' $DTBFILE0
cat $FAKEROOT/realpath >> $DTBFILE0; sed -i 's/^}.*/&\n\n/' $DTBFILE0

                                         if [[ "$(grep --binary-files=text $pkgname"_pth" $DTBFILE0|cut -d'_' -f1|wc -w)" -gt 1 ]]; then
                                            sed -i "/$pkgname.*_pth/I,/}.*$pkgname/I d ; /^$/d" $DTBFILE0
                                            cat $FAKEROOT/realpath >> $DTBFILE0
                                            sed -i 's/^}.*/&\n\n/' $DTBFILE0
                                         fi

printf '%b\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n' >> $DTBFILE0
local SPCLINE="$(( $(grep -n '^#-*-#$' $DTBFILE0 |tail -1|cut -f1 -d':') + 1 ))"
local LINE_STAT="$(head -n $SPCLINE $DTBFILE0|tail -1)"
[[ "$LINE_STAT" =~ ^[[:space:]]+$ ]] || sed -i -e "$(( $SPCLINE - 1 ))a \ " $DTBFILE0
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE0
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE0
[ $(stat -c "%a" "$DTBFILE0") != "755" ] && chmod 755 $DTBFILE0; chattr +i $DTBFILE0; rm -f "$DTBFILE0.bck"
else
printf "#-----------------------------------------------------------------------------------------------#\n\
#%1s$LOGFILE%83s#\n#%1sDescription: sspm installation logfile%56s#\n#%1slast edit: $DATE at $TIME%43sDo not edit by hand%1s#\n\
#-----------------------------------------------------------------------------------------------#\n\n" > $DTBFILE0 
cat $FAKEROOT/realpath >> $DTBFILE0
printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n' >> $DTBFILE0
chmod 755 $DTBFILE0
chattr +i $DTBFILE0
fi
###########################################################    div infos
if [ -f "$DTBFILE1" ]; then
[ ! -w "$DTBFILE1" ] && chattr -i $DTBFILE1
cp $DTBFILE1 "$DTBFILE1.bck"; printf "\e[96mmise "$a_grave" jour de la base de donn"$e_acute"es\e[0m\n"
if grep -q "^[[:punct:]]$pkgname" $DTBFILE1; then
sed -i "/^[[:punct:]]$pkgname\|^.*"$pkgname"_desc/d ; /^[[:space:]]*$/d" $DTBFILE1
else sed -i '/^[[:space:]]*$/d' $DTBFILE1; fi
printf '%b ' "{$pkgname}.{$pkgver}.($pkgrev).{$ARCH}.{$EPOCH}.{$pkggroup}.{$PKG_SIZE}.{$packager}.${depends[@]}${makedepend[@]}\n" >> $DTBFILE1
printf ""$pkgname"_desc<$pkgdesc>url<$pkg_url>\n" >> $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
sed -i -e "$(grep -n '^###*#$' $DTBFILE1 |tail -1|cut -f1 -d':')a \ " $DTBFILE1
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE1
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE1
[ $(stat -c "%a" "$DTBFILE1") != "755" ] && chmod 755 $DTBFILE1; chattr +i $DTBFILE1; rm -f "$DTBFILE1.bck"
[[ -z "$2" ]] && check_dtb -g -f
else
printf "#####################################################################################################\n\
#%2sGenerated by sspm%80s#\n#%2s---------------------------%70s#\n#%2slast edit: $DATE  $TIME%48sDo not edit by hand%1s#\n\
#####################################################################################################\n\n" > $DTBFILE1
printf '%b ' "{$pkgname}.{$pkgver}.($pkgrev).{$ARCH}.{$EPOCH}.{$pkggroup}.{$PKG_SIZE}.{$packager}.${depends[@]}${makedepend[@]}\n" >> $DTBFILE1
printf ""$pkgname"_desc<$pkgdesc>url<$pkg_url>\n" >> $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
chmod 755 $DTBFILE1; chattr +i $DTBFILE1; [[ -z "$2" ]] && check_dtb -g
fi

find $TMP -iname tif.* -delete
                rm -rf $FAKEROOT
                  ipc_tool --break
                       printf '\n'
[ -n $BIMODE ] && unset BIMODE
[ -n $M_CHOWN ] && unset M_CHOWN
}






remove_pkg () {
## de base la base de donnees est protegee en ecriture,
## la logique veut que seul le proprietaire pourra modifier ces attributs. 
## si l'on est proprietaire ou qu'on peut s'attribuer ses droits continuer sinon erreur
##############################################################################################
[[ -n $DEBUG_MODE && $DEBUG_MODE = y ]] && set -x
check_dtb 1>/dev/null
if [[ (( ! -f "$DTBFILE0" || ! -f "$DTBFILE1" )) && $FIRST_INIT = "N" ]]; then
    case $RANDOM in  9*1|1*3*8*|*12*0|*6*2|4*3|*0*9*3|7*1*)
    printf "\e[91merreur fatale:\e[0m impossible de lire dans la base de donn"$e_acute"es\n"; exit $ERCODE ;;
    ''|*) printf "\e[91merreur fatale:\e[0m base de donn"$e_acute"es introuvable\n"; exit $ERCODE ;;
    esac
else
if [[ ! -f "$DTBFILE0" && ! -f "$DTBFILE1" ]]; then printf "aucun paquet install"$e_acute" avec $(basename $SCRIPTFILE)\n"; exit $ERCODE; fi
local DTB_OWNER="$([[ "$(stat  -c %u $DTBFILE0)" != "$(stat  -c %u $DTBFILE1)" ]] || printf "$(stat  -c %u $DTBFILE1)")"
if [[ "${EUID:-$(id -u)}" -ne "$DTB_OWNER" ]]; then
   if ! [[ -w $DTBFILE0 || -w $DTBFILE1 ]]; then 
   printf "$(basename $SCRIPTFILE): database: Permission non accord"$e_acute"e\n"
   exit $ERCODE
   fi
fi
fi
####################################################################
[[ "$LC_TIME" = POSIX ]] || export LC_TIME=POSIX
local DATE="$(date +%D)" TIME="$(date "+%I:%M %p")"
## detection des repertoires
             if [[ -n "$1" && "$#" = "1" ]]; then
             local ROOT="/"; local PKGDIR="$PKGDIR"; local DOCDIR="/usr/share/doc/"
             elif [[ -n "$2" && "$#" = "2" ]]; then
             [[ "$2" =~ /$ ]] && local ROOT="${2%?}" || local ROOT="$2"
             local DOCDIR="$ROOT/usr/share/doc/"; local PKGDIR="$ROOT"$PKGDIR
             else printf "\e[91merreur \e[0mparam"$e_grave"tre non reconnu\n"
             exit $ERCODE; fi
             ipc_tool -l
[[ "$2" ]] || check_dtb -c -r
if grep -q "^"$1"_pth" $DTBFILE0 && grep -q "^{$1}" $DTBFILE1; then
local LINE="$(sed -n -e "/\(^{$1}\)/p" $DTBFILE1)"
local LINE0="$(rev <<< "$LINE"|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f1|sed 's/[[:punct:]][[:punct:]][[:punct:]]/ /g; s/^[[:punct:]]\|[[:punct:]]$//g')"
local LINE1="$(rev <<< "$LINE"|sed 's/\((.}\)/( }/'|rev|cut -d' ' -f2-|sed 's/)(/) (/')"
printf "\e[36mRecherche des informations du paquet...\e[0m\n"; sleep 0.25
local PKG_NAME="$(cut -d' ' -f1 <<< $LINE0)"
local PKG_VER="$(cut -d' ' -f2 <<< $LINE0)"
local PKG_REV="$(cut -d' ' -f3 <<< $LINE0)"
local PKG_TYPE="$(cut -d' ' -f6 <<< $LINE0)"
local PKG_SIZE="$(cut -d' ' -f7 <<< $LINE0)"
local PKG_DEPEND=("$(cut -d')' -f1 <<< $LINE1|tr -d '()')")
local PKG_MAKE_DEPEND=("$(cut -d'(' -f3- <<< $LINE1|tr -d '()')")

                               while IFS= read -r LINE; do
                                if [[ -n "$LINE" && ! $LINE =~ ^"{$1" ]]; then
                                NAME="$(tr -d '{}' <<< "${LINE%%.*}")"  
                                MATCH="$(cut -d')' -f1 <<< "${LINE##*.}" | tr -d '()')"
                                for PKG in $MATCH; do [[ $PKG != "$1" || "${PKG_MAKE_DEPEND[@]}" =~ "$NAME" ]] || PKG_MAKE_DEPEND+=("$NAME"); done
			           else continue
                                fi
                               done <<< "$(grep ^'{.*)'$ $DTBFILE1 | grep "\<$1\>")"


## mais on peut toujours etablir une regle de base [ pour eviter les erreurs de debutants (: ]
## * vous ne pouvez desinstaller un paquet de type 'base' seulement si il n'est requit par aucun autre paquet 
## * pour un paquet de type 'add' etc... vous aurez un dialogue montrant les paquets sur lesquels il cree une dependance
##
## exemple: vous compilez 'sspm' par contre vous avez une erreur fatal: vous explicant que >= libfoo v1.5 manque
## laisser sspm, compilez libfoo en indiquant/ajoutant dans la variable makedepend=(anotherlib another-package sspm) du fichier 'pkgbuild'
## puis recompiler sspm en ajoutant 'libfoo' dans la variable depend=(libfoo another-package) du fichier 'pkgbuild'
## en procedant ainsi vous aurez tout de meme un bon resultat pour mieux gerer vos paquets
##
## pour l'instant sspm n'a pas encore de mecanisme pour gerer les dependances
##################################################################################################################################################
if [[ ${#PKG_MAKE_DEPEND[@]} -gt 0 ]]; then
local FOUND_PKGMAKE_DEPEND=()
for NAME in ${PKG_MAKE_DEPEND[@]}; do ( grep -q "^{$NAME}" $DTBFILE1) && local FOUND_PKGMAKE_DEPEND+=("$NAME"); done
if [[ ${#FOUND_PKGMAKE_DEPEND[@]} -gt 0 ]]; then
case $PKG_TYPE in
        base)
        repeat() { N=$(($(wc -c <<< "${FOUND_PKGMAKE_DEPEND[@]}") + 3)); printf -- "$1%.0s" $(seq 1 $N); }
        local words="$([[ ${#FOUND_PKGMAKE_DEPEND[@]} = 1 ]] && printf "ce paquet" || printf "tout ces paquets")"
        printf "\e[91merreur :\e[0m ce paquet est requis par :\n"
        printf "%b$(repeat -)\n| $(cat <<< ${FOUND_PKGMAKE_DEPEND[@]}) |\n$(repeat -)\n"
        printf "et a "$e_acute"t"$e_acute" indiqu"$e_acute" comme paquet '\e[1m\e[3mfondamental\e[0m'\n"
        printf "vous devez d"$e_acute"sinstaller $words\navant de d"$e_acute"sinstaller celui-ci\n\n"
        printf "$(basename $SCRIPTFILE): '$PKG_NAME' impossible de d"$e_acute"sinstaller ce paquet\n"
        exit $ERCODE        
        ;;
esac
fi

# certains dialogues marchent mieux si la variable RANDOM existe
# peut etre retirer si RANDOM sera toujours disponible
local RANDOM=${RANDOM:-$(shuf -i 1-100000 -n 1)}
#################################################################

local COLOR="$(
if [[ $RANDOM == [[:digit:]]5* ]]
 then printf '\\e[95m'
  elif [[ $RANDOM == 2* ]]
   then printf '\\e[32m'
    elif [[ $RANDOM == *0 ]]
     then printf '\\e[35m'
      elif [[ $RANDOM == *6*0* ]]
        then printf '\\e[33m'
          elif [[ $RANDOM == *1* ]]
            then printf '\\e[97m'
              elif [[ $RANDOM == 8* ]]
                then printf '\\e[93m'
                   elif [[ $RANDOM == *7 ]]
                      then printf '\\e[31m'
                        else printf '\\e[97m';fi)"
fi
printf "\n%5spaquet: "$PKG_NAME"  version ($PKG_VER) r"$e_acute"vision ($PKG_REV) \n%15stype '$PKG_TYPE' \n%15sles paquets qui en d"$e_acute"pendent:\n\
%14s\e[3m$COLOR$(cat <<< "${FOUND_PKGMAKE_DEPEND[@]}") \e[0m\n\n%10slib"$e_grave"re environ  $PKG_SIZE\n\n"


read -p "Voulez-vous d$(printf '\xc3\xa9')sinstaller ce paquet ? (o/n) " REP
case $REP in [oO]|'')  printf "\n" ;; [nN]|*) printf "\n" && exit ;; esac
else printf "sspm: '$1' non install"$e_acute"\n"; exit $ERCODE; fi
local FILES="$($DTBFILE0 "$1"_pth|sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"\
|sed '/'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|^'$COMMENT10.*$COMMENT9.*$COMMENT5'/d'\
|sed -e 's/\'$SYMBOLE'\|'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|'$COMMENT3'\|'$COMMENT4'\|'$COMMENT5'\|'$COMMENT6'\|'$COMMENT7'\b\|'$COMMENT8'\|\[[^]]*\]//g' \
| tr '\t' ' ')" 

             #### si indiquer on ignore ce repertoire et son contenu
             if [[ "${EXCLUDE:-$IGNORE}" ]]
                then local EXCLUDE_DIR="${EXCLUDE:-$IGNORE}"
                else [[ "$NOT_TRACE_PATH" ]] && local EXCLUDE_DIR="$NOT_TRACE_PATH"
             fi
             if [[ "$EXCLUDE_DIR" ]]; then
             printf "v"$e_acute"rification du chemin "$a_grave" exclure:"
             if [[ -d "$EXCLUDE_DIR" ]]; then printf " trouv"$e_acute"\n"
             [[ "$EXCLUDE_DIR" =~ /$ ]] || EXCLUDE_DIR=""$EXCLUDE_DIR"/"
             else printf "\n\e[91m===> ERREUR:\e[0m r"$e_acute"pertoire '$EXCLUDE_DIR' non trouv"$e_acute"\n\n"
             exit $ERCODE; fi fi
             ######  verification
             local PKG_DIRS=() PKG_FILES=()
             shopt -s extglob
             while IFS= read -r LINE; do
             local LINE="${LINE##*( )}"
             local LINE="${LINE%%*( )}"
             if [[ "$LINE" =~ ^/ && ! "${PKG_DIRS[@]}" =~ "$LINE" ]]
             then local PKG_DIRS+=("$LINE")
             else
                if [[ "$(wc -w <<< "$LINE")" = 2 ]]; then
                local PKG_FILE=""${LINE##* }"/"${LINE%% *}""
                [[ "${PKG_FILES[@]}" =~ "$PKG_FILE" ]] || local PKG_FILES+=("$PKG_FILE")
                [[ "${PKG_DIRS[@]}" =~ "${LINE##* }" ]] || local PKG_DIRS+=("${LINE##* }")
                else  local PKG_FILES+=("$LINE");  fi
             fi
             done <<< "$FILES"
             shopt -u extglob
             ###### supression du paquet
             local DTB_CONTENT="$(cat -s $DTBFILE0 | sed "/"$1"_pth/,/paquet "$1"/d" \
             | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g" \
             | sed '/^#\|'$COMMENT0'\|'$COMMENT1'\|'$COMMENT2'\|^.*'$COMMENT10.*$COMMENT9.*$COMMENT5'/d' \
             | sed -e 's/\'$SYMBOLE'\|'$COMMENT1'\|'$COMMENT2'\|'$COMMENT3'\|'$COMMENT4'\|'$COMMENT5'\|'$COMMENT6'\|\[[^]]*\]//g' | tr '\t\n' ' ')"
             rm -fv ${PKG_FILES[@]}  | tr -d "\"'" | sed 's/removed\| su.*$//g'
             for PKG_DIR in ${PKG_DIRS[@]}; do
             [[ "${sysdirs[@]}" =~ "$(basename "$PKG_DIR")" || "$DTB_CONTENT" =~ "$PKG_DIR" ]] && continue || rm -rf $PKG_DIR && printf "%s\n" "$PKG_DIR"
             done;   [[ -n "$(find "$DOCDIR" -name "$1*")" ]] && find "$DOCDIR" -name "$1*" -print0 | xargs -0 rm -rf
             #### verification des liens symboliques
             if [ -z "$2" ]; then
             if [ -z "$EXCLUDE_DIR" ]; then
             find $ROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/run/*' -o -path '/tmp/*' -o -path '/dev/*' -o -path '/home/*' -o -path '/root/*' \) -delete
             else
             find $ROOT -xtype l \! \( -path '/proc/*' -o -path '/sys/*' -o -path '/tmp/*' -o -path '/run/*' -o -path '/dev/*' -o -path '/home/*' -o -path '/root/*' -o -path ''$EXCLUDE_DIR'*' \) -delete
             fi
             fi

### mise a jour de la base de donnees
[ ! -w "$DTBFILE0" ] && chattr -i $DTBFILE0 && local PERM1=ro
cp $DTBFILE0 "$DTBFILE0.bck"
sed -i "/"$1"_pth/,/paquet "$1"/d" $DTBFILE0 && sed -i '/^$/d' $DTBFILE0
sed -i 's/^}.*/&\n\n/' $DTBFILE0; sed -i '/'"$PARSEID"'/i\\' $DTBFILE0
local SPCLINE="$(( $(grep -n '^#-*-#$' $DTBFILE0 |tail -1|cut -f1 -d':') + 1 ))"
local LINE_STAT="$(head -n $SPCLINE $DTBFILE0|tail -1)"
[[ "$LINE_STAT" =~ ^[[:space:]]+$ ]] || sed -i -e "$(( $SPCLINE - 1 ))a \ " $DTBFILE0
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE0
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE0
[ $(stat -c "%a" "$DTBFILE0") != "755" ] && chmod 755 $DTBFILE0
[[ -n "$PERM1" && "$PERM1" = "ro" ]] && chattr +i $DTBFILE0
rm -f "$DTBFILE0.bck"
[ ! -w "$DTBFILE1" ] && chattr -i "$DTBFILE1" && local PERM2=ro
cp $DTBFILE1 "$DTBFILE1.bck"
sed -i "/^[[:punct:]]"$1"\|^"$1"/d" $DTBFILE1 && sed -i '/^$/d' $DTBFILE1
sed -i '/^[[:space:]]*$/d' $DTBFILE1;  sed -i 's/^ \+//g' $DTBFILE1
sed -i -e "$(grep -n '^###*#$' $DTBFILE1 |tail -1|cut -f1 -d':')a \ " $DTBFILE1
sed -i 's|[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]/[[:digit:]][[:digit:]]|'$DATE'|g' $DTBFILE1
sed -i "s|[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]][[:space:]][[:alpha:]][[:alpha:]]|$TIME|g" $DTBFILE1
[ $(stat -c "%a" "$DTBFILE1") != "755" ] && chmod 755 $DTBFILE1
[[ -n "$PERM2" && "$PERM2" = "ro" ]] && chattr +i $DTBFILE1
rm -f "$DTBFILE1.bck"
[[ -z "$2" ]] && check_dtb -g -f
ipc_tool -s
printf "\n\e[90m%10spaquet d"$e_acute"sinstall"$e_acute"%10s\e[0m\n\n"
}


                           restore_type () {
                           ## ce outils tentera de reparer automatiquement la base de donnees avec les erreurs communes connues  
                           ## si cela echoue je vous invite a les resoudre manuellement.  "/tmp" etant le repertoire temporaire
                           ## la technique consite a isole la section contenant les erreurs a la fin du fichier,
                           ## afin que vous puissez l'inspecter facilement. (methode a tester)
                           ############################################################
                               case $1 in -b)
                               sleep 0.20; printf "\n\e[93mAvertissement:\e[0m cela peut prendre du temps\n\n";  sleep 0.70
                               printf "test de lecture de la base de donn"$e_acute"es%22s"
                               [[ -r "$DTBFILE0" && -r "$DTBFILE1" ]] && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[91mfailed\e[0m ]\n"
                               printf "d"$e_acute"tection du nombre de paquets install"$e_acute"s%10s"
                               local PKG_NAMES0=($(grep _pth "$DTBFILE0"|cut -d '_' -f1|tr '\n' ' '))
                               if [[ "${#PKG_NAMES0[@]}" -gt 0 ]]; then printf "[ ${#PKG_NAMES0[@]} ]%2s[ \e[92mok\e[0m ]\n"
                               else printf "[ \e[91mind"$e_acute"termin"$e_acute"\e[0m ]\n"; fi
                               printf "test de synchronisation de la base de donn"$e_acute"es%14s"
                               local PKG_NAMES1=($(grep _desc "$DTBFILE1"|cut -d '_' -f1|tr '\n' ' '))
                               [[ "${#PKG_NAMES1[@]}" -gt 0 && (( "${#PKG_NAMES1[@]}" -eq "${#PKG_NAMES0[@]}" )) ]] &&
                               printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n"
                               printf "cr"$e_acute"ation d'une base de donn"$e_acute"es temporaire%18s"
                               local tmp_database0="$(mktemp /tmp/$LOGFILE.XXXXXX)" && chmod u+x $tmp_database0 && printf "[ \e[92mok\e[0m ]\n"
                               if [[ "${#PKG_NAMES1[@]}" -ne "${#PKG_NAMES0[@]}" ]]; then
                               printf "test de r"$e_acute"cup"$e_acute"ration rapide%32s"
                               if [[ "${#PKG_NAMES1[@]}" -lt "${#PKG_NAMES0[@]}" ]]; then
                               local first_pkg="$(cut -d' ' -f1 <<< ${PKG_NAMES1[@]} )"
                               local last_pkg="$(rev <<< ${PKG_NAMES1[@]}|cut -d' ' -f1|rev)"
                               sed -n "/$first_pkg.*_pth/I,/}.*$last_pkg/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               $tmp_database0 "$last_pkg"_pth  &>/dev/null
                               [ $? -eq 0 ] && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n" &&
                               printf "sauvegarde de la base de donn"$e_acute"es temporaire%16s"
                               local tmp_database1="/tmp/$LOGFILE" && mv $tmp_database0 $tmp_database1 &&
                               printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n" &&
                               printf "v"$e_acute"rification des donn"$e_acute"es restant%27s"
                               sed -i "/$first_pkg.*_pth/I,/}.*$last_pkg/I d ; /^$/d" $DTBFILE0
                               sed -i '/^'}'/a\\' $DTBFILE0 && printf "[ \e[92mok\e[0m ]\n" || printf "[ \e[93mfailed\e[0m ]\n"
                               printf 'recherche des erreurs ...%36s'
                               local LAST_PKG_NAMES0=($(grep _pth "$DTBFILE0"|cut -d '_' -f1|tr '\n' ' '))
                               >$tmp_database0 && chmod u+x $tmp_database0
                               for pkg_name in ${LAST_PKG_NAMES0[@]}; do
                               sed -i -e '/'"$PARSEID"'/,$d' $tmp_database0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               if $tmp_database0 "$pkg_name"_pth &>/dev/null; then
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database1
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               continue
                               else
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0
                               sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 && cat $tmp_database1 >> $DTBFILE0 && sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 
                               sed -i '/^'}'/a\\' $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               printf '#####################################################################################################\n' >> $DTBFILE0
                               printf '########################### error: cannot properly read this section\n\n' >> $DTBFILE0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $tmp_database0 >> $DTBFILE0
                               printf '\n#####################################################################################################\n' >> $DTBFILE0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $DTBFILE0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $DTBFILE0
                               find /tmp \( -iname tif.* -o -iname $LOGFILE -o -iname $LOGFILE.* \) -delete ; rm -rf $FAKEROOT
                               printf "\n\e[91merreur:\e[0m  impossible de lire cette derni"$e_grave"re section '"$pkg_name"_pth'\n\e[2mdans '$DTBFILE0'\e[0m\n"
                               exit $ERCODE
                               fi
                               done
                               fi
                               else
                               printf 'recherche des erreurs ...%34s'
                               local tmp_database1="/tmp/$LOGFILE"
                               >$tmp_database0 && chmod u+x $tmp_database0
                               for pkg_name in ${PKG_NAMES0[@]}; do
                               sed -i -e '/'"$PARSEID"'/,$d' $tmp_database0
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database0
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $tmp_database0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $tmp_database0
                               if $tmp_database0 "$pkg_name"_pth &>/dev/null; then
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> $tmp_database1
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               continue
                               else
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0
                               # sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $DTBFILE0 >> "$PKGDIR/database/check_me"
                               sed -n "/$pkg_name.*_pth/I,/}.*$pkg_name/I p" $tmp_database0 >> "$PKGDIR/database/check_me"
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               sed -i "/$pkg_name.*_pth/I,/}.*$pkg_name/I d ; /^$/d" $tmp_database0
                               continue
                               fi
                               done
                               sed -i '/^.*_pth/,$d' $DTBFILE0 ; sed -i -e '/'"$PARSEID"'/,$d' $DTBFILE0 && cat $tmp_database1 >> $DTBFILE0 &&
                               sed -i '/^'}'/a\\' $DTBFILE0 && sed -i '/^'}'/a\\' $DTBFILE0
                               sed -i '/^'}'/a\\' "$PKGDIR/database/check_me" ; printf '\n' >> "$PKGDIR/database/check_me"
                               printf '%b\n\n\n'"$PARSEID"'\n[ -z $1 ] && exit '$dtb_ercode'\n' >> $DTBFILE0
                               printf '( $1 &>/dev/null ) && $1 || exit '$dtb_ercode'\n'        >> $DTBFILE0
                               find /tmp \( -iname tif.* -o -iname $LOGFILE -o -iname $LOGFILE.* \) -delete ; rm -rf $FAKEROOT
                               printf "[ \e[92mok\e[0m ]\n"
                               printf "\nveillez examiner le fichier '$PKGDIR/database/check_me'\n"                             
                               printf "puis recopier son contenu dans '$DTBFILE0' apr"$e_grave"s avoir corriger les erreurs.\n"
                               fi
                               ;;
                               -r)
                               local FNAME=".asosdtb"
                               if [ -f "$PKGDIR/database/$FNAME" ]; then
                               chattr -i "$DTBFILE0" "$DTBFILE1" ; rm -f "$DTBFILE0.bck" "$DTBFILE0" "$DTBFILE1"
                               tar -xf "$PKGDIR/database/$FNAME" -C "$PKGDIR/database/" && chattr +i "$DTBFILE0" "$DTBFILE1"
                               check_dtb -g -f
                               else
                               printf "\e[91merreur fatale:\e[0m fichiers de r"$e_acute"cup"$e_acute"ration inexistants\n"
                               exit $ERCODE
                               fi                         
                               ;;
                               esac                        
                           
                           }
                           
                           
                           
                           
                           
        





###################################    Options d'analyse generale    (la parse zone)
############################################################################################################
############################################################################################################
# tri et codage des arguments
input=(); extra_0=(); extra_1=(); file=(); fatal=(); positionnal=() opt_end=
[[ "$#" -gt 0 ]] && optin="y:$#"; while [[ $# -gt 0 ]]; do
arg="$1"; shift; case "${opt_end}${arg}" in
-rtf|-pi|-ip|-aq|-qa|-qq|-wh|-eh|-pe|-ep|--*) args+=("$arg") ;;
-ob|-bo|-io|-oi|-br|-or|-ro|-rb|-lr|-rl|-ri|-ir|[[:punct:]]) fatal+=("$arg") ;;
-*) for i in $(seq 2 ${#arg}); do args+=("-${arg:i-1:1}"); done ;;
*) args+=("$arg") ;; esac done;   set -- "${args[@]}"

while [[ $# -gt 0 ]]; do
  arg="$1"; shift
  case "${opt_end}${arg}" in
    --)                                           fatal+=("$arg"); opt_end=1 ;;
    -rtf|--remnant-files)                         input+=("c") ;;
    --root=*|-r=*)                                extra_0+=("${arg#*=}") ; r+=("1") ;;
    --destdir=*)                                  extra_1+=("${arg#*=}") ; r+=("2") ;;
    -r*|--root*)                                  extra_0+=("$1") ; r+=("1") ; shift ;;
    -o*|--destdir*)                               extra_1+=("$1") ; r+=("2") ; shift ;;
    infos|'info')                                 input+=("a") ;;
    -v|--version)                                 input+=("b") ;;
    -pe|-ep|--pkgbuild-example)                   input+=("i") ;;
    --depends|--depend)                           input+=("d") ;;
    -p|--path)                                    input+=("e") ;;
    -pi|-ip|--print-infos)                        input+=("f") ;;
    -l|--list)                                    input+=("g") ;;
    -h|--help)                                    input+=("h") ;;
    -R|--remove)                                  input+=("7") ;;
    -d|--debug)                                   input+=("0") ;;
    -q|--quiet)                                   input+=("1") ;;
    -qq|--quiet-all)                              input+=("2") ;;
    -qa|-aq|--always-quiet)                       input+=("3") ;;
    -wh|-eh|--enable-hash|--with-hash)            input+=("4") ;;
    -b|--build)                                   input+=("5") ;;
    -i|--install)                                 input+=("6") ;;
    --*)                                          fatal+=("$arg") ;;
    -*) for i in $(seq 2 ${#arg}); do input0+=("-${arg:i-1:1}"); done ;;
    *)                                            file+=("$arg") ;;
  esac
done

set -- ${positionnal[@]}

                 
    # verification de la syntaxe
    if [[ -v LV_BUILD && -n "$LV_BUILD" && $optin == y:[[:digit:]] ]]; then
    INT_MODE="$(tr '[:upper:]' '[:lower:]' <<< ${LV_BUILD//[[:punct:][:digit:]]})"
    if [[ "$INT_MODE" = on || "$INT_MODE" = y || "$INT_MODE" = yes  ]]; then
    if [[ "${input[@]}" = 5 && "${optin//[[:alpha:][:punct:]]}" -gt 1 ]] \
    || [[ "${input[@]}" =~ 5 && "${#input[@]}" -gt 1 ]]; then
    printf "\e[2mle mode interactif est activ"$e_acute" tapez \e[0m'sspm -b'\e[2m pour commencer\n\
    ou d"$e_acute"sinitialisez la variable 'LV_BUILD'\e[0m\n"; exit $ERCODE; fi fi fi
    N="$(cat <<< "${input0[@]}"|wc -w)"
    if [[ "${#input[@]}" -gt 1 && -n "$(tr ' ' '\n' <<< "${input[@]}" | sort |uniq -d|tr -d '\n')" ]]; then
    printf "sspm :  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi
    if [[ -n "${r[@]}" && (( "$extra_0" = \-[[:alpha:]] || "$extra_1" = \-[[:alpha:]] )) ]]; then
    printf "erreur de \e[91msyntaxe:\e[0m veillez indiquer un r"$e_acute"pertoire\n"; exit $ERCODE; fi    
    if [[ -n "$N" ]]; then if [[ "$N" -gt 1 ]]; then
    unknown_opt="$(sed 's/-p\|-i\|-l\|-h\|-o\|-R\|-q\|-b\|-d\|-v\|-r\|infos\|info\|--depends\|--depend//g; s/^ //g' <<< ${input0[@]})"
    if [[ -n "$unknown_opt" ]]; then
    printf "%ssspm :  option non reconnue -- '$(tr -d '[:punct:]' <<< $unknown_opt)'\nEssayez 'sspm --help' pour plus d'informations.\n"
    exit $ERCODE; else  printf "%serreur:  de syntaxe '$(cat <<< ${input0[@]})'\nEssayez 'sspm --help' pour plus d'informations.\n"
    exit $ERCODE; fi else  fatal+=("$input0"); if [[ -n "${fatal[@]}" ]]; then
    printf "%serreur:  option non reconnue -- '$(tr -d '[:punct:]' <<< ${fatal[@]})'\nEssayez 'sspm --help' pour plus d'informations.\n"
    exit $ERCODE; fi  fi  fi;  if [[ "${input[@]}" =~ [0-9] && (( "${input[@]}" =~ [a-z] || "${input[@]}" =~ [A-Z] )) ]]; then
    printf "sspm :  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi
    if [[ "${input[@]}" =~ '1' || "${input[@]}" =~ '2' || "${input[@]}" =~ '3' || "${input[@]}" =~ '4' ]]; then
    if [[ ! "${input[@]}" =~ '5' ]]; then
    printf "%serreur:  les options '-q*/--quiet* et -wh' ne peuvent "$e_circumflex"tre utilis"$e_acute"es que quand '-b' est pr"$e_acute"sent\n"
    exit $ERCODE; fi fi; if [[ "${input[@]}" =~ '7' && (( "${input[@]}" =~ '5' || "${input[@]}" =~ '6' )) ]]; then
    printf "erreur:  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi
    if [[ "${input[@]}" =~ '0' ]]; then if [[ "$EUID" != 0 || $(id -u) != 0 ]]; then
    printf "erreur:  vous devez "$e_circumflex"tre root pour lancer le mode d"$e_acute"bogage\n";  exit $ERCODE; fi fi
    if [[ "${input[@]}" =~ ^[[:alpha:][:space:]]+$ ]]; then if [[ "${#input[@]}" -gt 1 ]]; then
    printf "sspm :  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi
    elif [[ "${input[@]}" =~ '6' && ! "${input[@]}" =~ '5' ]]; then
    if [[ "${r[@]}" =~ 2 ]]; then
    printf "erreur de \e[91msyntaxe:\e[0m  '-o/--destdir' ne peut "$e_circumflex"tre utilis"$e_acute" que si:\n"
    printf "\e[90m'-b/--build' est pr"$e_acute"sent ou avec '-pe/--pkgbuild-example'\nEssayez 'sspm infos' pour plus d'informations.\n\e[0m"
    exit $ERCODE;  fi
    elif [[ "${input[@]}" =~ '5' && ! "${input[@]}" =~ 6 ]]; then
    if [[ "${r[@]}" =~ 1 ]]; then
    printf "erreur de \e[91msyntaxe:\e[0m  '-r/--root' ne peut "$e_circumflex"tre utilis"$e_acute" que si:\n"
    printf "\e[90m'-i/--install' est pr"$e_acute"sent ou avec '-p/--path' etc...\nEssayez 'sspm info' pour plus d'informations.\e[0m\n"
    exit $ERCODE;  fi
    elif [[ -z "${input[@]}" && (( -n "$extra_0" || -n "$extra_1" )) ]]; then
    if [[ "${r[@]}" = 1 ]]; then
    printf "erreur:  param"$e_grave"tre non compris\n\e[90m(ex: sspm -i -b -r /r"$e_acute"pertoire)\e[0m\n"
    printf "Essayez 'sspm info' pour plus d'informations.\n"; exit $ERCODE
    elif [[ "${r[@]}" = 2 ]]; then
    printf "erreur:  param"$e_grave"tre non compris\n\e[90m(ex: sspm --pkgbuild-example -o /r"$e_acute"pertoire)\e[0m\n"
    printf "Essayez 'sspm infos' pour plus d'informations.\n"; exit $ERCODE
    else printf "erreur:  de syntaxe\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE;  fi
    elif [[ -n "${file[@]}" && (( -z "${input[@]}" && -z "${fatal[@]}" )) ]]; then
    printf "erreur:  param"$e_grave"tre non compris\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE
    fi ;   if [[ -n "$r" ]]; then if [[ "${#r[@]}" = 1 ]]; then  if [[ "${r[@]}" = 1 ]]; then
    if [[ ! "${input[@]}" =~ [6-7] ]] && [[ "${input[@]}" != [e-g] ]]; then
    printf "erreur:  trop d'arguments, '-r/--root' ne peut pas "$e_circumflex"tre utilis"$e_acute" ici\nEssayez 'sspm infos' pour plus d'informations.\n"
    exit $ERCODE;  fi;  elif [[ "${r[@]}" = 2 ]]; then  if [[ ! "${input[@]}" =~ '5' && "${input[@]}" != 'i'  ]]; then
    printf "sspm :  trop d'arguments, '-o/--destdir' ne peut pas "$e_circumflex"tre utilis"$e_acute" ici\nEssayez 'sspm infos' pour plus d'informations.\n"
    exit $ERCODE;  fi  fi;  if [[ -z "$extra_0" && -z "$extra_1" ]]; then
    printf "%serreur:  argument(s) manquant(s) \nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE;  fi
    elif [[ "${#r[@]}" -gt 2 ]]; then printf "erreur:  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi fi
    if [[ "${input[@]}" = 'i' ]]; then if [[ -n "$r" && (( "${r[@]}" =~ 1 || "${r[@]}" = 1 )) ]]; then
    printf "sspm :  erreur trop d'arguments, '-r/--root' ne peut pas "$e_circumflex"tre utilis"$e_acute" ici\nEssayez 'sspm infos' pour plus d'informations.\n"
    exit $ERCODE;  fi fi;   if [[ "${input[@]}" =~ '5' && -n $file ]]; then  printf "%s\n" "Avertissement:  option non reconnue '$file'"; fi


# verification et execution de la requete
commande=(); variable=()

   [[ "${input[@]}" == 'a' ]] && commande=("sspm_infos")
   [[ "${input[@]}" == 'b' ]] && commande=("sspm_version")
   [[ "${input[@]}" == 'c' ]] && variable=("CLEANUP=y")
   [[ "${input[@]}" == 'd' ]] && commande=("sspm_depends")
   [[ "${input[@]}" == 'e' ]] && commande=("e")
   [[ "${input[@]}" == 'f' ]] && commande=("f")
   [[ "${input[@]}" == 'g' ]] && commande=("pkg_infos -l")
   [[ "${input[@]}" == 'h' ]] && commande=("usage")
   [[ "${input[@]}" == 'i' ]] && commande=("pkgbuild_example")
   [[ "${input[@]}" =~ '0' ]] && variable+=("DEBUG_MODE=y")
   [[ "${input[@]}" =~ '1' ]] && variable+=("STDOUT_MODE=s")
   [[ "${input[@]}" =~ '2' ]] && variable+=("STDOUT_MODE=qs")
   [[ "${input[@]}" =~ '3' ]] && variable+=("PERM_STDOUT_MODE=y")
   if [[ "${input[@]}" =~ '5' ]]; then
   [[ "${input[@]}" =~ '6' ]] && variable+=("NOEXIT=y")
   fi; if [[ "${input[@]}" =~ '6' ]]; then
   [[ "${input[@]}" =~ '5' ]] && variable+=("BIMODE=y")
   fi; [[ "${input[@]}" =~ '5' ]] && commande+=("5")
   [[ "${input[@]}" =~ '4' ]] && commande+=("4")
   [[ "${input[@]}" =~ '6' ]] && commande+=("6")
   [[ "${input[@]}" =~ '7' ]] && commande=("r")

[ -z "$variable" ] || declare ${variable[@]}

	
if [[ -n "$commande" ]]; then
if [[ $commande == 'e' || $commande == 'f' ]]; then
arg="$([ $commande = 'e' ] && printf '%s-p'; [ $commande = 'f' ] && printf '%s-pi')"
if [ -n "$file" ]; then if [ -z "$extra_0" ]; then if [[ ! "$file" == *['!'@#\$%^\&*()/]* ]]; then pkg_infos $arg $file
else printf "\e[91merreur \e[0mde syntaxe\e[0m\n\e[90mindiquez uniquement le nom du paquet\e[0m\n\e[90met assurez vous que\
%1sce dernier ne contient pas de caract"$e_grave"res sp"$e_acute"ciaux\e[0m\n"; exit $ERCODE; fi
else if [[ ! "$file" == *['!'@#\$%^\&*()/]* ]]; then if [ -d "$extra_0" ]; then pkg_infos $arg $file $extra_0
else printf "%serreur:  '$extra_0' n'est pas un r"$e_acute"pertoire ou n'existe pas\n"; exit $ERCODE; fi
else printf "\e[91merreur \e[0mde syntaxe\e[0m\n\e[90mindiquez uniquement le nom du paquet\e[0m\n\
\e[90met assurez vous que ce dernier ne contient pas de caract"$e_grave"res sp"$e_acute"ciaux\e[0m\n"
exit $ERCODE; fi  fi else printf "erreur:  veillez indiquer le nom d'un paquet\n"; exit $ERCODE; fi
elif [[ $commande == 'r' ]]; then if [ -n "$file" ]; then if [ -z "$extra_0" ]; then if [[ ! "$file" == *['!'@#\$%^\&*()/]* ]]; then remove_pkg $file
else printf "\e[91merreur \e[0mde syntaxe\e[0m\n\e[90mindiquez uniquement le nom du paquet\e[0m\n\e[90met assurez vous que\
%1sce dernier ne contient pas de caract"$e_grave"res sp"$e_acute"ciaux\e[0m\n"; exit $ERCODE; fi
else if [[ ! "$file" == *['!'@#\$%^\&*()/]* ]]; then if [ -d "$extra_0" ]; then remove_pkg $file $extra
else printf "%serreur:  '$extra_0' n'est pas un r"$e_acute"pertoire ou n'existe pas\n"; exit $ERCODE; fi
else printf "\e[91merreur \e[0mde syntaxe\e[0m\n\e[90mindiquez uniquement le nom du paquet\e[0m\n\
\e[90met assurez vous que ce dernier ne contient pas de caract"$e_grave"res sp"$e_acute"ciaux\e[0m\n"
exit $ERCODE; fi  fi else printf "erreur:  veillez indiquer le nom d'un paquet\n"; exit $ERCODE; fi
elif [[ "${commande[@]}" =~ "5" && (( ! "${commande[@]}" =~ "4" && ! "${commande[@]}" =~ "6" )) ]]; then make_build
elif [[ "${commande[@]}" =~ "6" && (( ! "${commande[@]}" =~ "5" )) ]]; then 
[ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "4" && (( ! "${commande[@]}" =~ "6" )) ]]; then make_build -wh
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "4" && "${commande[@]}" =~ "6" ]]; then
make_build -wh && [ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0
elif [[ "${commande[@]}" =~ "5" && "${commande[@]}" =~ "6" && (( ! "${commande[@]}" =~ "4" )) ]]; then
make_build && [ -z $extra_0 ] && make_install ${PKG_FILE:-$file} || make_install ${PKG_FILE:-$file} $extra_0; else $commande; fi
else if [ -z $variable ]; then usage; else if [[ ! "${variable[@]}" =~  ^"CLEANUP=y"$  ]]; then
printf "erreur:  trop d'arguments\nEssayez 'sspm --help' pour plus d'informations.\n"; exit $ERCODE; fi; fi; fi





#####################################################   fin d'analyse
####################################################################################################
####################################################################################################














                                                                       # Supprimer tout les fichiers temporaires restants
                                                                       # lors d'un arret brutal du processus
                                                                       # de compilation par exemple, etc ...
  
                                                                       if [[ -n $CLEANUP && $CLEANUP == [yY] ]]; then
                                                                          [[ ! -d "$TMP" ]] && printf "\e[91merreur: \
                                                                          \e[0mimpossible d'acc"$e_acute"der au \
                                                                          r"$e_acute"pertoire temporaire\n" && exit 1
                                                                          if [[ -n "$(find "$TMP" \( -name "*_build*" \
                                                                          -o -name "*_source*" -o -iname "*fakeroot*" \
                                                                          -o -name "*tif*" -o -name "*link*" -o -name "*msc*" \
                                                                          -o -name "*extractdir*" -o -name "*$BUILDFILE*" \) \
                                                                          -writable -type f,l,d 2>/dev/null )" ]]; then
                                                                          printf "Avertissement: cela effacera tous les"
                                                                          printf "%1sfichiers concern"$e_acute"s\n%16sdans%1s"
                                                                          printf "le%1sr"$e_acute"pertoire temporaire\n\n"
                                                                          read -p "Voulez-vous continuer ? (o/n) : " REP
                                                                          case $REP in  [oO] | '') printf '\n' ;;  [nN]) \
                                                                          printf '\n' && exit ;;  *) printf '\n' && exit ;; esac
                                                                          if [[ "${EUID:-$(id -u)}" -eq 0 ]]; then find "$TMP" \
                                                                          \( -name '*_build*' -o -iname "*fakeroot*" -o -name '*tif*' \
                                                                          -o -name "*$BUILDFILE*" -o -name '*msc*' -o -name '*link*' \
                                                                          -o -name '*extractdir*' -o -name 'tst*' -o -name '*_source*' \) \
                                                                          -type f,l,d -print0 | xargs -0 rm -rf && printf 'Fait\n\n'
                                                                          else find "$TMP" \( -name '*extractdir*' -o -iname "*fakeroot*" \
                                                                          -o -name '*_source*' -o -name "*$BUILDFILE*" -o -name '*msc*' \
                                                                          -o -name '*link*' -o -name 'tst*' -o -name '*_build*' -o -name \
                                                                          '*tif*' \) -writable -type f,l,d -print0 2>/dev/null | xargs -0 rm -rf && \
                                                                          printf 'Fait\n\n'; fi; exit; else printf 'vide  \n';exit; fi; fi




if [[ -n "$PERM_STDOUT_MODE" ]]; then if [[ "$PERM_STDOUT_MODE" = "y" ]]; then if [[ "$DIALOG" = "off" ]]; then
sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="on"/' "$SCRIPTFILE"; printf "\e[90mmessage de succ"$e_grave"s activ"$e_acute"\e[0m\n"
elif [[ "$DIALOG" = "on" ]]; then sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="off"/' "$SCRIPTFILE"
printf "\e[90mmessage de succ"$e_grave"s d"$e_acute"activ"$e_acute"\e[0m\n"; elif [[ -z "$DIALOG" ]]; then
sed -i -e '0,/\(^DIALOG=.*\)/s/DIALOG=.*/DIALOG="off"/' "$SCRIPTFILE"; printf "\e[90mmessage de succ"$e_grave"s d"$e_acute"activ"$e_acute"\e[0m\n"; fi fi fi

